diff --git a/sdk/mx.sdk/suite.py b/sdk/mx.sdk/suite.py
index 79c97354020..9518d41f5db 100644
--- a/sdk/mx.sdk/suite.py
+++ b/sdk/mx.sdk/suite.py
@@ -520,6 +520,8 @@ suite = {
       "javaCompliance" : "17+",
       "workingSets" : "Truffle,Tools",
       "checkstyle" : "org.graalvm.word",
+      # disable SpotBugs due to incorrect lazy initialization
+      "spotbugs" : "false",
       "graalCompilerSourceEdition": "ignore",
     },
     "org.graalvm.launcher.test" : {
diff --git a/truffle/src/com.oracle.truffle.api/src/com/oracle/truffle/api/impl/FrameWithoutBoxing.java b/truffle/src/com.oracle.truffle.api/src/com/oracle/truffle/api/impl/FrameWithoutBoxing.java
index de0c5fa02fa..d5f3b55e387 100644
--- a/truffle/src/com.oracle.truffle.api/src/com/oracle/truffle/api/impl/FrameWithoutBoxing.java
+++ b/truffle/src/com.oracle.truffle.api/src/com/oracle/truffle/api/impl/FrameWithoutBoxing.java
@@ -174,15 +174,15 @@ public final class FrameWithoutBoxing implements VirtualFrame, MaterializedFrame
             indexedTagsArray = EMPTY_BYTE_ARRAY;
         } else {
             indexedLocalsArray = new Object[indexedSize];
-            indexedPrimitiveLocalsArray = new long[indexedSize];
+            indexedPrimitiveLocalsArray = new long[indexedPrimitiveLengthTrimmed(indexedSize)];
             // Do not initialize tags, even for static slots. In practice, this means that it is
             // possible to statically access uninitialized slots.
-            indexedTagsArray = new byte[indexedSize];
-            if (defaultValue == ILLEGAL_DEFAULT) {
-                Arrays.fill(indexedTagsArray, ILLEGAL_TAG);
-            } else if (defaultValue != null) {
-                Arrays.fill(indexedLocalsArray, defaultValue);
-            }
+            indexedTagsArray = EMPTY_BYTE_ARRAY;
+            // if (defaultValue == ILLEGAL_DEFAULT) {
+            // Arrays.fill(indexedTagsArray, ILLEGAL_TAG);
+            // } else if (defaultValue != null) {
+            // Arrays.fill(indexedLocalsArray, defaultValue);
+            // }
         }
         if (auxiliarySize == 0) {
             auxiliarySlotsArray = EMPTY_OBJECT_ARRAY;
@@ -207,7 +207,7 @@ public final class FrameWithoutBoxing implements VirtualFrame, MaterializedFrame
         } else {
             defaultTag = OBJECT_TAG;
         }
-        Arrays.fill(this.indexedTags, defaultTag);
+        // Arrays.fill(this.indexedTags, defaultTag);
         Arrays.fill(this.indexedLocals, defaultValue);
         Arrays.fill(this.indexedPrimitiveLocals, 0L);
         Arrays.fill(this.auxiliarySlots, null);
@@ -812,20 +812,21 @@ public final class FrameWithoutBoxing implements VirtualFrame, MaterializedFrame
 
     @Override
     public Object getObjectStatic(int slot) {
-        assert checkStaticGet(slot, STATIC_OBJECT_TAG) : "Unexpected read of static object value";
+        // assert checkStaticGet(slot, STATIC_OBJECT_TAG) : "Unexpected read of static object
+        // value";
 
-        return getIndexedLocals()[slot];
+        return unsafeGetObject(getIndexedLocals(), getObjectOffset(slot), true, OBJECT_LOCATION);
     }
 
     @Override
     public void setObjectStatic(int slot, Object value) {
-        assert checkStatic(slot) : UNEXPECTED_STATIC_WRITE;
+        // assert checkStatic(slot) : UNEXPECTED_STATIC_WRITE;
         // We use this check instead of the assert keyword to update the tags in PE'd code.
-        if (ASSERTIONS_ENABLED) {
-            indexedTags[slot] = STATIC_OBJECT_TAG;
-        }
+        // if (ASSERTIONS_ENABLED) {
+        // indexedTags[slot] = STATIC_OBJECT_TAG;
+        // }
 
-        getIndexedLocals()[slot] = value;
+        unsafePutObject(getIndexedLocals(), getObjectOffset(slot), value, OBJECT_LOCATION);
     }
 
     @Override
@@ -866,36 +867,36 @@ public final class FrameWithoutBoxing implements VirtualFrame, MaterializedFrame
 
     @Override
     public int getIntStatic(int slot) {
-        assert checkStaticGet(slot, STATIC_INT_TAG) : "Unexpected read of static int value";
+        // assert checkStaticGet(slot, STATIC_INT_TAG) : "Unexpected read of static int value";
 
-        return narrow(getIndexedPrimitiveLocals()[slot]);
+        return unsafeGetLongAndNarrowInt(getIndexedPrimitiveLocals(), getPrimitiveOffset(slot), true, PRIMITIVE_LOCATION);
     }
 
     @Override
     public void setIntStatic(int slot, int value) {
-        assert checkStatic(slot) : UNEXPECTED_STATIC_WRITE;
+        // assert checkStatic(slot) : UNEXPECTED_STATIC_WRITE;
         // We use this check instead of the assert keyword to update the tags in PE'd code.
-        if (ASSERTIONS_ENABLED) {
-            indexedTags[slot] = STATIC_INT_TAG;
-        }
+        // if (ASSERTIONS_ENABLED) {
+        // indexedTags[slot] = STATIC_INT_TAG;
+        // }
 
-        getIndexedPrimitiveLocals()[slot] = extend(value);
+        unsafePutLongAndExtendInt(getIndexedPrimitiveLocals(), getPrimitiveOffset(slot), value, PRIMITIVE_LOCATION);
     }
 
     @Override
     public long getLongStatic(int slot) {
-        assert checkStaticGet(slot, STATIC_LONG_TAG) : "Unexpected read of static long value";
+        // assert checkStaticGet(slot, STATIC_LONG_TAG) : "Unexpected read of static long value";
 
-        return getIndexedPrimitiveLocals()[slot];
+        return unsafeGetLong(slot);
     }
 
     @Override
     public void setLongStatic(int slot, long value) {
-        assert checkStatic(slot) : UNEXPECTED_STATIC_WRITE;
+        // assert checkStatic(slot) : UNEXPECTED_STATIC_WRITE;
         // We use this check instead of the assert keyword to update the tags in PE'd code.
-        if (ASSERTIONS_ENABLED) {
-            indexedTags[slot] = STATIC_LONG_TAG;
-        }
+        // if (ASSERTIONS_ENABLED) {
+        // indexedTags[slot] = STATIC_LONG_TAG;
+        // }
 
         getIndexedPrimitiveLocals()[slot] = value;
     }
@@ -1071,13 +1072,13 @@ public final class FrameWithoutBoxing implements VirtualFrame, MaterializedFrame
         } else if (sourceOffset < 0) {
             CompilerDirectives.transferToInterpreterAndInvalidate();
             throw new IndexOutOfBoundsException("Illegal sourceOffset passed.");
-        } else if (sourceOffset + length > getIndexedTags().length) {
+        } else if (sourceOffset + length > getIndexedLocals().length) {
             CompilerDirectives.transferToInterpreterAndInvalidate();
             throw new IndexOutOfBoundsException("Illegal sourceOffset or length passed.");
         } else if (destinationOffset < 0) {
             CompilerDirectives.transferToInterpreterAndInvalidate();
             throw new IndexOutOfBoundsException("Illegal destinationOffset passed.");
-        } else if (destinationOffset + length > o.getIndexedTags().length) {
+        } else if (destinationOffset + length > o.getIndexedLocals().length) {
             CompilerDirectives.transferToInterpreterAndInvalidate();
             throw new IndexOutOfBoundsException("Illegal destinationOffset or length passed.");
         }
@@ -1091,9 +1092,13 @@ public final class FrameWithoutBoxing implements VirtualFrame, MaterializedFrame
 
         // eventually we might want to optimize this further using Unsafe.
         // for now System.arrayCopy is fast enough.
-        System.arraycopy(getIndexedTags(), srcOffset, o.getIndexedTags(), dstOffset, length);
+        // System.arraycopy(getIndexedTags(), srcOffset, o.getIndexedTags(), dstOffset, length);
         System.arraycopy(getIndexedLocals(), srcOffset, o.getIndexedLocals(), dstOffset, length);
-        System.arraycopy(getIndexedPrimitiveLocals(), srcOffset, o.getIndexedPrimitiveLocals(), dstOffset, length);
+        System.arraycopy(getIndexedPrimitiveLocals(), srcOffset, o.getIndexedPrimitiveLocals(), dstOffset, indexedPrimitiveLengthTrimmed(length));
+    }
+
+    private int indexedPrimitiveLengthTrimmed(final int length) {
+        return Math.min(2, length);
     }
 
     @Override
@@ -1177,18 +1182,18 @@ public final class FrameWithoutBoxing implements VirtualFrame, MaterializedFrame
      * @param slot The slot that should be transferred
      */
     void transferOSRStaticSlot(FrameWithoutBoxing target, int slot) {
-        if (ASSERTIONS_ENABLED) {
-            final byte tag = indexedTags[slot];
-            indexedTags[slot] = STATIC_OBJECT_TAG;
-            target.setObjectStatic(slot, getObjectStatic(slot));
-            indexedTags[slot] = STATIC_LONG_TAG;
-            target.setLongStatic(slot, getLongStatic(slot));
-            indexedTags[slot] = tag;
-            target.setStaticSlotTag(slot, tag);
-        } else {
-            target.setObjectStatic(slot, getObjectStatic(slot));
-            target.setLongStatic(slot, getLongStatic(slot));
-        }
+        // if (ASSERTIONS_ENABLED) {
+        // final byte tag = indexedTags[slot];
+        // indexedTags[slot] = STATIC_OBJECT_TAG;
+        // target.setObjectStatic(slot, getObjectStatic(slot));
+        // indexedTags[slot] = STATIC_LONG_TAG;
+        // target.setLongStatic(slot, getLongStatic(slot));
+        // indexedTags[slot] = tag;
+        // target.setStaticSlotTag(slot, tag);
+        // } else {
+        target.setObjectStatic(slot, getObjectStatic(slot));
+        target.setLongStatic(slot, getLongStatic(slot));
+        // }
     }
 
     private void setStaticSlotTag(int slot, byte tag) {
diff --git a/truffle/src/com.oracle.truffle.api/src/com/oracle/truffle/api/nodes/NodeUtil.java b/truffle/src/com.oracle.truffle.api/src/com/oracle/truffle/api/nodes/NodeUtil.java
index 10b976c323e..18e3fd6a8a8 100644
--- a/truffle/src/com.oracle.truffle.api/src/com/oracle/truffle/api/nodes/NodeUtil.java
+++ b/truffle/src/com.oracle.truffle.api/src/com/oracle/truffle/api/nodes/NodeUtil.java
@@ -175,7 +175,7 @@ public final class NodeUtil {
             current = current.getParent();
         } while (current != null);
 
-        if (!(prev instanceof ExecutableNode)) {
+        if (prev.isAdoptable() && !(prev instanceof ExecutableNode)) {
             failNotAdopted(node, prev);
         }
         return true;
diff --git a/truffle/src/com.oracle.truffle.runtime/src/com/oracle/truffle/runtime/BytecodeOSRMetadata.java b/truffle/src/com.oracle.truffle.runtime/src/com/oracle/truffle/runtime/BytecodeOSRMetadata.java
index 37ce96b318d..4118d192ff4 100644
--- a/truffle/src/com.oracle.truffle.runtime/src/com/oracle/truffle/runtime/BytecodeOSRMetadata.java
+++ b/truffle/src/com.oracle.truffle.runtime/src/com/oracle/truffle/runtime/BytecodeOSRMetadata.java
@@ -431,17 +431,16 @@ public final class BytecodeOSRMetadata {
             CompilerDirectives.transferToInterpreterAndInvalidate();
             throw new IllegalArgumentException("Transferring frame for OSR from an uninitialized bytecode target.");
         }
-        if (!(targetMetadata instanceof OsrEntryDescription)) {
+        if (!(targetMetadata instanceof OsrEntryDescription description)) {
             CompilerDirectives.transferToInterpreterAndInvalidate();
             throw new IllegalArgumentException("Wrong usage of targetMetadata during OSR frame transfer.");
         }
-
-        OsrEntryDescription description = (OsrEntryDescription) targetMetadata;
         CompilerAsserts.partialEvaluationConstant(description);
 
         OptimizedRuntimeAccessor.ACCESSOR.startOSRFrameTransfer(target);
         // Transfer indexed frame slots
-        transferLoop(description.indexedFrameTags, source, target);
+        // transferLoop(description.indexedFrameTags, source, target);
+        source.copyTo(0, target, 0, source.getFrameDescriptor().getNumberOfSlots());
         // transfer auxiliary slots
         transferAuxiliarySlots(source, target, state);
     }
@@ -495,7 +494,8 @@ public final class BytecodeOSRMetadata {
         // state.frameDescriptor to restoreLoop in order to correctly account for static slots.
 
         // transfer indexed frame slots
-        restoreLoop(state.frameDescriptor, source, target);
+        // restoreLoop(state.frameDescriptor, source, target);
+        source.copyTo(0, target, 0, source.getFrameDescriptor().getNumberOfSlots());
         // transfer auxiliary slots
         transferAuxiliarySlots(source, target, state);
     }
@@ -533,19 +533,18 @@ public final class BytecodeOSRMetadata {
             byte actualTag = source.getTag(i);
             byte expectedTag = expectedTags[i];
 
-            if (expectedTag == FrameWithoutBoxing.STATIC_TAG) {
+            if (expectedTag != FrameWithoutBoxing.STATIC_TAG) {
                 // Here we can skip incompatible tag check in case of static slot since the frame
                 // descriptor has not changed (checked as pre-condition in 'validateDescriptor').
                 // This allows uninitialized static slots (tag == 0) to pass through (and transfer
                 // with 'tag == STATIC')
-                actualTag = FrameWithoutBoxing.STATIC_TAG;
-            }
-            boolean incompatibleTags = expectedTag != actualTag;
-            if (incompatibleTags) {
-                // The tag for this slot may have changed; if so, deoptimize and update it.
-                CompilerDirectives.transferToInterpreterAndInvalidate();
-                expectedTags[i] = actualTag;
-                continue; // try again with updated tags.
+                boolean incompatibleTags = expectedTag != actualTag;
+                if (incompatibleTags) {
+                    // The tag for this slot may have changed; if so, deoptimize and update it.
+                    CompilerDirectives.transferToInterpreterAndInvalidate();
+                    expectedTags[i] = actualTag;
+                    continue; // try again with updated tags.
+                }
             }
 
             transferIndexedFrameSlot(source, target, i, expectedTag);
