/*
 * Copyright (c) 2017-2020 Software Architecture Group, Hasso Plattner Institute
 *
 * Licensed under the MIT License.
 */
package de.hpi.swa.graal.squeak.nodes.plugins;

import java.util.function.LongBinaryOperator;

import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.CompilerDirectives.CompilationFinal;

import de.hpi.swa.graal.squeak.exceptions.PrimitiveExceptions.PrimitiveFailed;
import de.hpi.swa.graal.squeak.exceptions.SqueakExceptions.SqueakException;
import de.hpi.swa.graal.squeak.model.AbstractSqueakObject;
import de.hpi.swa.graal.squeak.model.FloatObject;
import de.hpi.swa.graal.squeak.model.LargeIntegerObject;
import de.hpi.swa.graal.squeak.model.NativeObject;
import de.hpi.swa.graal.squeak.model.NilObject;
import de.hpi.swa.graal.squeak.model.PointersObject;
import de.hpi.swa.graal.squeak.model.VariablePointersObject;
import de.hpi.swa.graal.squeak.model.layout.ObjectLayouts.FORM;
import de.hpi.swa.graal.squeak.nodes.SqueakGuards;
import de.hpi.swa.graal.squeak.util.UnsafeUtils;

/* Automatically generated by
   SmartSyntaxPluginCodeGenerator * VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1
    from
   BitBltSimulation * VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1
 */

public final class BitBlt {
    /* Constants */
    private static final long ALL_ONES = 0xFFFFFFFFL;
    private static final int ALPHA_INDEX = 3;
    private static final int BB_CLIP_HEIGHT_INDEX = 13;
    private static final int BB_CLIP_WIDTH_INDEX = 12;
    private static final int BB_CLIP_X_INDEX = 10;
    private static final int BB_CLIP_Y_INDEX = 11;
    private static final int BB_COLOR_MAP_INDEX = 14;
    private static final int BB_DEST_FORM_INDEX = 0;
    private static final int BB_DEST_X_INDEX = 4;
    private static final int BB_DEST_Y_INDEX = 5;
    private static final int BB_HALFTONE_FORM_INDEX = 2;
    private static final int BB_HEIGHT_INDEX = 7;
    private static final int BB_RULE_INDEX = 3;
    private static final int BB_SOURCE_FORM_INDEX = 1;
    private static final int BB_SOURCE_X_INDEX = 8;
    private static final int BB_SOURCE_Y_INDEX = 9;
    private static final int BB_WARP_BASE = 15;
    private static final int BB_WIDTH_INDEX = 6;
    // private static final int BE_BITBLT_INDEX = 2;
    private static final int BINARY_POINT = 14;
    private static final int BLUE_INDEX = 2;
    private static final int COLOR_MAP_FIXED_PART = 2;
    private static final int COLOR_MAP_INDEXED_PART = 4;
    private static final int COLOR_MAP_NEW_STYLE = 8;
    private static final int COLOR_MAP_PRESENT = 1;
    private static final int FIXED_PT1 = 0x4000;
    private static final int GREEN_INDEX = 1;
    private static final int OP_TABLE_SIZE = 43;
    private static final int RED_INDEX = 0;

    /* Return the default translation table from 1..8 bit indexed colors to 32bit */
    /* The table has been generated by the following statements */
    /*
     * | pvs hex | String streamContents:[:s| s nextPutAll:'static long theTable[256] = { '. pvs :=
     * (Color colorMapIfNeededFrom: 8 to: 32) asArray. 1 to: pvs size do:[:i| i > 1 ifTrue:[s
     * nextPutAll:', ']. (i-1 \\ 8) = 0 ifTrue:[s cr]. s nextPutAll:'0x'. hex := (pvs at: i)
     * printStringBase: 16. s nextPutAll: (hex copyFrom: 4 to: hex size). ]. s nextPutAll:'};'. ].
     */

    /* BitBltSimulation>>#default8To32Table */
    @CompilationFinal(dimensions = 1) private static final long[] DEFAULT_8_TO_32_TABLE = new long[]{
                    0x0L, 0xFF000001L, 0xFFFFFFFFL, 0xFF808080L, 0xFFFF0000L, 0xFF00FF00L, 0xFF0000FFL, 0xFF00FFFFL,
                    0xFFFFFF00L, 0xFFFF00FFL, 0xFF202020L, 0xFF404040L, 0xFF606060L, 0xFF9F9F9FL, 0xFFBFBFBFL, 0xFFDFDFDFL,
                    0xFF080808L, 0xFF101010L, 0xFF181818L, 0xFF282828L, 0xFF303030L, 0xFF383838L, 0xFF484848L, 0xFF505050L,
                    0xFF585858L, 0xFF686868L, 0xFF707070L, 0xFF787878L, 0xFF878787L, 0xFF8F8F8FL, 0xFF979797L, 0xFFA7A7A7L,
                    0xFFAFAFAFL, 0xFFB7B7B7L, 0xFFC7C7C7L, 0xFFCFCFCFL, 0xFFD7D7D7L, 0xFFE7E7E7L, 0xFFEFEFEFL, 0xFFF7F7F7L,
                    0xFF000001L, 0xFF003300L, 0xFF006600L, 0xFF009900L, 0xFF00CC00L, 0xFF00FF00L, 0xFF000033L, 0xFF003333L,
                    0xFF006633L, 0xFF009933L, 0xFF00CC33L, 0xFF00FF33L, 0xFF000066L, 0xFF003366L, 0xFF006666L, 0xFF009966L,
                    0xFF00CC66L, 0xFF00FF66L, 0xFF000099L, 0xFF003399L, 0xFF006699L, 0xFF009999L, 0xFF00CC99L, 0xFF00FF99L,
                    0xFF0000CCL, 0xFF0033CCL, 0xFF0066CCL, 0xFF0099CCL, 0xFF00CCCCL, 0xFF00FFCCL, 0xFF0000FFL, 0xFF0033FFL,
                    0xFF0066FFL, 0xFF0099FFL, 0xFF00CCFFL, 0xFF00FFFFL, 0xFF330000L, 0xFF333300L, 0xFF336600L, 0xFF339900L,
                    0xFF33CC00L, 0xFF33FF00L, 0xFF330033L, 0xFF333333L, 0xFF336633L, 0xFF339933L, 0xFF33CC33L, 0xFF33FF33L,
                    0xFF330066L, 0xFF333366L, 0xFF336666L, 0xFF339966L, 0xFF33CC66L, 0xFF33FF66L, 0xFF330099L, 0xFF333399L,
                    0xFF336699L, 0xFF339999L, 0xFF33CC99L, 0xFF33FF99L, 0xFF3300CCL, 0xFF3333CCL, 0xFF3366CCL, 0xFF3399CCL,
                    0xFF33CCCCL, 0xFF33FFCCL, 0xFF3300FFL, 0xFF3333FFL, 0xFF3366FFL, 0xFF3399FFL, 0xFF33CCFFL, 0xFF33FFFFL,
                    0xFF660000L, 0xFF663300L, 0xFF666600L, 0xFF669900L, 0xFF66CC00L, 0xFF66FF00L, 0xFF660033L, 0xFF663333L,
                    0xFF666633L, 0xFF669933L, 0xFF66CC33L, 0xFF66FF33L, 0xFF660066L, 0xFF663366L, 0xFF666666L, 0xFF669966L,
                    0xFF66CC66L, 0xFF66FF66L, 0xFF660099L, 0xFF663399L, 0xFF666699L, 0xFF669999L, 0xFF66CC99L, 0xFF66FF99L,
                    0xFF6600CCL, 0xFF6633CCL, 0xFF6666CCL, 0xFF6699CCL, 0xFF66CCCCL, 0xFF66FFCCL, 0xFF6600FFL, 0xFF6633FFL,
                    0xFF6666FFL, 0xFF6699FFL, 0xFF66CCFFL, 0xFF66FFFFL, 0xFF990000L, 0xFF993300L, 0xFF996600L, 0xFF999900L,
                    0xFF99CC00L, 0xFF99FF00L, 0xFF990033L, 0xFF993333L, 0xFF996633L, 0xFF999933L, 0xFF99CC33L, 0xFF99FF33L,
                    0xFF990066L, 0xFF993366L, 0xFF996666L, 0xFF999966L, 0xFF99CC66L, 0xFF99FF66L, 0xFF990099L, 0xFF993399L,
                    0xFF996699L, 0xFF999999L, 0xFF99CC99L, 0xFF99FF99L, 0xFF9900CCL, 0xFF9933CCL, 0xFF9966CCL, 0xFF9999CCL,
                    0xFF99CCCCL, 0xFF99FFCCL, 0xFF9900FFL, 0xFF9933FFL, 0xFF9966FFL, 0xFF9999FFL, 0xFF99CCFFL, 0xFF99FFFFL,
                    0xFFCC0000L, 0xFFCC3300L, 0xFFCC6600L, 0xFFCC9900L, 0xFFCCCC00L, 0xFFCCFF00L, 0xFFCC0033L, 0xFFCC3333L,
                    0xFFCC6633L, 0xFFCC9933L, 0xFFCCCC33L, 0xFFCCFF33L, 0xFFCC0066L, 0xFFCC3366L, 0xFFCC6666L, 0xFFCC9966L,
                    0xFFCCCC66L, 0xFFCCFF66L, 0xFFCC0099L, 0xFFCC3399L, 0xFFCC6699L, 0xFFCC9999L, 0xFFCCCC99L, 0xFFCCFF99L,
                    0xFFCC00CCL, 0xFFCC33CCL, 0xFFCC66CCL, 0xFFCC99CCL, 0xFFCCCCCCL, 0xFFCCFFCCL, 0xFFCC00FFL, 0xFFCC33FFL,
                    0xFFCC66FFL, 0xFFCC99FFL, 0xFFCCCCFFL, 0xFFCCFFFFL, 0xFFFF0000L, 0xFFFF3300L, 0xFFFF6600L, 0xFFFF9900L,
                    0xFFFFCC00L, 0xFFFFFF00L, 0xFFFF0033L, 0xFFFF3333L, 0xFFFF6633L, 0xFFFF9933L, 0xFFFFCC33L, 0xFFFFFF33L,
                    0xFFFF0066L, 0xFFFF3366L, 0xFFFF6666L, 0xFFFF9966L, 0xFFFFCC66L, 0xFFFFFF66L, 0xFFFF0099L, 0xFFFF3399L,
                    0xFFFF6699L, 0xFFFF9999L, 0xFFFFCC99L, 0xFFFFFF99L, 0xFFFF00CCL, 0xFFFF33CCL, 0xFFFF66CCL, 0xFFFF99CCL,
                    0xFFFFCCCCL, 0xFFFFFFCCL, 0xFFFF00FFL, 0xFFFF33FFL, 0xFFFF66FFL, 0xFFFF99FFL, 0xFFFFCCFFL, 0xFFFFFFFFL};

    /* Variables */
    private int affectedB;
    private int affectedL;
    private int affectedR;
    private int affectedT;
    private int bbH;
    private int bbW;
    private PointersObject bitBltOop;
    private long bitCount;
    private int clipHeight;
    private int clipWidth;
    private int clipX;
    private int clipY;
    private long cmBitsPerColor;
    private long cmFlags;
    private int[] cmLookupTable;
    private long cmMask;

    /** Used in {@link BitBlt#setupColorMasksFromto}. */
    private final int[] cmMaskTableTemplate = new int[]{0, 0, 0, 0};
    private final int[] cmShiftTableTemplate = new int[]{0, 0, 0, 0};

    private int[] cmMaskTable;
    private int[] cmShiftTable;
    private int combinationRule;
    private long componentAlphaModeAlpha;
    private long componentAlphaModeColor;
    private int[] destBits;
    private byte[] destBytes;
    private long destDelta;
    private int destDepth;
    private PointersObject destForm;
    private int destHeight;
    private long destIndex;
    private long destMask;
    private boolean destMSB;
    private int destPitch;
    private int destPPW;
    private int destWidth;
    private int destX;
    private int destY;
    @CompilationFinal(dimensions = 1) private static final int[] DITHER_8_LOOKUP = new int[4096];
    @CompilationFinal(dimensions = 1) private static final int[] DITHER_MATRIX_4X4 = new int[]{
                    0, 8, 2, 10,
                    12, 4, 14, 6,
                    3, 11, 1, 9,
                    15, 7, 13, 5
    };
    @CompilationFinal(dimensions = 1) private static final int[] DITHER_THRESHOLDS_16 = new int[]{0, 2, 4, 6, 8, 12, 14, 16};
    @CompilationFinal(dimensions = 1) private static final int[] DITHER_VALUES_16 = new int[]{
                    0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30
    };
    private long dstBitShift;
    private int dx;
    private int dy;
    private long endOfDestination;
    private long endOfSource;
    private long[] gammaLookupTable;
    private AbstractSqueakObject halftoneForm;
    private int[] halftoneBits;
    private long halftoneHeight;
    private boolean hasSurfaceLock;
    private long hDir;
    private int height;
    @SuppressWarnings("unused") private boolean isWarping;
    private long mask1;
    private long mask2;
    @CompilationFinal(dimensions = 1) private static final int[] MASK_TABLE = new int[]{
                    0, 1, 3, 0, 15, 31, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 65535,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1
    };
    private static final String MODULE_NAME = "BitBltPlugin * VMMaker.oscog-eem.2480 (GraalSqueak)";
    private boolean noHalftone;
    private boolean noSource;
    private int nWords;
    @CompilationFinal(dimensions = 1) private final LongBinaryOperator[] opTable = new LongBinaryOperator[43];
    private boolean preload;
    private long skew;
    private long sourceAlpha;
    private Object sourceBits;
    private boolean sourceBitsIsWords;
    private long sourceDelta;
    private int sourceDepth;
    private PointersObject sourceForm;
    private int sourceHeight;
    private long sourceIndex;
    private boolean sourceMSB;
    private int sourcePitch;
    private int sourcePPW;
    private int sourceWidth;
    private int sourceX;
    private int sourceY;
    private long srcBitShift;
    private int sx;
    private int sy;
    private long[] ungammaLookupTable;
    private long vDir;
    private long warpAlignMask;
    private long warpAlignShift;
    private int[] warpBitShiftTable = new int[32];
    private long warpSrcMask;
    private long warpSrcShift;
    private int width;

    private boolean successFlag = false;

    public BitBlt() {
        initialiseModule();
    }

    /* BitBltSimulation>>#addWord:with: */
    private long addWordwith(final long sourceWord, final long destinationWord) {
        return sourceWord + destinationWord;
    }

    /* BitBltSimulation>>#alphaBlendConst:with: */
    private long alphaBlendConstwith(final long sourceWord, final long destinationWord) {
        return alphaBlendConstwithpaintMode(sourceWord, destinationWord, false);
    }

    /*
     * Blend sourceWord with destinationWord using a constant alpha. Alpha is encoded as 0 meaning
     * 0.0, and 255 meaning 1.0. The blend produced is alpha*source + (1.0-alpha)*dest, with the
     * computation being performed independently on each color component. This function could
     * eventually blend into any depth destination, using the same color averaging and mapping as
     * warpBlt. paintMode = true means do nothing if the source pixel value is zero.
     */
    /*
     * This first implementation works with dest depths of 16 and 32 bits only. Normal color mapping
     * will allow sources of lower depths in this case, and results can be mapped directly by
     * truncation, so no extra color maps are needed. To allow storing into any depth will require
     * subsequent addition of two other colormaps, as is the case with WarpBlt.
     */

    /* BitBltSimulation>>#alphaBlendConst:with:paintMode: */
    private long alphaBlendConstwithpaintMode(final long sourceWord, final long destinationWord, final boolean paintMode) {
        final long bitsPerColor;
        long blend;
        long blendAG;
        long blendRB;
        long destPixVal;
        long destShifted;
        long j;
        long maskShifted;
        long pixBlend;
        final long pixMask;
        final long rgbMask;
        long shift;
        long sourcePixVal;
        long sourceShifted;

        if (destDepth < 16) {
            return destinationWord;
        }
        final long unAlpha = 0xFF - sourceAlpha;
        long result = destinationWord;
        if (destPPW == 1) {
            /* 32bpp blends include alpha */
            if (!(paintMode && sourceWord == 0)) {
                /* painting a transparent pixel */
                /* blendRB red and blue */
                blendRB = (sourceWord & 16711935) * sourceAlpha + (destinationWord & 16711935) * unAlpha + 16711935;
                /* blendRB alpha and green */
                blendAG = (sourceWord >>> 8 & 16711935) * sourceAlpha + (destinationWord >>> 8 & 16711935) * unAlpha + 16711935;
                /* divide by 255 */
                blendRB = blendRB + (blendRB - 65537 >>> 8 & 16711935) >>> 8 & 16711935;
                blendAG = blendAG + (blendAG - 65537 >>> 8 & 16711935) >>> 8 & 16711935;
                result = blendRB | blendAG << 8;
            }
        } else {
            pixMask = MASK_TABLE[destDepth];
            bitsPerColor = 5;
            rgbMask = 0x1F;
            maskShifted = destMask;
            destShifted = destinationWord;
            sourceShifted = sourceWord;
            for (j = 1; j <= destPPW; j++) {
                sourcePixVal = sourceShifted & pixMask;
                if (!((maskShifted & pixMask) == 0 || paintMode && sourcePixVal == 0)) {
                    destPixVal = destShifted & pixMask;
                    pixBlend = 0;
                    for (int i = 1; i <= 3; i++) {
                        shift = (i - 1) * bitsPerColor;
                        blend = div((shr(sourcePixVal, shift) & rgbMask) * sourceAlpha + (shr(destPixVal, shift) & rgbMask) * unAlpha + 0xFE, 0xFF) & rgbMask;
                        pixBlend = pixBlend | shl(blend, shift);
                    }
                    result = result & ~shl(pixMask, (j - 1) * 16) | shl(pixBlend, (j - 1) * 16);
                }
                maskShifted = shr(maskShifted, destDepth);
                sourceShifted = shr(sourceShifted, destDepth);
                destShifted = shr(destShifted, destDepth);
            }
        }
        return result;
    }

    /*
     * Blend sourceWord with destinationWord using the alpha value from sourceWord. Alpha is encoded
     * as 0 meaning 0.0, and 255 meaning 1.0. In contrast to alphaBlend:with: the color produced is
     *
     * srcColor + (1-srcAlpha) * dstColor
     *
     * e.g., it is assumed that the source color is already scaled.
     */

    /* BitBltSimulation>>#alphaBlendScaled:with: */
    private long alphaBlendScaledwith(final long sourceWord, final long destinationWord) {
        /* High 8 bits of source pixel is source opacity (ARGB format) */
        final long unAlpha = 0xFF - (sourceWord >>> 24);
        /* blend red and blue components */
        long rb = ((destinationWord & 16711935) * unAlpha >>> 8 & 16711935) + (sourceWord & 16711935);
        /* blend alpha and green components */
        long ag = ((destinationWord >>> 8 & 16711935) * unAlpha >>> 8 & 16711935) + (sourceWord >>> 8 & 16711935);
        /* saturate red and blue components if there is a carry */
        rb = rb & 16711935 | (rb & 16777472) * 0xFF >>> 8;
        /* saturate alpha and green components if there is a carry */
        ag = (int) ((ag & 16711935) << 8) | (ag & 16777472) * 0xFF;
        return ag | rb;
    }

    /*
     * Blend sourceWord with destinationWord, assuming both are 32-bit pixels. The source is assumed
     * to have 255*alpha in the high 8 bits of each pixel, while the high 8 bits of the
     * destinationWord will be ignored. The blend produced is alpha*source + (1-alpha)*dest, with
     * the computation being performed independently on each color component. The high byte of the
     * result will be 0.
     */

    /* BitBltSimulation>>#alphaBlend:with: */
    private long alphaBlendwith(final long sourceWord, final long destinationWord) {
        /* High 8 bits of source pixel */
        final long alpha = sourceWord >>> 24;
        if (alpha == 0) {
            return destinationWord;
        }
        if (alpha == 0xFF) {
            return sourceWord;
        }
        final long unAlpha = 0xFF - alpha;
        /* blend red and blue */
        long blendRB = (sourceWord & 16711935) * alpha + (destinationWord & 16711935) * unAlpha + 16711935;
        /* blend alpha and green */
        long blendAG = ((sourceWord >>> 8 | 0xFF0000) & 16711935) * alpha + (destinationWord >>> 8 & 16711935) * unAlpha + 16711935;
        /* divide by 255 */
        blendRB = blendRB + (blendRB - 65537 >>> 8 & 16711935) >>> 8 & 16711935;
        blendAG = blendAG + (blendAG - 65537 >>> 8 & 16711935) >>> 8 & 16711935;
        return blendRB | blendAG << 8;
    }

    /* BitBltSimulation>>#alphaPaintConst:with: */
    private long alphaPaintConstwith(final long sourceWord, final long destinationWord) {
        if (sourceWord == 0) {
            return destinationWord;
        }
        return alphaBlendConstwithpaintMode(sourceWord, destinationWord, true);
    }

    /*
     * This version assumes combinationRule = 34 sourcePixSize = 32 destPixSize = 16 sourceForm ~=
     * destForm.
     */

    /* BitBltSimulation>>#alphaSourceBlendBits16 */
    private void alphaSourceBlendBits16() {
        int deltaX;
        int deltaY;
        long destWord;
        int ditherBase;
        int ditherIndex;
        int ditherThreshold;
        long dstIndex;
        long dstMask;
        int dstY;
        long sourceWord;
        long srcAlpha;
        long srcIndex;
        int srcShift;
        int srcY;

        /* This particular method should be optimized in itself */

        /* So we can pre-decrement */
        deltaY = bbH + 1;
        srcY = sy;
        dstY = dy;
        srcShift = (dx & 1) * 16;
        if (destMSB) {
            srcShift = 16 - srcShift;
        }
        /* This is the outer loop */
        mask1 = shl(0xFFFF, 16 - srcShift);
        while (--deltaY > 0) {
            srcIndex = srcY * sourcePitch + sx * 4;
            dstIndex = dstY * destPitch + dx / 2 * 4;
            ditherBase = (dstY & 3) * 4;
            /* For pre-increment */
            ditherIndex = (sx & 3) - 1;
            /* So we can pre-decrement */
            deltaX = bbW + 1;
            dstMask = mask1;
            if (dstMask == 0xFFFF) {
                srcShift = 16;
            } else {
                srcShift = 0;
            }
            while (--deltaX > 0) {
                ditherThreshold = DITHER_MATRIX_4X4[ditherBase + (ditherIndex = ditherIndex + 1 & 3)];
                sourceWord = srcLongAt(srcIndex);
                srcAlpha = sourceWord >>> 24;
                if (srcAlpha == 0xFF) {
                    /* Dither from 32 to 16 bit */
                    sourceWord = dither32To16threshold(sourceWord, ditherThreshold);
                    if (sourceWord == 0) {
                        sourceWord = shl(1, srcShift);
                    } else {
                        sourceWord = shl(sourceWord, srcShift);
                    }
                    destLongAtputmask(dstIndex, dstMask, sourceWord);
                } else {
                    /* srcAlpha ~= 255 */
                    if (srcAlpha != 0) {
                        /* 0 < srcAlpha < 255 */
                        /* If we have to mix colors then just copy a single word */
                        destWord = dstLongAt(dstIndex);
                        destWord = destWord & ~dstMask;
                        /* Expand from 16 to 32 bit by adding zero bits */
                        destWord = destWord >>> srcShift;
                        /* Mix colors */
                        destWord = (destWord & 0x7C00) << 9 | (destWord & 0x3E0) << 6 | (destWord & 0x1F) << 3 | 0xFF000000L;
                        /* And dither */
                        sourceWord = alphaBlendScaledwith(sourceWord, destWord);
                        sourceWord = dither32To16threshold(sourceWord, ditherThreshold);
                        if (sourceWord == 0) {
                            sourceWord = shl(1, srcShift);
                        } else {
                            sourceWord = shl(sourceWord, srcShift);
                        }
                        destLongAtputmask(dstIndex, dstMask, sourceWord);
                    }
                }
                srcIndex += 4;
                if (destMSB) {
                    if (srcShift == 0) {
                        dstIndex += 4;
                    }
                } else {
                    if (srcShift != 0) {
                        dstIndex += 4;
                    }
                }
                /* Toggle between 0 and 16 */
                srcShift = srcShift ^ 16;
                dstMask = ~dstMask;
            }
            srcY++;
            dstY++;
        }
    }

    /*
     * This version assumes combinationRule = 34 sourcePixSize = destPixSize = 32 sourceForm ~=
     * destForm. Note: The inner loop has been optimized for dealing with the special cases of
     * srcAlpha = 0.0 and srcAlpha = 1.0
     */

    /* BitBltSimulation>>#alphaSourceBlendBits32 */
    private void alphaSourceBlendBits32() {
        int deltaX;
        int deltaY;
        long destWord;
        long dstIndex;
        int dstY;
        long sourceWord;
        long srcAlpha;
        long srcIndex;
        int srcY;

        /* This particular method should be optimized in itself */
        /* Give the compile a couple of hints */
        /*
         * The following should be declared as pointers so the compiler will notice that they're
         * used for accessing memory locations (good to know on an Intel architecture) but then the
         * increments would be different between ST code and C code so must hope the compiler
         * notices what happens (MS Visual C does)
         */

        /* So we can pre-decrement */
        deltaY = bbH + 1;
        srcY = sy;
        /* This is the outer loop */
        dstY = dy;
        while (--deltaY > 0) {
            srcIndex = srcY * sourcePitch + sx * 4;
            dstIndex = dstY * destPitch + dx * 4;
            /* So we can pre-decrement */
            /* This is the inner loop */
            deltaX = bbW + 1;
            while (--deltaX > 0) {
                sourceWord = srcLongAt(srcIndex);
                srcAlpha = sourceWord >>> 24;
                if (srcAlpha == 0xFF) {
                    dstLongAtput(dstIndex, sourceWord);
                    srcIndex += 4;
                    /* Now copy as many words as possible with alpha = 255 */
                    dstIndex += 4;
                    while (--deltaX > 0 && (sourceWord = srcLongAt(srcIndex)) >>> 24 == 0xFF) {
                        dstLongAtput(dstIndex, sourceWord);
                        srcIndex += 4;
                        dstIndex += 4;
                    }
                    deltaX++;
                } else {
                    /* srcAlpha ~= 255 */
                    if (srcAlpha == 0) {
                        srcIndex += 4;
                        /* Now skip as many words as possible, */
                        dstIndex += 4;
                        while (--deltaX != 0 && (sourceWord = srcLongAt(srcIndex)) >>> 24 == 0) {
                            srcIndex += 4;
                            dstIndex += 4;
                        }
                        deltaX++;
                    } else {
                        /* 0 < srcAlpha < 255 */
                        /* If we have to mix colors then just copy a single word */
                        destWord = dstLongAt(dstIndex);
                        destWord = alphaBlendScaledwith(sourceWord, destWord);
                        dstLongAtput(dstIndex, destWord);
                        srcIndex += 4;
                        dstIndex += 4;
                    }
                }
            }
            srcY++;
            dstY++;
        }
    }

    /*
     * This version assumes combinationRule = 34 sourcePixSize = 32 destPixSize = 8 sourceForm ~=
     * destForm. Note: This is not real blending since we don't have the source colors available.
     */

    /* BitBltSimulation>>#alphaSourceBlendBits8 */
    private void alphaSourceBlendBits8() {
        long adjust;
        int deltaX;
        int deltaY;
        long destWord;
        long dstIndex;
        long dstMask;
        int dstY;
        final long mapperFlags;
        final long[] mappingTable;
        long sourceWord;
        long srcAlpha;
        long srcIndex;
        long srcShift;
        int srcY;

        mappingTable = DEFAULT_8_TO_32_TABLE;
        mapperFlags = cmFlags & ~COLOR_MAP_NEW_STYLE;

        /* So we can pre-decrement */
        deltaY = bbH + 1;
        srcY = sy;
        dstY = dy;
        mask1 = (dx & 3) * 8;
        if (destMSB) {
            mask1 = 24 - mask1;
        }
        mask2 = ALL_ONES ^ shl(0xFF, mask1);
        if ((dx & 1) == 0) {
            adjust = 0;
        } else {
            adjust = 522133279;
        }
        if ((dy & 1) == 0) {
            adjust = adjust ^ 522133279;
        }
        while (--deltaY > 0) {
            adjust = adjust ^ 522133279;
            srcIndex = srcY * sourcePitch + sx * 4;
            dstIndex = dstY * destPitch + dx / 4 * 4;
            /* So we can pre-decrement */
            deltaX = bbW + 1;
            srcShift = mask1;
            /* This is the inner loop */
            dstMask = mask2;
            while (--deltaX > 0) {
                sourceWord = (srcLongAt(srcIndex) & ~adjust) + adjust;
                srcAlpha = sourceWord >>> 24;
                if (srcAlpha > 0x1F) {
                    /* Everything below 31 is transparent */
                    if (srcAlpha < 224) {
                        /* Everything above 224 is opaque */
                        destWord = dstLongAt(dstIndex);
                        destWord = destWord & ~dstMask;
                        destWord = shr(destWord, srcShift);
                        destWord = mappingTable[(int) destWord];
                        sourceWord = alphaBlendScaledwith(sourceWord, destWord);
                    }
                    sourceWord = mapPixelflags(sourceWord, mapperFlags);
                    /* Store back */
                    sourceWord = shl(sourceWord, srcShift);
                    destLongAtputmask(dstIndex, dstMask, sourceWord);
                }
                srcIndex += 4;
                if (destMSB) {
                    if (srcShift == 0) {
                        dstIndex += 4;
                        srcShift = 24;
                        dstMask = 0xFFFFFF;
                    } else {
                        srcShift -= 8;
                        dstMask = dstMask >>> 8 | 0xFF000000L;
                    }
                } else {
                    if (srcShift == 24) {
                        dstIndex += 4;
                        srcShift = 0;
                        dstMask = 0xFFFFFF00L;
                    } else {
                        srcShift += 8;
                        dstMask = dstMask << 8 | 0xFF;
                    }
                }
                adjust = adjust ^ 522133279;
            }
            srcY++;
            dstY++;
        }
    }

    /* BitBltSimulation>>#bitAndInvert:with: */
    private static long bitAndInvertwith(final long sourceWord, final long destinationWord) {
        return sourceWord & ~destinationWord;
    }

    /* BitBltSimulation>>#bitAnd:with: */
    private static long bitAndwith(final long sourceWord, final long destinationWord) {
        return sourceWord & destinationWord;
    }

    /* BitBltSimulation>>#bitInvertAndInvert:with: */
    private static long bitInvertAndInvertwith(final long sourceWord, final long destinationWord) {
        return ~sourceWord & ~destinationWord;
    }

    /* BitBltSimulation>>#bitInvertAnd:with: */
    private static long bitInvertAndwith(final long sourceWord, final long destinationWord) {
        return ~sourceWord & destinationWord;
    }

    /* BitBltSimulation>>#bitInvertDestination:with: */
    private static long bitInvertDestinationwith(@SuppressWarnings("unused") final long sourceWord, final long destinationWord) {
        return ~destinationWord;
    }

    /* BitBltSimulation>>#bitInvertOrInvert:with: */
    private static long bitInvertOrInvertwith(final long sourceWord, final long destinationWord) {
        return ~sourceWord | ~destinationWord;
    }

    /* BitBltSimulation>>#bitInvertOr:with: */
    private static long bitInvertOrwith(final long sourceWord, final long destinationWord) {
        return ~sourceWord | destinationWord;
    }

    /* BitBltSimulation>>#bitInvertSource:with: */
    private static long bitInvertSourcewith(final long sourceWord, @SuppressWarnings("unused") final long destinationWord) {
        return ~sourceWord;
    }

    /* BitBltSimulation>>#bitInvertXor:with: */
    private static long bitInvertXorwith(final long sourceWord, final long destinationWord) {
        return ~sourceWord ^ destinationWord;
    }

    /* BitBltSimulation>>#bitOrInvert:with: */
    private static long bitOrInvertwith(final long sourceWord, final long destinationWord) {
        return sourceWord | ~destinationWord;
    }

    /* BitBltSimulation>>#bitOr:with: */
    private static long bitOrwith(final long sourceWord, final long destinationWord) {
        return sourceWord | destinationWord;
    }

    /* BitBltSimulation>>#bitXor:with: */
    private static long bitXorwith(final long sourceWord, final long destinationWord) {
        return sourceWord ^ destinationWord;
    }

    /* check for possible overlap of source and destination */
    /* ar 10/19/1999: This method requires surfaces to be locked. */

    /* BitBltSimulation>>#checkSourceOverlap */
    private void checkSourceOverlap() {
        if (sourceForm == destForm && dy >= sy) {
            if (dy > sy) {
                /* have to start at bottom */
                vDir = -1;
                sy = sy + bbH - 1;
                dy = dy + bbH - 1;
            } else {
                if (dy == sy && dx > sx) {
                    /* y's are equal, but x's are backward */
                    hDir = -1;
                    /* start at right */
                    sx = sx + bbW - 1;
                    /* and fix up masks */
                    dx = dx + bbW - 1;
                    if (nWords > 1) {
                        final long t = mask1;
                        mask1 = mask2;
                        mask2 = t;
                    }
                }
            }
            destIndex = dy * destPitch + div(dx, destPPW) * 4;
            destDelta = destPitch * vDir - 4 * (nWords * hDir);
        }
    }

    /* BitBltSimulation>>#clearWord:with: */
    private static long clearWordwith(@SuppressWarnings("unused") final long sourceWord, @SuppressWarnings("unused") final long destinationWord) {
        return 0L;
    }

    /* clip and adjust source origin and extent appropriately */
    /* first in x */

    /* BitBltSimulation>>#clipRange */
    private void clipRange() {
        if (destX >= clipX) {
            sx = sourceX;
            dx = destX;
            bbW = width;
        } else {
            sx = sourceX + clipX - destX;
            bbW = width - (clipX - destX);
            dx = clipX;
        }
        if (dx + bbW > clipX + clipWidth) {
            bbW -= dx + bbW - (clipX + clipWidth);
        }
        if (destY >= clipY) {
            sy = sourceY;
            dy = destY;
            bbH = height;
        } else {
            sy = sourceY + clipY - destY;
            bbH = height - (clipY - destY);
            dy = clipY;
        }
        if (dy + bbH > clipY + clipHeight) {
            bbH -= dy + bbH - (clipY + clipHeight);
        }
        if (noSource) {
            return;
        }
        if (sx < 0) {
            dx -= sx;
            bbW += sx;
            sx = 0;
        }
        if (sx + bbW > sourceWidth) {
            bbW -= sx + bbW - sourceWidth;
        }
        if (sy < 0) {
            dy -= sy;
            bbH += sy;
            sy = 0;
        }
        if (sy + bbH > sourceHeight) {
            bbH -= sy + bbH - sourceHeight;
        }
    }

    /* This function is exported for the Balloon engine */

    /* BitBltSimulation>>#copyBits */
    private void copyBits() {
        copyBits(-1);
    }

    private void copyBits(final long factor) {
        clipRange();
        if (bbW <= 0 || bbH <= 0) {
            /* zero width or height; noop */
            affectedL = affectedR = affectedT = affectedB = 0;
            return;
        }
        if (!lockSurfaces()) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        copyBitsLockedAndClipped(factor);
        unlockSurfaces();
    }

    /* Support for the balloon engine. */

    /* BitBltSimulation>>#copyBitsFrom:to:at: */
    protected void copyBitsFromtoat(final int startX, final int stopX, final int yValue) {
        destX = startX;
        destY = yValue;
        sourceX = startX;
        width = stopX - startX;
        copyBits();
        showDisplayBits();
    }

    /*
     * Perform the actual copyBits operation. Assume: Surfaces have been locked and clipping was
     * performed.
     */

    /* BitBltSimulation>>#copyBitsLockedAndClipped */
    private void copyBitsLockedAndClipped() {
        copyBitsLockedAndClipped(-1);
    }

    private void copyBitsLockedAndClipped(final long factorOrMinusOne) {
        copyBitsRule41Test();
        if (failed()) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        if (tryCopyingBitsQuickly()) {
            return;
        }
        if (combinationRule >= 30 && combinationRule <= 0x1F) {
            /* Check and fetch source alpha parameter for alpha blend */
            if (factorOrMinusOne == -1) {
                PrimitiveFailed.andTransferToInterpreter();
            }
            sourceAlpha = factorOrMinusOne;
            if (failed() || sourceAlpha < 0 || sourceAlpha > 0xFF) {
                PrimitiveFailed.andTransferToInterpreter();
            }
        }
        /* Choose and perform the actual copy loop. */
        bitCount = 0;
        performCopyLoop();
        if (combinationRule >= 30 && combinationRule <= 0x1F) {
            /* zero width and height; just return the count */
            affectedL = affectedR = affectedT = affectedB = 0;
        } else {
            if (hDir > 0) {
                affectedL = dx;
                affectedR = dx + bbW;
            } else {
                affectedL = dx - bbW + 1;
                affectedR = dx + 1;
            }
            if (vDir > 0) {
                affectedT = dy;
                affectedB = dy + bbH;
            } else {
                affectedT = dy - bbH + 1;
                affectedB = dy + 1;
            }
        }
    }

    /*
     * Test possible use of rule 41, rgbComponentAlpha:with: Nothing to return, just set up some
     * variables
     */

    /* BitBltSimulation>>#copyBitsRule41Test */
    private void copyBitsRule41Test() {
        if (combinationRule == 41) {
            /* fetch the forecolor into componentAlphaModeColor. */
            componentAlphaModeAlpha = 0xFF;
            componentAlphaModeColor = 0xFFFFFF;
            gammaLookupTable = null;
            ungammaLookupTable = null;

            throw SqueakException.create("Not implemented");
            // TODO: uncomment:
            // if ((methodArgumentCount()) >= 2) {
            // componentAlphaModeAlpha = stackIntegerValue((methodArgumentCount()) - 2);
            // if (failed()) {
            // throw new PrimitiveFailed();
            // }
            // componentAlphaModeColor = stackIntegerValue((methodArgumentCount()) - 1);
            // if (failed()) {
            // throw new PrimitiveFailed();
            // }
            // if ((methodArgumentCount()) == 4) {
            // gammaLookupTableOop = stackObjectValue(1);
            // if (isBytes(gammaLookupTableOop)) {
            // gammaLookupTable = firstIndexableField(gammaLookupTableOop);
            // }
            // ungammaLookupTableOop = stackObjectValue(0);
            // if (isBytes(ungammaLookupTableOop)) {
            // ungammaLookupTable = firstIndexableField(ungammaLookupTableOop);
            // }
            // }
            // } else {
            // if ((methodArgumentCount()) == 1) {
            // componentAlphaModeColor = stackIntegerValue(0);
            // if (failed()) {
            // throw new PrimitiveFailed();
            // }
            // } else {
            // throw new PrimitiveFailed();
            // }
            // }
        }
    }

    /* This version of the inner loop assumes noSource = false. */

    /* BitBltSimulation>>#copyLoop */
    private void copyLoop() {
        long destWord;
        long halftoneWord;
        final long hInc;
        long mergeWord;
        final long notSkewMask;
        long prevWord;
        final long skewMask;
        long skewWord;
        long thisWord;
        final long unskew;
        long word;
        int y;

        /* unskew is a bitShift and MUST remain signed, while skewMask is unsigned. */
        final LongBinaryOperator mergeFnwith = opTable[combinationRule + 1];
        assert mergeFnwith != null : "Unexpected `null` value";
        assert !(preload && skew == 0);
        assert -32 <= skew && skew <= 32; // Modified (image uses 31 instead of 32).

        /* Byte delta */
        hInc = hDir * 4;
        if (skew < 0) {
            unskew = skew + 32;
            skewMask = shl(ALL_ONES, 0 - skew);
        } else {
            if (skew == 0) {
                unskew = 0;
                skewMask = ALL_ONES;
            } else {
                unskew = skew - 32;
                skewMask = shr(ALL_ONES, skew);
            }
        }
        notSkewMask = ~skewMask;
        if (noHalftone) {
            halftoneWord = ALL_ONES;
            halftoneHeight = 0;
        } else {
            halftoneWord = halftoneLongAt(0);
        }

        /*
         * Here is the vertical loop, in two versions, one for the combinationRule = 3 copy mode,
         * one for the general case.
         */
        y = dy;
        if (combinationRule == 3) {
            for (int i = 1; i <= bbH; i++) {
                /*
                 * here is the vertical loop for combinationRule = 3 copy mode; no need to call
                 * merge
                 */
                if (halftoneHeight > 1) {
                    /* Otherwise, its always the same */
                    halftoneWord = halftoneLongAt(y);
                    y += vDir;
                }
                if (preload) {
                    /* load the 64-bit shifter */
                    prevWord = srcLongAt(sourceIndex);
                    sourceIndex += hInc;
                } else {
                    prevWord = 0;
                }
                destMask = mask1;
                /* pick up next word */
                thisWord = srcLongAt(sourceIndex);
                sourceIndex += hInc;
                /* 32-bit rotate */
                skewWord = shift(prevWord & notSkewMask, unskew) | shift(thisWord & skewMask, skew);
                prevWord = thisWord;
                destWord = dstLongAt(destIndex);
                destWord = destMask & skewWord & halftoneWord | destWord & ~destMask;
                dstLongAtput(destIndex, destWord);
                destIndex += hInc;
                destMask = ALL_ONES;
                if (skew == 0 && halftoneWord == ALL_ONES) {
                    /* Very special inner loop for STORE mode with no skew -- just move words */
                    if (preload && hDir == 1) {
                        for (word = 2; word < nWords; word++) {
                            /* Note loop starts with prevWord loaded (due to preload) */
                            dstLongAtput(destIndex, prevWord);
                            destIndex += hInc;
                            prevWord = srcLongAt(sourceIndex);
                            sourceIndex += hInc;
                        }
                    } else {
                        for (word = 2; word < nWords; word++) {
                            thisWord = srcLongAt(sourceIndex);
                            sourceIndex += hInc;
                            dstLongAtput(destIndex, thisWord);
                            destIndex += hInc;
                        }
                        prevWord = thisWord;
                    }
                } else {
                    for (word = 2; word < nWords; word++) {
                        thisWord = srcLongAt(sourceIndex);
                        sourceIndex += hInc;
                        /* 32-bit rotate */
                        skewWord = shift(prevWord & notSkewMask, unskew) | shift(thisWord & skewMask, skew);
                        prevWord = thisWord;
                        dstLongAtput(destIndex, skewWord & halftoneWord);
                        destIndex += hInc;
                    }
                }
                if (nWords > 1) {
                    destMask = mask2;
                    if (((skew < 0 ? skewMask >> -skew : skewMask << skew) & mask2) == 0) {
                        /* we don't need more bits, they will all come from prevWord */
                        thisWord = 0;
                    } else {
                        thisWord = srcLongAt(sourceIndex);
                    }
                    sourceIndex += hInc;
                    /* 32-bit rotate */
                    skewWord = shift(prevWord & notSkewMask, unskew) | shift(thisWord & skewMask, skew);
                    destWord = dstLongAt(destIndex);
                    destWord = destMask & skewWord & halftoneWord | destWord & ~destMask;
                    dstLongAtput(destIndex, destWord);
                    destIndex += hInc;
                }
                sourceIndex += sourceDelta;
                destIndex += destDelta;
            }
        } else {
            for (int i = 1; i <= bbH; i++) {
                /* here is the vertical loop for the general case (combinationRule ~= 3) */
                if (halftoneHeight > 1) {
                    /* Otherwise, its always the same */
                    halftoneWord = halftoneLongAt(y);
                    y += vDir;
                }
                if (preload) {
                    /* load the 64-bit shifter */
                    prevWord = srcLongAt(sourceIndex);
                    sourceIndex += hInc;
                } else {
                    prevWord = 0;
                }
                destMask = mask1;
                /* pick up next word */
                thisWord = srcLongAt(sourceIndex);
                sourceIndex += hInc;
                /* 32-bit rotate */
                skewWord = shift(prevWord & notSkewMask, unskew) | shift(thisWord & skewMask, skew);
                prevWord = thisWord;
                destWord = dstLongAt(destIndex);
                mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, destWord);
                destWord = destMask & mergeWord | destWord & ~destMask;
                dstLongAtput(destIndex, destWord);
                destIndex += hInc;
                destMask = ALL_ONES;
                for (word = 2; word < nWords; word++) {
                    /* Normal inner loop does merge: */
                    /* pick up next word */
                    thisWord = srcLongAt(sourceIndex);
                    sourceIndex += hInc;
                    /* 32-bit rotate */
                    skewWord = (unskew < 0 ? (prevWord & notSkewMask) >>> -unskew : (prevWord & notSkewMask) << unskew) |
                                    (skew < 0 ? (thisWord & skewMask) >>> -skew : (thisWord & skewMask) << skew);
                    prevWord = thisWord;
                    mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, dstLongAt(destIndex));
                    dstLongAtput(destIndex, mergeWord);
                    destIndex += hInc;
                }
                if (nWords > 1) {
                    destMask = mask2;
                    if (((skew < 0 ? skewMask >> -skew : skewMask << skew) & mask2) == 0) {
                        /* we don't need more bits, they will all come from prevWord */
                        thisWord = 0;
                    } else {
                        thisWord = srcLongAt(sourceIndex);
                    }
                    sourceIndex += hInc;
                    /* 32-bit rotate */
                    skewWord = (unskew < 0 ? (prevWord & notSkewMask) >>> -unskew : (prevWord & notSkewMask) << unskew) |
                                    (skew < 0 ? (thisWord & skewMask) >>> -skew : (thisWord & skewMask) << skew);
                    destWord = dstLongAt(destIndex);
                    mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, destWord);
                    destWord = destMask & mergeWord | destWord & ~destMask;
                    dstLongAtput(destIndex, destWord);
                    destIndex += hInc;
                }
                sourceIndex += sourceDelta;
                destIndex += destDelta;
            }
        }
    }

    /*
     * Faster copyLoop when source not used. hDir and vDir are both positive, and perload and skew
     * are unused
     */

    /* BitBltSimulation>>#copyLoopNoSource */
    private void copyLoopNoSource() {
        long destWord;
        long halftoneWord;
        long mergeWord;
        long word;

        halftoneWord = 0;
        final LongBinaryOperator mergeFnwith = opTable[combinationRule + 1];
        assert mergeFnwith != null : "Unexpected `null` value";
        if (noHalftone) {
            halftoneWord = ALL_ONES;
        }
        for (int i = 1; i <= bbH; i++) {
            /* here is the vertical loop */
            if (!noHalftone) {
                halftoneWord = halftoneLongAt(dy + i - 1);
            }
            destMask = mask1;
            destWord = dstLongAt(destIndex);
            mergeWord = mergeFnwith.applyAsLong(halftoneWord, destWord);
            destWord = destMask & mergeWord | destWord & ~destMask;
            dstLongAtput(destIndex, destWord);
            destIndex += 4;
            destMask = ALL_ONES;
            if (combinationRule == 3) {
                /* Special inner loop for STORE */
                destWord = halftoneWord;
                for (word = 2; word < nWords; word++) {
                    dstLongAtput(destIndex, destWord);
                    destIndex += 4;
                }
            } else {
                /* Normal inner loop does merge */
                for (word = 2; word < nWords; word++) {
                    /* Normal inner loop does merge */
                    destWord = dstLongAt(destIndex);
                    mergeWord = mergeFnwith.applyAsLong(halftoneWord, destWord);
                    dstLongAtput(destIndex, mergeWord);
                    destIndex += 4;
                }
            }
            if (nWords > 1) {
                destMask = mask2;
                destWord = dstLongAt(destIndex);
                mergeWord = mergeFnwith.applyAsLong(halftoneWord, destWord);
                destWord = destMask & mergeWord | destWord & ~destMask;
                dstLongAtput(destIndex, destWord);
                destIndex += 4;
            }
            destIndex += destDelta;
        }
    }

    /*
     * This version of the inner loop maps source pixels to a destination form with different depth.
     * Because it is already unweildy, the loop is not unrolled as in the other versions. Preload,
     * skew and skewMask are all overlooked, since pickSourcePixels delivers its destination word
     * already properly aligned. Note that pickSourcePixels could be copied in-line at the top of
     * the horizontal loop, and some of its inits moved out of the loop.
     */
    /*
     * ar 12/7/1999: The loop has been rewritten to use only one pickSourcePixels call. The idea is
     * that the call itself could be inlined. If we decide not to inline pickSourcePixels we could
     * optimize the loop instead.
     */

    /* BitBltSimulation>>#copyLoopPixMap */
    private long copyLoopPixMap() {
        final long destPixMask;
        long destWord;
        long dstShift;
        int dstShiftInc;
        long dstShiftLeft;
        final long endBits;
        long halftoneWord;
        final long mapperFlags;
        long mergeWord;
        long nPix;
        final long nSourceIncs;
        final long scrStartBits;
        long skewWord;
        final long sourcePixMask;
        long srcShift;
        int srcShiftInc;
        long startBits;
        long words;

        halftoneWord = 0;
        final LongBinaryOperator mergeFnwith = opTable[combinationRule + 1];
        assert mergeFnwith != null : "Unexpected `null` value";
        sourcePPW = div(32, sourceDepth);
        sourcePixMask = MASK_TABLE[sourceDepth];
        destPixMask = MASK_TABLE[destDepth];
        mapperFlags = cmFlags & ~COLOR_MAP_NEW_STYLE;
        sourceIndex = sy * sourcePitch + div(sx, sourcePPW) * 4;
        scrStartBits = sourcePPW - (sx & sourcePPW - 1);
        if (bbW < scrStartBits) {
            nSourceIncs = 0;
        } else {
            nSourceIncs = div(bbW - scrStartBits, sourcePPW) + 1;
        }
        /* Note following two items were already calculated in destmask setup! */
        sourceDelta = sourcePitch - nSourceIncs * 4;
        startBits = destPPW - (dx & destPPW - 1);
        endBits = (dx + bbW - 1 & destPPW - 1) + 1;
        if (bbW < startBits) {
            startBits = bbW;
        }
        srcShift = (sx & sourcePPW - 1) * sourceDepth;
        dstShift = (dx & destPPW - 1) * destDepth;
        srcShiftInc = sourceDepth;
        dstShiftInc = destDepth;
        dstShiftLeft = 0;
        if (sourceMSB) {
            srcShift = 32 - sourceDepth - srcShift;
            srcShiftInc = 0 - srcShiftInc;
        }
        if (destMSB) {
            dstShift = 32 - destDepth - dstShift;
            dstShiftInc = 0 - dstShiftInc;
            dstShiftLeft = 32 - destDepth;
        }
        if (noHalftone) {
            halftoneWord = ALL_ONES;
        }
        for (int i = 1; i <= bbH; i++) {
            /* here is the vertical loop */
            if (!noHalftone) {
                halftoneWord = halftoneLongAt(dy + i - 1);
            }
            srcBitShift = srcShift;
            dstBitShift = dstShift;
            destMask = mask1;
            /* Here is the horizontal loop... */
            nPix = startBits;
            words = nWords;
            do {
                /* align next word to leftmost pixel */
                skewWord = pickSourcePixelsflagssrcMaskdestMasksrcShiftIncdstShiftInc(nPix, mapperFlags, sourcePixMask, destPixMask, srcShiftInc, dstShiftInc);
                dstBitShift = dstShiftLeft;
                if (destMask == ALL_ONES) {
                    /* avoid read-modify-write */
                    mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, dstLongAt(destIndex));
                    dstLongAtput(destIndex, destMask & mergeWord);
                } else {
                    /* General version using dest masking */
                    destWord = dstLongAt(destIndex);
                    mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, destWord & destMask);
                    destWord = destMask & mergeWord | destWord & ~destMask;
                    dstLongAtput(destIndex, destWord);
                }
                destIndex += 4;
                if (words == 2) {
                    /* e.g., is the next word the last word? */
                    /* set mask for last word in this row */
                    destMask = mask2;
                    nPix = endBits;
                } else {
                    /* use fullword mask for inner loop */
                    destMask = ALL_ONES;
                    nPix = destPPW;
                }
            } while (--words > 0);
            sourceIndex += sourceDelta;
            destIndex += destDelta;
        }
        return 0;
    }

    /* Utility routine for computing Warp increments. */

    /* BitBltSimulation>>#deltaFrom:to:nSteps: */
    private static int deltaFromtonSteps(final int x1, final int x2, final int n) {
        if (x2 > x1) {
            return div(x2 - x1 + FIXED_PT1, n + 1) + 1;
        } else {
            if (x2 == x1) {
                return 0;
            }
            return 0 - (div(x1 - x2 + FIXED_PT1, n + 1) + 1);
        }
    }

    /* BitBltSimulation>>#destinationWord:with: */
    private static long destinationWordwith(@SuppressWarnings("unused") final long sourceWord, final long destinationWord) {
        return destinationWord;
    }

    /* Compute masks for left and right destination words */

    /* BitBltSimulation>>#destMaskAndPointerInit */
    private void destMaskAndPointerInit() {
        final long endBits;
        final long pixPerM1;
        final long startBits;

        /* A mask, assuming power of two */
        /* how many pixels in first word */
        pixPerM1 = destPPW - 1;
        /* how many pixels in last word */
        startBits = destPPW - (dx & pixPerM1);
        endBits = (dx + bbW - 1 & pixPerM1) + 1;
        if (destMSB) {
            mask1 = (int) shr(ALL_ONES, 32 - startBits * destDepth);
            mask2 = (int) shl(ALL_ONES, 32 - endBits * destDepth);
        } else {
            mask1 = (int) shl(ALL_ONES, 32 - startBits * destDepth);
            mask2 = (int) shr(ALL_ONES, 32 - endBits * destDepth);
        }
        if (bbW <= startBits) {
            mask1 = mask1 & mask2;
            mask2 = 0;
            nWords = 1;
        } else {
            nWords = div(bbW - startBits + pixPerM1, destPPW) + 1;
        }
        /* defaults for no overlap with source */
        /* calculate byte addr and delta, based on first word of data */
        /* Note pitch is bytes and nWords is longs, not bytes */
        hDir = vDir = 1;
        destIndex = dy * destPitch + div(dx, destPPW) * 4;
        /* byte addr delta */
        destDelta = destPitch * vDir - 4 * (nWords * hDir);
    }

    /* Dither the given 32bit word to 16 bit. Ignore alpha. */

    /* BitBltSimulation>>#dither32To16:threshold: */
    private static long dither32To16threshold(final long srcWord, final long ditherValue) {
        final long addThreshold;

        addThreshold = ditherValue << 8;
        return ((long) DITHER_8_LOOKUP[(int) (addThreshold + (srcWord >>> 16 & 0xFF))] << 10) +
                        ((long) DITHER_8_LOOKUP[(int) (addThreshold + (srcWord >>> 8 & 0xFF))] << 5) +
                        DITHER_8_LOOKUP[(int) (addThreshold + (srcWord & 0xFF))];
    }

    /*
     * This is the primitive implementation of the line-drawing loop. See the comments in
     * BitBlt>>drawLoopX:Y:
     */

    /* BitBltSimulation>>#drawLoopX:Y: */
    private void drawLoopXY(final long xDelta, final long yDelta) {
        int affB;
        int affL;
        int affR;
        int affT;
        final long dx1;
        final long dy1;
        long p;
        final long px;
        final long py;

        if (xDelta > 0) {
            dx1 = 1;
        } else {
            if (xDelta == 0) {
                dx1 = 0;
            } else {
                dx1 = -1;
            }
        }
        if (yDelta > 0) {
            dy1 = 1;
        } else {
            if (yDelta == 0) {
                dy1 = 0;
            } else {
                dy1 = -1;
            }
        }
        px = Math.abs(yDelta);
        py = Math.abs(xDelta);
        /* init null rectangle */
        affL = affT = 9999;
        affR = affB = -9999;
        if (py > px) {
            /* more horizontal */
            p = py / 2;
            for (int i = 1; i <= py; i++) {
                destX += dx1;
                if ((p -= px) < 0) {
                    destY += dy1;
                    p += py;
                }
                if (i < py) {
                    copyBits();
                    if (failed()) {
                        return;
                    }
                    if (affectedL < affectedR && affectedT < affectedB) {
                        /* Affected rectangle grows along the line */
                        affL = affL < affectedL ? affL : affectedL;
                        affR = affR < affectedR ? affectedR : affR;
                        affT = affT < affectedT ? affT : affectedT;
                        affB = affB < affectedB ? affectedB : affB;
                        if ((affR - affL) * (affB - affT) > 4000) {
                            /* If affected rectangle gets large, update it in chunks */
                            affectedL = affL;
                            affectedR = affR;
                            affectedT = affT;
                            affectedB = affB;
                            showDisplayBits();
                            /* init null rectangle */
                            affL = affT = 9999;
                            affR = affB = -9999;
                        }
                    }
                }
            }
        } else {
            /* more vertical */
            p = px / 2;
            for (int i = 1; i <= px; i++) {
                destY += dy1;
                if ((p -= py) < 0) {
                    destX += dx1;
                    p += px;
                }
                if (i < px) {
                    copyBits();
                    if (failed()) {
                        return;
                    }
                    if (affectedL < affectedR && affectedT < affectedB) {
                        /* Affected rectangle grows along the line */
                        affL = affL < affectedL ? affL : affectedL;
                        affR = affR < affectedR ? affectedR : affR;
                        affT = affT < affectedT ? affT : affectedT;
                        affB = affB < affectedB ? affectedB : affB;
                        if ((affR - affL) * (affB - affT) > 4000) {
                            /* If affected rectangle gets large, update it in chunks */
                            affectedL = affL;
                            affectedR = affR;
                            affectedT = affT;
                            affectedB = affB;
                            showDisplayBits();
                            /* init null rectangle */
                            affL = affT = 9999;
                            affR = affB = -9999;
                        }
                    }
                }
            }
        }
        affectedL = affL;
        affectedR = affR;
        affectedT = affT;
        /* store destX, Y back */
        affectedB = affB;
        storeIntegerofObjectwithValue(BB_DEST_X_INDEX, bitBltOop, destX);
        storeIntegerofObjectwithValue(BB_DEST_Y_INDEX, bitBltOop, destY);
    }

    /* Dither the given 32bit word to 16 bit. Ignore alpha. */

    /* BitBltSimulation>>#expensiveDither32To16:threshold: */
    private static long expensiveDither32To16threshold(final long srcWord, final long ditherValue) {
        int out;
        int pv;
        int threshold;
        int value;

        pv = (int) (srcWord & 0xFF);
        threshold = DITHER_THRESHOLDS_16[pv & 7];
        value = DITHER_VALUES_16[pv >>> 3];
        if (ditherValue < threshold) {
            out = value + 1;
        } else {
            out = value;
        }
        pv = (int) (srcWord >>> 8 & 0xFF);
        threshold = DITHER_THRESHOLDS_16[pv & 7];
        value = DITHER_VALUES_16[pv >>> 3];
        if (ditherValue < threshold) {
            out = out | value + 1 << 5;
        } else {
            out = out | value << 5;
        }
        pv = (int) (srcWord >>> 16 & 0xFF);
        threshold = DITHER_THRESHOLDS_16[pv & 7];
        value = DITHER_VALUES_16[pv >>> 3];
        if (ditherValue < threshold) {
            out = out | value + 1 << 10;
        } else {
            out = out | value << 10;
        }
        return out;
    }

    /*
     * Return the integer value of the given field of the given object. If the field contains a
     * Float, truncate it and return its integral part. Fail if the given field does not contain a
     * small integer or Float, or if the truncated Float is out of the range of small integers.
     */

    /* BitBltSimulation>>#fetchIntOrFloat:ofObject: */
    private static int fetchIntOrFloatofObject(final int fieldIndex, final PointersObject objectPointer) {
        final Object fieldOop = fetchPointerofObject(fieldIndex, objectPointer);
        if (fieldOop instanceof Long) {
            final long longValue = (long) fieldOop;
            if (Integer.MIN_VALUE <= longValue && longValue <= Integer.MAX_VALUE) {
                return (int) longValue;
            }
            PrimitiveFailed.andTransferToInterpreter(); // Fail because value is too big.
        } else if (fieldOop instanceof FloatObject) {
            return floatToLong(((FloatObject) fieldOop).getValue());
        } else if (fieldOop instanceof Double) {
            return floatToLong((double) fieldOop);
        } else if (fieldOop instanceof LargeIntegerObject) {
            final LargeIntegerObject fieldLarge = (LargeIntegerObject) fieldOop;
            if (fieldLarge.fitsIntoInt()) {
                return fieldLarge.intValueExact();
            }
            PrimitiveFailed.andTransferToInterpreter(); // Fail because value is too big.
        }
        throw SqueakException.create("Should not be reached:", fieldOop);
    }

    private static int floatToLong(final double floatValue) {
        if (!(-2.147483648e9 <= floatValue && floatValue <= 2.147483647e9)) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        return (int) floatValue;
    }

    /*
     * Return the integer value of the given field of the given object. If the field contains a
     * Float, truncate it and return its integral part. Fail if the given field does not contain a
     * small integer or Float, or if the truncated Float is out of the range of small integers.
     */

    /* BitBltSimulation>>#fetchIntOrFloat:ofObject:ifNil: */
    private static int fetchIntOrFloatofObjectifNil(final int fieldIndex, final PointersObject objectPointer, final long defaultValue) {
        final Object fieldOop = fetchPointerofObject(fieldIndex, objectPointer);
        if (fieldOop instanceof Long) {
            final long longValue = (long) fieldOop;
            if (Integer.MIN_VALUE <= longValue && longValue <= Integer.MAX_VALUE) {
                return (int) (long) fieldOop;
            }
            PrimitiveFailed.andTransferToInterpreter(); // Fail because value is too big.
        }
        if (fieldOop == NilObject.SINGLETON) {
            return (int) defaultValue;
        } else if (fieldOop instanceof Double) {
            return floatToLong((double) fieldOop);
        } else if (fieldOop instanceof FloatObject) {
            return floatToLong(((FloatObject) fieldOop).getValue());
        } else if (fieldOop instanceof LargeIntegerObject) {
            final LargeIntegerObject fieldLarge = (LargeIntegerObject) fieldOop;
            if (fieldLarge.fitsIntoInt()) {
                return fieldLarge.intValueExact();
            }
            PrimitiveFailed.andTransferToInterpreter(); // Fail because value is too big.
        }
        throw SqueakException.create("Should not be reached:", fieldOop);
    }

    /*
     * For any non-zero pixel value in destinationWord with zero alpha channel take the alpha from
     * sourceWord and fill it in. Intended for fixing alpha channels left at zero during 16->32 bpp
     * conversions.
     */

    /* BitBltSimulation>>#fixAlpha:with: */
    private long fixAlphawith(final long sourceWord, final long destinationWord) {
        if (destDepth != 32) {
            return destinationWord;
        }
        if (destinationWord == 0) {
            return 0;
        }
        if ((destinationWord & 0xFF000000L) != 0) {
            return destinationWord;
        }
        return destinationWord | sourceWord & 0xFF000000L;
    }

    /*
     * Note: This is hardcoded so it can be run from Squeak. The module name is used for validating
     * a module *after* it is loaded to check if it does really contain the module we're thinking it
     * contains. This is important!
     */

    /* InterpreterPlugin>>#getModuleName */
    public static String getModuleName() {
        return MODULE_NAME;
    }

    /* BitBltSimulation>>#ignoreSourceOrHalftone: */
    private boolean ignoreSourceOrHalftone(final Object formPointer) {
        return formPointer == null || combinationRule == 0 || combinationRule == 5 || combinationRule == 10 || combinationRule == 15;
    }

    /* BitBltSimulation>>#initBBOpTable */
    private void initBBOpTable() {
        CompilerDirectives.transferToInterpreterAndInvalidate();
        opTable[0 + 1] = BitBlt::clearWordwith;
        opTable[1 + 1] = BitBlt::bitAndwith;
        opTable[2 + 1] = BitBlt::bitAndInvertwith;
        opTable[3 + 1] = this::sourceWordwith;
        opTable[4 + 1] = BitBlt::bitInvertAndwith;
        opTable[5 + 1] = BitBlt::destinationWordwith;
        opTable[6 + 1] = BitBlt::bitXorwith;
        opTable[7 + 1] = BitBlt::bitOrwith;
        opTable[8 + 1] = BitBlt::bitInvertAndInvertwith;
        opTable[9 + 1] = BitBlt::bitInvertXorwith;
        opTable[10 + 1] = BitBlt::bitInvertDestinationwith;
        opTable[11 + 1] = BitBlt::bitOrInvertwith;
        opTable[12 + 1] = BitBlt::bitInvertSourcewith;
        opTable[13 + 1] = BitBlt::bitInvertOrwith;
        opTable[14 + 1] = BitBlt::bitInvertOrInvertwith;
        opTable[15 + 1] = BitBlt::destinationWordwith;
        opTable[16 + 1] = BitBlt::destinationWordwith;
        opTable[17 + 1] = BitBlt::destinationWordwith;
        opTable[18 + 1] = this::addWordwith;
        opTable[19 + 1] = this::subWordwith;
        opTable[20 + 1] = this::rgbAddwith;
        opTable[21 + 1] = this::rgbSubwith;
        opTable[22 + 1] = this::oLDrgbDiffwith;
        opTable[23 + 1] = this::oLDtallyIntoMapwith;
        opTable[24 + 1] = this::alphaBlendwith;
        opTable[25 + 1] = this::pixPaintwith;
        opTable[26 + 1] = this::pixMaskwith;
        opTable[27 + 1] = this::rgbMaxwith;
        opTable[28 + 1] = this::rgbMinwith;
        opTable[29 + 1] = this::rgbMinInvertwith;
        opTable[30 + 1] = this::alphaBlendConstwith;
        opTable[31 + 1] = this::alphaPaintConstwith;
        opTable[32 + 1] = this::rgbDiffwith;
        opTable[33 + 1] = this::tallyIntoMapwith;
        opTable[34 + 1] = this::alphaBlendScaledwith;
        opTable[35 + 1] = this::alphaBlendScaledwith;
        opTable[36 + 1] = this::alphaBlendScaledwith;
        opTable[37 + 1] = this::rgbMulwith;
        opTable[38 + 1] = this::pixSwapwith;
        opTable[39 + 1] = this::pixClearwith;
        opTable[40 + 1] = this::fixAlphawith;
        opTable[41 + 1] = this::rgbComponentAlphawith;
    }

    /* BitBltSimulation>>#initDither8Lookup */
    private static void initDither8Lookup() {
        CompilerDirectives.transferToInterpreterAndInvalidate();
        long value;

        for (int b = 0; b <= 0xFF; b++) {
            for (int t = 0; t <= 15; t++) {
                value = expensiveDither32To16threshold(b, t);
                DITHER_8_LOOKUP[(int) (((long) t << 8) + b)] = (int) value;
            }
        }
    }

    /* BitBltSimulation>>#initialiseModule */
    private void initialiseModule() {
        initBBOpTable();
        initDither8Lookup();
    }

    /* Return true if shiftTable/maskTable define an identity mapping. */

    /* BitBltSimulation>>#isIdentityMap:with: */
    private static boolean isIdentityMapwith(final int[] shifts, final int[] masks) {
        if (shifts == null || masks == null) {
            return true;
        }
        return shifts[RED_INDEX] == 0 && shifts[GREEN_INDEX] == 0 && shifts[BLUE_INDEX] == 0 && shifts[ALPHA_INDEX] == 0 &&
                        masks[RED_INDEX] == 0xFF0000 && masks[GREEN_INDEX] == 0xFF00 && masks[BLUE_INDEX] == 0xFF && masks[ALPHA_INDEX] == 0xFF000000;
    }

    /*
     * Load the dest form for BitBlt. Answer false if anything is wrong, true otherwise.
     */

    /* BitBltSimulation>>#loadBitBltDestForm */
    private boolean loadBitBltDestForm() {
        if (!(isPointers(destForm) && slotSizeOf(destForm) >= 4)) {
            return false;
        }
        final Object destBitsValue = fetchPointerofObject(FORM.BITS, destForm);
        destWidth = fetchIntegerofObject(FORM.WIDTH, destForm);
        destHeight = fetchIntegerofObject(FORM.HEIGHT, destForm);
        if (!(destWidth >= 0 && destHeight >= 0)) {
            return false;
        }
        destDepth = fetchIntegerofObject(FORM.DEPTH, destForm);
        if (!(destMSB = destDepth > 0)) {
            destDepth = 0 - destDepth;
        }
        if (!isWordsOrBytes(destBitsValue)) {
            if (destBitsValue instanceof Long) {
                throw SqueakException.create("Not supported: Query for actual surface dimensions");
            } else {
                return false;
            }
        }
        destPPW = div(32, destDepth);
        destPitch = div(destWidth + destPPW - 1, destPPW) * 4;
        final NativeObject destBitsNative = (NativeObject) destBitsValue;
        final long destBitsSize;
        if (isWords(destBitsNative)) {
            destBits = destBitsNative.getIntStorage();
            destBytes = null;
            destBitsSize = destBits.length * 4;
        } else {
            destBytes = destBitsNative.getByteStorage();
            destBits = null;
            destBitsSize = destBytes.length;
        }
        return destBitsSize >= destPitch * destHeight;
    }

    /*
     * Load BitBlt from the oop. This function is exported for the Balloon engine.
     */

    /* BitBltSimulation>>#loadBitBltFrom: */
    protected boolean loadBitBltFrom(final PointersObject bbObj) {
        return loadBitBltFromwarping(bbObj, false);
    }

    /* Load context from BitBlt instance. Return false if anything is amiss */
    /*
     * NOTE this should all be changed to minX/maxX coordinates for simpler clipping -- once it
     * works!
     */

    /* BitBltSimulation>>#loadBitBltFrom:warping: */
    private boolean loadBitBltFromwarping(final PointersObject bbObj, final boolean aBool) {
        boolean ok;

        bitBltOop = bbObj;
        isWarping = aBool;
        combinationRule = fetchIntegerofObject(BB_RULE_INDEX, bitBltOop);
        if (failed() || combinationRule < 0 || combinationRule > OP_TABLE_SIZE - 2) {
            return false;
        }
        if (combinationRule >= 16 && combinationRule <= 17) {
            return false;
        }
        sourceForm = fetchPointerofObjectOrNull(BB_SOURCE_FORM_INDEX, bitBltOop);
        noSource = ignoreSourceOrHalftone(sourceForm);
        halftoneForm = (AbstractSqueakObject) fetchPointerofObject(BB_HALFTONE_FORM_INDEX, bitBltOop);
        noHalftone = ignoreSourceOrHalftone(halftoneForm == NilObject.SINGLETON ? null : halftoneForm);
        destForm = fetchPointerofObjectOrNull(BB_DEST_FORM_INDEX, bitBltOop);
        ok = loadBitBltDestForm();
        if (!ok) {
            return false;
        }
        destX = fetchIntOrFloatofObjectifNil(BB_DEST_X_INDEX, bitBltOop, 0);
        destY = fetchIntOrFloatofObjectifNil(BB_DEST_Y_INDEX, bitBltOop, 0);
        width = fetchIntOrFloatofObjectifNil(BB_WIDTH_INDEX, bitBltOop, destWidth);
        height = fetchIntOrFloatofObjectifNil(BB_HEIGHT_INDEX, bitBltOop, destHeight);
        if (failed()) {
            return false;
        }
        if (noSource) {
            sourceX = sourceY = 0;
        } else {
            ok = loadBitBltSourceForm();
            if (!ok) {
                return false;
            }
            ok = loadColorMap();
            if (!ok) {
                return false;
            }
            if ((cmFlags & COLOR_MAP_NEW_STYLE) == 0) {
                setupColorMasks();
            }
            sourceX = fetchIntOrFloatofObjectifNil(BB_SOURCE_X_INDEX, bitBltOop, 0);
            sourceY = fetchIntOrFloatofObjectifNil(BB_SOURCE_Y_INDEX, bitBltOop, 0);
        }
        ok = loadHalftoneForm();
        if (!ok) {
            return false;
        }
        clipX = fetchIntOrFloatofObjectifNil(BB_CLIP_X_INDEX, bitBltOop, 0);
        clipY = fetchIntOrFloatofObjectifNil(BB_CLIP_Y_INDEX, bitBltOop, 0);
        clipWidth = fetchIntOrFloatofObjectifNil(BB_CLIP_WIDTH_INDEX, bitBltOop, destWidth);
        clipHeight = fetchIntOrFloatofObjectifNil(BB_CLIP_HEIGHT_INDEX, bitBltOop, destHeight);
        if (failed()) {
            return false;
        }
        if (clipX < 0) {
            clipWidth += clipX;
            clipX = 0;
        }
        if (clipY < 0) {
            clipHeight += clipY;
            clipY = 0;
        }
        if (clipX + clipWidth > destWidth) {
            clipWidth = destWidth - clipX;
        }
        if (clipY + clipHeight > destHeight) {
            clipHeight = destHeight - clipY;
        }
        return true;
    }

    /*
     * Load the source form for BitBlt. Return false if anything is wrong, true otherwise.
     */

    /* BitBltSimulation>>#loadBitBltSourceForm */
    private boolean loadBitBltSourceForm() {
        if (!(isPointers(sourceForm) && slotSizeOf(sourceForm) >= 4)) {
            return false;
        }
        final Object sourceBitsValue = fetchPointerofObject(FORM.BITS, sourceForm);
        sourceWidth = fetchIntOrFloatofObject(FORM.WIDTH, sourceForm);
        sourceHeight = fetchIntOrFloatofObject(FORM.HEIGHT, sourceForm);
        if (!(sourceWidth >= 0 && sourceHeight >= 0)) {
            return false;
        }
        sourceDepth = fetchIntegerofObject(FORM.DEPTH, sourceForm);
        if (!(sourceMSB = sourceDepth > 0)) {
            sourceDepth = 0 - sourceDepth;
        }
        if (!isWordsOrBytes(sourceBitsValue)) {
            if (sourceBitsValue instanceof Long) {
                throw SqueakException.create("Not supported: Query for actual surface dimensions");
            } else {
                return false;
            }
        }
        sourcePPW = div(32, sourceDepth);
        sourcePitch = div(sourceWidth + sourcePPW - 1, sourcePPW) * 4;
        final NativeObject sourceBitsNative = (NativeObject) sourceBitsValue;
        if (isWords(sourceBitsNative)) {
            sourceBitsIsWords = true;
            final int[] ints = sourceBitsNative.getIntStorage();
            sourceBits = ints;
            return ints.length * Integer.BYTES >= sourcePitch * sourceHeight;
        } else {
            sourceBitsIsWords = false;
            final byte[] bytes = sourceBitsNative.getByteStorage();
            if (bytes.length >= sourcePitch * sourceHeight) {
                sourceBits = bytes;
                return true;
            } else {
                return false;
            }
        }
    }

    /*
     * ColorMap, if not nil, must be longWords, and 2^N long, where N = sourceDepth for 1, 2, 4, 8
     * bits, or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits.
     */

    /* BitBltSimulation>>#loadColorMap */
    private boolean loadColorMap() {
        final Object cmOop;
        final long cmSize;
        boolean oldStyle;
        final NativeObject oop;

        cmFlags = cmMask = cmBitsPerColor = 0;
        cmShiftTable = null;
        cmMaskTable = null;
        cmLookupTable = null;
        cmOop = fetchPointerofObject(BB_COLOR_MAP_INDEX, bitBltOop);
        if (cmOop == NilObject.SINGLETON) {
            return true;
        }

        /* even if identity or somesuch - may be cleared later */
        cmFlags = COLOR_MAP_PRESENT;
        oldStyle = false;
        if (cmOop instanceof NativeObject && isWords((NativeObject) cmOop)) {
            /* This is an old-style color map (indexed only, with implicit RGBA conversion) */
            cmSize = slotSizeOfWords((NativeObject) cmOop);
            cmLookupTable = ((NativeObject) cmOop).getIntStorage();
            oldStyle = true;
        } else {

            /* A new-style color map (fully qualified) */
            if (!(isPointers(cmOop) && slotSizeOf((PointersObject) cmOop) >= 3)) {
                return false;
            }
            final PointersObject cmOopPointers = (PointersObject) cmOop;
            cmShiftTable = loadColorMapShiftOrMaskFrom(fetchNativeofObjectOrNull(0, cmOopPointers));
            cmMaskTable = loadColorMapShiftOrMaskFrom(fetchNativeofObjectOrNull(1, cmOopPointers));
            oop = fetchNativeofObjectOrNull(2, cmOopPointers);
            if (oop == null) {
                cmSize = 0;
            } else {
                if (!isWords(oop)) {
                    return false;
                }
                cmLookupTable = oop.getIntStorage();
                cmSize = cmLookupTable.length;
            }
            cmFlags = cmFlags | COLOR_MAP_NEW_STYLE;
        }
        if ((cmSize & cmSize - 1) != 0) {
            return false;
        }
        cmMask = cmSize - 1;
        cmBitsPerColor = 0;
        if (cmSize == 512) {
            cmBitsPerColor = 3;
        }
        if (cmSize == 4096) {
            cmBitsPerColor = 4;
        }
        if (cmSize == 32768) {
            cmBitsPerColor = 5;
        }
        if (cmSize == 0) {
            cmLookupTable = null;
            cmMask = 0;
        } else {
            cmFlags = cmFlags | COLOR_MAP_INDEXED_PART;
        }
        if (oldStyle) {
            /* needs implicit conversion */
            setupColorMasks();
        }
        if (isIdentityMapwith(cmShiftTable, cmMaskTable)) {
            cmMaskTable = null;
            cmShiftTable = null;
        } else {
            cmFlags = cmFlags | COLOR_MAP_FIXED_PART;
        }
        return true;
    }

    /* BitBltSimulation>>#loadColorMapShiftOrMaskFrom: */
    private static int[] loadColorMapShiftOrMaskFrom(final NativeObject mapOop) {
        if (mapOop == null) {
            return null;
        }
        if (!(isWords(mapOop) && slotSizeOfWords(mapOop) == 4)) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        return mapOop.getIntStorage();
    }

    /* Load the halftone form */

    /* BitBltSimulation>>#loadHalftoneForm */
    private boolean loadHalftoneForm() {
        if (noHalftone) {
            halftoneBits = null;
            return true;
        }
        final NativeObject halftoneBitsValue;
        if (isPointers(halftoneForm) && slotSizeOf((VariablePointersObject) halftoneForm) >= 4) {
            /* Old-style 32xN monochrome halftone Forms */
            halftoneBitsValue = fetchNativeofObjectOrNull(FORM.BITS, (VariablePointersObject) halftoneForm);
            halftoneHeight = fetchIntegerofObject(FORM.HEIGHT, (VariablePointersObject) halftoneForm);
            if (!isWords(halftoneBitsValue)) {
                noHalftone = true;
            } else {
                halftoneBits = halftoneBitsValue.getIntStorage();
            }
        } else {
            /* New spec accepts, basically, a word array */
            if (!isWords(halftoneForm)) {
                return false;
            }
            halftoneBitsValue = (NativeObject) halftoneForm;
            halftoneBits = halftoneBitsValue.getIntStorage();
            halftoneHeight = halftoneBits.length;
        }
        return true;
    }

    /* BitBltSimulation>>#loadSurfacePlugin not needed for GraalSqueak */

    /* BitBltSimulation>>#loadWarpBltFrom: */
    private boolean loadWarpBltFrom(final PointersObject bbObj) {
        return loadBitBltFromwarping(bbObj, true);
    }

    /* BitBltSimulation>>#lockSurfaces */
    private boolean lockSurfaces() {
        hasSurfaceLock = false;

        // Actual locking code not needed for GraalSqueak.
        assert destBits != null || destBytes != null : "Unexpected `null` value";
        assert sourceBits != null || noSource;

        endOfSource = noSource || sourceBits == null ? 0 : sourcePitch * sourceHeight;
        endOfDestination = destPitch * destHeight;
        return (destBits != null || destBytes != null) && (sourceBits != null || noSource);
    }

    /* Color map the given source pixel. */

    /* BitBltSimulation>>#mapPixel:flags: */
    private long mapPixelflags(final long sourcePixel, final long mapperFlags) {
        long pv;

        pv = sourcePixel;
        if ((mapperFlags & COLOR_MAP_PRESENT) != 0) {
            if ((mapperFlags & COLOR_MAP_FIXED_PART) != 0) {
                /* avoid introducing transparency by color reduction */
                pv = rgbMapPixelflags(sourcePixel);
                if (pv == 0 && sourcePixel != 0) {
                    pv = 1;
                }
            }
            if ((mapperFlags & COLOR_MAP_INDEXED_PART) != 0) {
                pv = cmLookupTable[(int) (pv & cmMask)];
            }
        }
        return pv;
    }

    /* BitBltSimulation>>#merge:with: omitted (no senders) */

    /*
     * The module with the given name was just unloaded. Make sure we have no dangling references.
     */

    /* BitBltSimulation>>#moduleUnloaded: omitted */

    /*
     * Subract the pixels in the source and destination, color by color, and return the sum of the
     * absolute value of all the differences. For non-rgb, XOR the two and return the number of
     * differing pixels. Note that the region is not clipped to bit boundaries, but only to the
     * nearest (enclosing) word. This is because copyLoop does not do pre-merge masking. For
     * accurate results, you must subtract the values obtained from the left and right fringes.
     */

    /* BitBltSimulation>>#OLDrgbDiff:with: */
    private long oLDrgbDiffwith(final long sourceWord, final long destinationWord) {
        long diff;
        final int pixMask;

        if (destDepth < 16) {
            /* Just xor and count differing bits if not RGB */
            diff = sourceWord ^ destinationWord;
            pixMask = MASK_TABLE[destDepth];
            while (diff != 0) {
                if ((diff & pixMask) != 0) {
                    bitCount++;
                }
                diff = shr(diff, destDepth);
            }
            return destinationWord;
        }
        if (destDepth == 16) {
            diff = partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, 5, 3);
            bitCount = bitCount + (diff & 0x1F) + (diff >>> 5 & 0x1F) + (diff >>> 10 & 0x1F);
            diff = partitionedSubfromnBitsnPartitions(sourceWord >>> 16, destinationWord >>> 16, 5, 3);
            bitCount = bitCount + (diff & 0x1F) + (diff >>> 5 & 0x1F) + (diff >>> 10 & 0x1F);
        } else {
            diff = partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, 8, 3);
            bitCount = bitCount + (diff & 0xFF) + (diff >>> 8 & 0xFF) + (diff >>> 16 & 0xFF);
        }
        return destinationWord;
    }

    /*
     * Tally pixels into the color map. Note that the source should be specified = destination, in
     * order for the proper color map checks to be performed at setup. Note that the region is not
     * clipped to bit boundaries, but only to the nearest (enclosing) word. This is because copyLoop
     * does not do pre-merge masking. For accurate results, you must subtract the values obtained
     * from the left and right fringes.
     */

    /* BitBltSimulation>>#OLDtallyIntoMap:with: */
    private long oLDtallyIntoMapwith(@SuppressWarnings("unused") final long sourceWord, final long destinationWord) {
        long mapIndex;
        final long pixMask;
        long shiftWord;
        long value;
        final int value1;
        final int value2;
        final int value3;

        if ((cmFlags & (COLOR_MAP_PRESENT | COLOR_MAP_INDEXED_PART)) != (COLOR_MAP_PRESENT | COLOR_MAP_INDEXED_PART)) {
            return destinationWord;
        }
        if (destDepth < 16) {
            /* loop through all packed pixels. */
            pixMask = MASK_TABLE[destDepth] & cmMask;
            shiftWord = destinationWord;
            for (int i = 1; i <= destPPW; i++) {
                mapIndex = shiftWord & pixMask;
                /* begin tallyMapAt:put: */
                final int index = (int) (mapIndex & cmMask);
                value = cmLookupTable[index] + 1;
                cmLookupTable[index] = (int) value;
                shiftWord = shr(shiftWord, destDepth);
            }
            return destinationWord;
        }
        if (destDepth == 16) {
            /* Two pixels Tally the right half... */
            mapIndex = rgbMapfromto(destinationWord & 0xFFFF, 5, cmBitsPerColor);
            /* begin tallyMapAt:put: */
            final int index = (int) (mapIndex & cmMask);
            value1 = cmLookupTable[index] + 1;
            cmLookupTable[index] = value1;
            mapIndex = rgbMapfromto(destinationWord >>> 16, 5, cmBitsPerColor);
            /* begin tallyMapAt:put: */
            final int index2 = (int) (mapIndex & cmMask);
            value2 = cmLookupTable[index2] + 1;
            cmLookupTable[index2] = value2;
        } else {
            /* Just one pixel. */
            mapIndex = rgbMapfromto(destinationWord, 8, cmBitsPerColor);
            /* begin tallyMapAt:put: */
            final int index = (int) (mapIndex & cmMask);
            value3 = cmLookupTable[index] + 1;
            cmLookupTable[index] = value3;
        }
        return destinationWord;
    }

    /*
     * Add word1 to word2 as nParts partitions of nBits each. This is useful for packed pixels, or
     * packed colors
     */
    /*
     * Use long everywhere because it has a well known arithmetic model without undefined behavior
     * w.r.t. overflow and shifts
     */

    /* BitBltSimulation>>#partitionedAdd:to:nBits:componentMask:carryOverflowMask: */
    private static long partitionedAddtonBitscomponentMaskcarryOverflowMask(final long word1, final long word2, final long nBits, final long componentMask, final long carryOverflowMask) {
        final long carryOverflow;
        final long sum;
        final long w1;
        final long w2;

        /* mask to remove high bit of each component */
        w1 = word1 & carryOverflowMask;
        w2 = word2 & carryOverflowMask;
        /* sum without high bit to avoid overflowing over next component */
        sum = (word1 ^ w1) + (word2 ^ w2);
        /* detect overflow condition for saturating */
        carryOverflow = w1 & w2 | (w1 | w2) & sum;
        return sum ^ w1 ^ w2 | shr(carryOverflow, nBits - 1) * componentMask;
    }

    /*
     * AND word1 to word2 as nParts partitions of nBits each. Any field of word1 not all-ones is
     * treated as all-zeroes. Used for erasing, eg, brush shapes prior to ORing in a color
     */

    /* BitBltSimulation>>#partitionedAND:to:nBits:nPartitions: */
    private static long partitionedANDtonBitsnPartitions(final long word1, final long word2, final int nBits, final int nParts) {
        long mask;
        long result;

        /* partition mask starts at the right */
        mask = MASK_TABLE[nBits];
        result = 0;
        if (nBits == 32) {
            if (word1 == mask) {
                result = result | word2;
            }
        } else {
            for (int i = 1; i <= nParts; i++) {
                if ((word1 & mask) == mask) {
                    result = result | word2 & mask;
                }
                /* slide left to next partition */
                mask = shl(mask, nBits);
            }
        }
        return result;
    }

    /* Max word1 to word2 as nParts partitions of nBits each */
    /*
     * In C, most arithmetic operations answer the same bit pattern regardless of the operands being
     * signed or longs (this is due to the way 2's complement numbers work). However, comparisions
     * might fail. Add the proper declaration of words as long in those cases where comparisions are
     * done (jmv)
     */

    /* BitBltSimulation>>#partitionedMax:with:nBits:nPartitions: */
    private static long partitionedMaxwithnBitsnPartitions(final long word1, final long word2, final int nBits, final int nParts) {
        long mask;
        long result;

        /* partition mask starts at the right */
        mask = MASK_TABLE[nBits];
        if (nBits == 32) {
            result = Math.max(word1, word2);
        } else {
            result = 0;
            for (int i = 1; i <= nParts; i++) {
                result = result | Math.max(word2 & mask, word1 & mask);
                /* slide left to next partition */
                mask = shl(mask, nBits);
            }
        }
        return result;
    }

    /* Min word1 to word2 as nParts partitions of nBits each */
    /*
     * In C, most arithmetic operations answer the same bit pattern regardless of the operands being
     * signed or longs (this is due to the way 2's complement numbers work). However, comparisions
     * might fail. Add the proper declaration of words as long in those cases where comparisions are
     * done (jmv)
     */

    /* BitBltSimulation>>#partitionedMin:with:nBits:nPartitions: */
    private static long partitionedMinwithnBitsnPartitions(final long word1, final long word2, final int nBits, final int nParts) {
        long mask;
        long result;

        /* partition mask starts at the right */
        mask = MASK_TABLE[nBits];
        if (nBits == 32) {
            result = Math.min(word1, word2);
        } else {
            result = 0;
            for (int i = 1; i <= nParts; i++) {
                result = result | Math.min(word2 & mask, word1 & mask);
                /* slide left to next partition */
                mask = shl(mask, nBits);
            }
        }
        return result;
    }

    /*
     * Multiply word1 with word2 as nParts partitions of nBits each. This is useful for packed
     * pixels, or packed colors. Bug in loop version when non-white background
     */
    /*
     * In C, integer multiplication might answer a wrong value if the unsigned values are declared
     * as signed. This problem does not affect this method, because the most significant bit (i.e.
     * the sign bit) will always be zero (jmv)
     */

    /* BitBltSimulation>>#partitionedMul:with:nBits:nPartitions: */
    private static long partitionedMulwithnBitsnPartitions(final long word1, final long word2, final int nBits, final int nParts) {
        final long dMask;
        long product;
        long result;
        final long sMask;

        /* partition mask starts at the right */
        sMask = MASK_TABLE[nBits];
        dMask = shl(sMask, nBits);
        /* optimized first step */
        result = shr(((word1 & sMask) + 1) * ((word2 & sMask) + 1) - 1 & dMask, nBits);
        if (nParts == 1) {
            return result;
        }
        product = ((shr(word1, nBits) & sMask) + 1) * ((shr(word2, nBits) & sMask) + 1) - 1 & dMask;
        result = result | product;
        if (nParts == 2) {
            return result;
        }
        product = ((shr(word1, 2 * nBits) & sMask) + 1) * ((shr(word2, 2 * nBits) & sMask) + 1) - 1 & dMask;
        result = result | shl(product, nBits);
        if (nParts == 3) {
            return result;
        }
        product = ((shr(word1, 3 * nBits) & sMask) + 1) * ((shr(word2, 3 * nBits) & sMask) + 1) - 1 & dMask;
        result = result | shl(product, 2 * nBits);
        return result;
    }

    /* BitBltSimulation>>#partitionedRgbComponentAlpha:dest:nBits:nPartitions: */
    private long partitionedRgbComponentAlphadestnBitsnPartitions(final long sourceWord, final long destWord, final int nBits, final int nParts) {
        long mask;
        long p1;
        long p2;
        long result;
        long v;

        /* partition mask starts at the right */
        mask = MASK_TABLE[nBits];
        result = 0;
        for (int i = 1; i <= nParts; i++) {
            p1 = shr(sourceWord & mask, (i - 1) * nBits);
            p2 = shr(destWord & mask, (i - 1) * nBits);
            if (nBits != 32) {
                if (nBits == 16) {
                    p1 = (p1 & 0x1F) << 3 | (p1 & 0x3E0) << 6 | (p1 & 0x7C00) << 9 | 0xFF000000L;
                    p2 = (p2 & 0x1F) << 3 | (p2 & 0x3E0) << 6 | (p2 & 0x7C00) << 9 | 0xFF000000L;
                } else {
                    p1 = rgbMapfromto(p1, nBits, 32) | 0xFF000000L;
                    p2 = rgbMapfromto(p2, nBits, 32) | 0xFF000000L;
                }
            }
            v = rgbComponentAlpha32with(p1, p2);
            if (nBits != 32) {
                v = rgbMapfromto(v, 32, nBits);
            }
            result = result | shl(v, (i - 1) * nBits);
            /* slide left to next partition */
            mask = shl(mask, nBits);
        }
        return result;
    }

    /*
     * Subtract word1 from word2 as nParts partitions of nBits each. This is useful for packed
     * pixels, or packed colors
     */
    /*
     * In C, most arithmetic operations answer the same bit pattern regardless of the operands being
     * signed or longs (this is due to the way 2's complement numbers work). However, comparisions
     * might fail. Add the proper declaration of words as long in those cases where comparisions are
     * done (jmv)
     */

    /* BitBltSimulation>>#partitionedSub:from:nBits:nPartitions: */
    private static long partitionedSubfromnBitsnPartitions(final long word1, final long word2, final int nBits, final int nParts) {
        long mask;
        long p1;
        long p2;
        long result;

        /* partition mask starts at the right */
        mask = MASK_TABLE[nBits];
        if (nBits == 32) {
            result = word1 < word2 ? word2 - word1 : word1 - word2;
        } else {
            result = 0;
            for (int i = 1; i <= nParts; i++) {
                p1 = word1 & mask;
                p2 = word2 & mask;
                if (p1 < p2) {
                    /* result is really abs value of thedifference */
                    result = result | p2 - p1;
                } else {
                    result = result | p1 - p2;
                }
                /* slide left to next partition */
                mask = shl(mask, nBits);
            }
        }
        return result;
    }

    /*
     * Based on the values provided during setup choose and perform the appropriate inner loop
     * function.
     */

    /* BitBltSimulation>>#performCopyLoop */
    private void performCopyLoop() {
        destMaskAndPointerInit();
        if (noSource) {
            /* Simple fill loop */
            copyLoopNoSource();
        } else {
            /* Loop using source and dest */
            checkSourceOverlap();
            if (sourceDepth != destDepth || cmFlags != 0 || sourceMSB != destMSB) {
                /*
                 * If we must convert between pixel depths or use color lookups or swap pixels use
                 * the general version
                 */
                copyLoopPixMap();
            } else {
                /* Otherwise we simply copy pixels and can use a faster version */
                sourceSkewAndPointerInit();
                copyLoop();
            }
        }
    }

    /*
     * Pick nPix pixels starting at srcBitIndex from the source, map by the color map, and justify
     * them according to dstBitIndex in the resulting destWord.
     */

    /* BitBltSimulation>>#pickSourcePixels:flags:srcMask:destMask:srcShiftInc:dstShiftInc: */
    private long pickSourcePixelsflagssrcMaskdestMasksrcShiftIncdstShiftInc(final long nPixels, final long mapperFlags, final long srcMask, final long dstMask, final long srcShiftInc,
                    final long dstShiftInc) {
        long destPix;
        long destWord;
        long dstShift;
        long nPix;
        long sourcePix;
        long sourceWord;
        long srcShift;

        destWord = 0;

        /* Hint: Keep in register */
        srcShift = srcBitShift;
        /* Hint: Keep in register */
        dstShift = dstBitShift;
        /* always > 0 so we can use do { } while(--nPix); */
        nPix = nPixels;
        if (mapperFlags == (COLOR_MAP_PRESENT | COLOR_MAP_INDEXED_PART)) {
            /* a little optimization for (pretty crucial) blits using indexed lookups only */
            /* grab, colormap and mix in pixel */
            do {
                sourceWord = srcLongAt(sourceIndex);
                sourcePix = shr(sourceWord, srcShift) & srcMask;
                destPix = cmLookupTable[(int) (sourcePix & cmMask)];
                /* adjust dest pix index */
                destWord = destWord | shl(destPix & dstMask, dstShift);
                /* adjust source pix index */
                dstShift += dstShiftInc;
                if (((srcShift += srcShiftInc) & 0xFFFFFFE0L) != 0) {
                    srcShift = sourceMSB ? srcShift + 32 : srcShift - 32;
                    /* begin incSrcIndex: */
                    sourceIndex += 4;
                }
            } while (--nPix > 0);
        } else {
            /* grab, colormap and mix in pixel */
            do {
                sourceWord = srcLongAt(sourceIndex);
                sourcePix = shr(sourceWord, srcShift) & srcMask;
                destPix = mapPixelflags(sourcePix, mapperFlags);
                /* adjust dest pix index */
                destWord = destWord | shl(destPix & dstMask, dstShift);
                /* adjust source pix index */
                dstShift += dstShiftInc;
                if (((srcShift += srcShiftInc) & 0xFFFFFFE0L) != 0) {
                    srcShift = sourceMSB ? srcShift + 32 : srcShift - 32;
                    /* begin incSrcIndex: */
                    sourceIndex += 4;
                }
            } while (--nPix > 0);
        }
        /* Store back */
        srcBitShift = srcShift;
        return destWord;
    }

    /*
     * Pick a single pixel from the source for WarpBlt. Note: This method is crucial for WarpBlt
     * speed w/o smoothing and still relatively important when smoothing is used.
     */

    /* BitBltSimulation>>#pickWarpPixelAtX:y: */
    private long pickWarpPixelAtXy(final long xx, final long yy) {
        final long sourcePix;
        final long sourceWord;
        final long x;
        final long y;

        /*
         * note: it would be much faster if we could just avoid these stupid tests for being inside
         * sourceForm.
         */
        if (xx < 0 || yy < 0 || (x = xx >>> BINARY_POINT) >= sourceWidth || (y = yy >>> BINARY_POINT) >= sourceHeight) {
            return 0;
        }
        final long srcIndex = y * sourcePitch + shr(x, warpAlignShift) * 4;
        /* Extract pixel from word */
        sourceWord = srcLongAt(srcIndex);
        srcBitShift = warpBitShiftTable[(int) (x & warpAlignMask)];
        sourcePix = shr(sourceWord, srcBitShift) & warpSrcMask;
        return sourcePix;
    }

    /*
     * Clear all pixels in destinationWord for which the pixels of sourceWord have the same values.
     * Used to clear areas of some constant color to zero.
     */

    /* BitBltSimulation>>#pixClear:with: */
    private long pixClearwith(final long sourceWord, final long destinationWord) {
        long mask;
        final int nBits;
        long pv;
        long result;

        if (destDepth == 32) {
            if (sourceWord == destinationWord) {
                return 0;
            } else {
                return destinationWord;
            }
        }
        nBits = destDepth;
        /* partition mask starts at the right */
        mask = MASK_TABLE[nBits];
        result = 0;
        for (int i = 1; i <= destPPW; i++) {
            pv = destinationWord & mask;
            if ((sourceWord & mask) == pv) {
                pv = 0;
            }
            result = result | pv;
            /* slide left to next partition */
            mask = shl(mask, nBits);
        }
        return result;
    }

    /* BitBltSimulation>>#pixMask:with: */
    private long pixMaskwith(final long sourceWord, final long destinationWord) {
        return partitionedANDtonBitsnPartitions(~sourceWord, destinationWord, destDepth, destPPW);
    }

    /* BitBltSimulation>>#pixPaint:with: */
    private long pixPaintwith(final long sourceWord, final long destinationWord) {
        if (sourceWord == 0) {
            return destinationWord;
        }
        return sourceWord | partitionedANDtonBitsnPartitions(~sourceWord, destinationWord, destDepth, destPPW);
    }

    /* Swap the pixels in destWord */

    /* BitBltSimulation>>#pixSwap:with: */
    private long pixSwapwith(@SuppressWarnings("unused") final long sourceWord, final long destWord) {
        long highMask;
        long lowMask;
        long result;
        int shift;

        if (destPPW == 1) {
            return destWord;
        }
        result = 0;
        /* mask low pixel */
        lowMask = shl(1, destDepth) - 1;
        /* mask high pixel */
        highMask = shl(lowMask, (destPPW - 1) * destDepth);
        shift = 32 - destDepth;
        result = result | shl(destWord & lowMask, shift) | shr(destWord & highMask, shift);
        if (destPPW <= 2) {
            return result;
        }
        for (int i = 2; i <= destPPW / 2; i++) {
            lowMask = shl(lowMask, destDepth);
            highMask = shr(highMask, destDepth);
            shift -= destDepth * 2;
            result = result | shl(destWord & lowMask, shift) | shr(destWord & highMask, shift);
        }
        return result;
    }

    /*
     * Invoke the copyBits primitive. If the destination is the display, then copy it to the screen.
     */

    /* BitBltSimulation>>#primitiveCopyBits */
    public Object primitiveCopyBits(final PointersObject bbObj, final long factor) {
        if (!loadBitBltFromwarping(bbObj, false)) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        try {
            copyBits(factor);
            assert !failed();
            showDisplayBits();
            assert !failed();
        } catch (final AssertionError e) {
            bbObj.image.printToStdErr(e.getMessage());
            PrimitiveFailed.andTransferToInterpreter();
        }
        if (combinationRule == 22 || combinationRule == 32) {
            return bitCount;
        } else {
            return bbObj;
        }
    }

    /* BitBltSimulation>>#primitiveDisplayString */
    public Object primitiveDisplayString(final PointersObject bbObj, final NativeObject sourceString, final long startIndex, final long stopIndex, final long[] glyphMap,
                    final long[] xTable, final int kernDelta) {
        int ascii;
        int glyphIndex;
        final int left;
        final long maxGlyph;
        final boolean quickBlt;

        /**
         * Most checks moved to guard of specialization in {@link PrimDisplayStringNode}.
         *
         * <pre>
         * if (!(slotSizeOf(glyphMap) == 256 && isBytes(sourceString) && startIndex > 0 && stopIndex >= 0 &&
         *              stopIndex <= sourceString.getByteLength() && loadBitBltFromwarping(bbObj, false) && combinationRule != 30 && combinationRule != 0x1F)) {
         * </pre>
         */
        if (!(loadBitBltFromwarping(bbObj, false) && combinationRule != 30 && combinationRule != 0x1F)) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        /**
         * Check moved to guard of specialization in {@link PrimDisplayStringNode}.
         *
         * <pre>
         * if (stopIndex == 0) {
         *     return bbObj;
         * }
         * </pre>
         */

        /* See if we can go directly into copyLoopPixMap (usually we can) */
        maxGlyph = xTable.length - 2;
        /* no point using slower version */
        quickBlt = (destBits != null || destBytes != null) && sourceBits != null &&
                        !noSource && sourceForm != destForm && (cmFlags != 0 || sourceMSB != destMSB || sourceDepth != destDepth);
        if (quickBlt) {
            endOfSource = sourcePitch * sourceHeight;
            endOfDestination = destPitch * destHeight;
        } else {
            if (!lockSurfaces()) {
                PrimitiveFailed.andTransferToInterpreter();
            }
        }
        left = destX;
        final byte[] sourceStringBytes = sourceString.getByteStorage();
        for (int charIndex = (int) startIndex; charIndex <= stopIndex; charIndex++) {
            ascii = Byte.toUnsignedInt(sourceStringBytes[charIndex - 1]);
            glyphIndex = (int) glyphMap[ascii];
            if (glyphIndex < 0 || glyphIndex > maxGlyph) {
                PrimitiveFailed.andTransferToInterpreter();
            }
            sourceX = (int) xTable[glyphIndex];
            width = (int) (xTable[glyphIndex + 1] - sourceX);
            assert !failed();
            clipRange();
            if (bbW > 0 && bbH > 0) {
                if (quickBlt) {
                    destMaskAndPointerInit();
                    copyLoopPixMap();
                    affectedL = dx;
                    affectedR = dx + bbW;
                    affectedT = dy;
                    affectedB = dy + bbH;
                } else {
                    copyBitsLockedAndClipped();
                }
            }
            assert !failed();
            destX = destX + width + kernDelta;
        }
        affectedL = left;
        if (!quickBlt) {
            unlockSurfaces();
        }
        showDisplayBits();
        storeIntegerofObjectwithValue(BB_DEST_X_INDEX, bbObj, destX);
        return bbObj;
    }

    /* Invoke the line drawing primitive. */

    /* BitBltSimulation>>#primitiveDrawLoop */
    public Object primitiveDrawLoop(final PointersObject bbObj, final long xDelta, final long yDelta) {
        if (!loadBitBltFromwarping(bbObj, false)) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        if (!failed()) {
            drawLoopXY(xDelta, yDelta);
            showDisplayBits();
        }
        return bbObj;
    }

    /*
     * returns the single pixel at x@y. It does not handle LSB bitmaps right now. If x or y are < 0,
     * return 0 to indicate transparent (cf BitBlt>bitPeekerFromForm: usage). Likewise if x>width or
     * y>depth. Fail if the rcvr doesn't seem to be a Form, or x|y seem wrong
     */

    /* BitBltSimulation>>#primitivePixelValueAtX:y: */
    public long primitivePixelValueAt(final PointersObject bbObj, final long xVal, final long yVal) {
        final NativeObject bitmap;
        final long bitsSize;
        final long depth;
        final long mask;
        final long pixel;
        final long ppW;
        final long shift;
        final long stride;
        final long word;

        if (xVal < 0 || yVal < 0) {
            return 0L;
        }
        if (!(isPointers(bbObj) && slotSizeOf(bbObj) >= 4)) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        bitmap = fetchNativeofObjectOrNull(FORM.BITS, bbObj);
        if (!isWordsOrBytes(bitmap)) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        width = fetchIntegerofObject(FORM.WIDTH, bbObj);
        height = fetchIntegerofObject(FORM.HEIGHT, bbObj);
        /* if width/height/depth are not integer, fail */
        depth = fetchIntegerofObject(FORM.DEPTH, bbObj);
        assert !failed();
        if (xVal >= width || yVal >= height) {
            return 0L;
        }
        if (depth < 0) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        /* pixels in each word */
        ppW = div(32, depth);
        /* how many words per row of pixels */
        stride = div(width + (ppW - 1), ppW);
        if (isWords(bitmap)) {
            bitsSize = bitmap.getIntLength() * Integer.SIZE;
        } else {
            bitsSize = bitmap.getByteLength();
        }
        if (bitsSize < stride * height * 4) {
            /* bytes per word */
            PrimitiveFailed.andTransferToInterpreter();
        }
        /* load the word that contains our target */
        final long index = yVal * stride + div(xVal, ppW);
        if (isWords(bitmap)) {
            word = Integer.toUnsignedLong(bitmap.getIntStorage()[(int) index]);
        } else {
            word = Integer.toUnsignedLong(UnsafeUtils.getInt(bitmap.getByteStorage(), index));
        }
        /* make a mask to isolate the pixel within that word */
        mask = shr(0xFFFFFFFFL, 32 - depth);
        /*
         * this is the tricky MSB part - we mask the xVal to find how far into the word we need,
         * then add 1 for the pixel we're looking for, then * depth to get the bit shift
         */
        shift = 32 - ((xVal & ppW - 1) + 1) * depth;
        /* shift, mask and dim the lights */
        pixel = shr(word, shift) & mask;
        return pixel;
    }

    /*
     * Invoke the warpBits primitive. If the destination is the display, then copy it to the screen.
     */

    /* BitBltSimulation>>#primitiveWarpBits */
    public PointersObject primitiveWarpBits(final PointersObject bbObj, final long n, final AbstractSqueakObject sourceMap) {
        if (!loadWarpBltFrom(bbObj)) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        warpBits(n, sourceMap);
        assert !failed();
        showDisplayBits();
        assert !failed();
        return bbObj;
    }

    /* BitBltSimulation>>#rgbAdd:with: */
    private long rgbAddwith(final long sourceWord, final long destinationWord) {
        long carryOverflowMask;
        long componentMask;

        if (destDepth < 16) {
            /* Add each pixel separately */
            componentMask = shl(1, destDepth) - 1;
            carryOverflowMask = shl(div(0xFFFFFFFFL, componentMask), destDepth - 1);
            return partitionedAddtonBitscomponentMaskcarryOverflowMask(sourceWord, destinationWord, destDepth, componentMask, carryOverflowMask);
        }
        if (destDepth == 16) {
            /* Add RGB components of each pixel separately */
            componentMask = 0x1F;
            carryOverflowMask = 1108361744;
            return partitionedAddtonBitscomponentMaskcarryOverflowMask(sourceWord & 2147450879, destinationWord & 2147450879, 5, componentMask, carryOverflowMask);
        } else {
            /* Add RGBA components of the pixel separately */
            componentMask = 0xFF;
            carryOverflowMask = 2155905152L;
            return partitionedAddtonBitscomponentMaskcarryOverflowMask(sourceWord, destinationWord, 8, componentMask, carryOverflowMask);
        }
    }

    /*
     * This version assumes combinationRule = 41 sourcePixSize = 32 destPixSize = 16 sourceForm ~=
     * destForm.
     */

    /* BitBltSimulation>>#rgbComponentAlpha16 */
    private void rgbComponentAlpha16() {
        int deltaX;
        int deltaY;
        long destWord;
        int ditherBase;
        int ditherIndex;
        int ditherThreshold;
        long dstIndex;
        long dstMask;
        int dstY;
        long sourceWord;
        long srcAlpha;
        long srcIndex;
        int srcShift;
        int srcY;

        /* So we can pre-decrement */
        deltaY = bbH + 1;
        srcY = sy;
        dstY = dy;
        srcShift = (dx & 1) * 16;
        if (destMSB) {
            srcShift = 16 - srcShift;
        }
        /* This is the outer loop */
        mask1 = shl(0xFFFF, 16 - srcShift);
        while (--deltaY > 0) {
            srcIndex = srcY * sourcePitch + sx * 4;
            dstIndex = dstY * destPitch + dx / 2 * 4;
            ditherBase = (dstY & 3) * 4;
            /* For pre-increment */
            ditherIndex = (sx & 3) - 1;
            /* So we can pre-decrement */
            deltaX = bbW + 1;
            dstMask = mask1;
            if (dstMask == 0xFFFF) {
                srcShift = 16;
            } else {
                srcShift = 0;
            }
            while (--deltaX > 0) {
                ditherThreshold = DITHER_MATRIX_4X4[ditherBase + (ditherIndex = ditherIndex + 1 & 3)];
                sourceWord = srcLongAt(srcIndex);
                srcAlpha = sourceWord & 0xFFFFFF;
                if (srcAlpha != 0) {
                    /* 0 < srcAlpha */
                    /* If we have to mix colors then just copy a single word */
                    /* begin dstLongAt: */
                    destWord = dstLongAt(dstIndex);
                    destWord = destWord & ~dstMask;
                    /* Expand from 16 to 32 bit by adding zero bits */
                    destWord = shr(destWord, srcShift);
                    /* Mix colors */
                    destWord = (destWord & 0x7C00) << 9 | (destWord & 0x3E0) << 6 | (destWord & 0x1F) << 3 | 0xFF000000L;
                    /* And dither */
                    sourceWord = rgbComponentAlpha32with(sourceWord, destWord);
                    sourceWord = dither32To16threshold(sourceWord, ditherThreshold);
                    if (sourceWord == 0) {
                        sourceWord = shl(1, srcShift);
                    } else {
                        sourceWord = shl(sourceWord, srcShift);
                    }
                    destLongAtputmask(dstIndex, dstMask, sourceWord);
                }
                srcIndex += 4;
                if (destMSB) {
                    if (srcShift == 0) {
                        dstIndex += 4;
                    }
                } else {
                    if (srcShift != 0) {
                        dstIndex += 4;
                    }
                }
                /* Toggle between 0 and 16 */
                srcShift = srcShift ^ 16;
                dstMask = ~dstMask;
            }
            srcY++;
            dstY++;
        }
    }

    /*
     * This version assumes combinationRule = 41 sourcePixSize = destPixSize = 32 sourceForm ~=
     * destForm. Note: The inner loop has been optimized for dealing with the special case of aR =
     * aG = aB = 0
     */

    /* BitBltSimulation>>#rgbComponentAlpha32 */
    private void rgbComponentAlpha32() {
        long deltaX;
        int deltaY;
        long destWord;
        long dstIndex;
        int dstY;
        long sourceWord;
        long srcAlpha;
        long srcIndex;
        int srcY;

        /* This particular method should be optimized in itself */
        /* Give the compile a couple of hints */
        /*
         * The following should be declared as pointers so the compiler will notice that they're
         * used for accessing memory locations (good to know on an Intel architecture) but then the
         * increments would be different between ST code and C code so must hope the compiler
         * notices what happens (MS Visual C does)
         */

        /* So we can pre-decrement */
        deltaY = bbH + 1;
        srcY = sy;
        /* This is the outer loop */
        dstY = dy;
        while (--deltaY > 0) {
            srcIndex = srcY * sourcePitch + sx * 4;
            dstIndex = dstY * destPitch + dx * 4;
            /* So we can pre-decrement */
            /* This is the inner loop */
            deltaX = bbW + 1;
            while (--deltaX != 0) {
                sourceWord = srcLongAt(srcIndex);
                srcAlpha = sourceWord & 0xFFFFFF;
                if (srcAlpha == 0) {
                    srcIndex += 4;
                    /* Now skip as many words as possible, */
                    dstIndex += 4;
                    while (--deltaX != 0 && ((sourceWord = srcLongAt(srcIndex)) & 0xFFFFFF) == 0) {
                        srcIndex += 4;
                        dstIndex += 4;
                    }
                    deltaX++;
                } else {
                    /* 0 < srcAlpha */
                    /* If we have to mix colors then just copy a single word */
                    /* begin dstLongAt: */
                    destWord = dstLongAt(dstIndex);
                    destWord = rgbComponentAlpha32with(sourceWord, destWord);
                    /* begin dstLongAt:put: */
                    dstLongAtput(dstIndex, destWord);
                    srcIndex += 4;
                    dstIndex += 4;
                }
            }
            srcY++;
            dstY++;
        }
    }

    /*
     * componentAlphaModeColor is the color, sourceWord contains an alpha value for each component
     * of RGB each of which is encoded as0 meaning 0.0 and 255 meaning 1.0 . the rule is...
     *
     * color = componentAlphaModeColor. colorAlpha = componentAlphaModeAlpha. mask = sourceWord.
     * dst.A = colorAlpha + (1 - colorAlpha) * dst.A dst.R = color.R * mask.R * colorAlpha + (1 -
     * (mask.R * colorAlpha)) * dst.R dst.G = color.G * mask.G * colorAlpha + (1 - (mask.G*
     * colorAlpha)) * dst.G dst.B = color.B * mask.B * colorAlpha + (1 - (mask.B* colorAlpha)) *
     * dst.B
     */

    /* BitBltSimulation>>#rgbComponentAlpha32:with: */
    private long rgbComponentAlpha32with(final long sourceWord, final long destinationWord) {
        long a;
        long aA;
        long aB;
        long aG;
        long alpha;
        final long answer;
        long aR;
        long b;
        long d;
        long dstMask;
        long g;
        long r;
        long s;
        final long srcAlpha;
        long srcColor;

        alpha = sourceWord;
        if (alpha == 0) {
            return destinationWord;
        }
        srcColor = componentAlphaModeColor;
        srcAlpha = componentAlphaModeAlpha & 0xFF;
        aB = alpha & 0xFF;
        alpha = alpha >>> 8;
        aG = alpha & 0xFF;
        alpha = alpha >>> 8;
        aR = alpha & 0xFF;
        alpha = alpha >>> 8;
        aA = alpha & 0xFF;
        if (srcAlpha != 0xFF) {
            aA = aA * srcAlpha >>> 8;
            aR = aR * srcAlpha >>> 8;
            aG = aG * srcAlpha >>> 8;
            aB = aB * srcAlpha >>> 8;
        }
        dstMask = destinationWord;
        d = dstMask & 0xFF;
        s = srcColor & 0xFF;
        if (ungammaLookupTable != null) {
            d = ungammaLookupTable[(int) d];
            s = ungammaLookupTable[(int) s];
        }
        b = (d * (0xFF - aB) >>> 8) + (s * aB >>> 8);
        if (b > 0xFF) {
            b = 0xFF;
        }
        if (gammaLookupTable != null) {
            b = gammaLookupTable[(int) b];
        }
        dstMask = dstMask >>> 8;
        srcColor = srcColor >>> 8;
        d = dstMask & 0xFF;
        s = srcColor & 0xFF;
        if (ungammaLookupTable != null) {
            d = ungammaLookupTable[(int) d];
            s = ungammaLookupTable[(int) s];
        }
        g = (d * (0xFF - aG) >>> 8) + (s * aG >>> 8);
        if (g > 0xFF) {
            g = 0xFF;
        }
        if (gammaLookupTable != null) {
            g = gammaLookupTable[(int) g];
        }
        dstMask = dstMask >>> 8;
        srcColor = srcColor >>> 8;
        d = dstMask & 0xFF;
        s = srcColor & 0xFF;
        if (ungammaLookupTable != null) {
            d = ungammaLookupTable[(int) d];
            s = ungammaLookupTable[(int) s];
        }
        r = (d * (0xFF - aR) >>> 8) + (s * aR >>> 8);
        if (r > 0xFF) {
            r = 0xFF;
        }
        if (gammaLookupTable != null) {
            r = gammaLookupTable[(int) r];
        }
        dstMask = dstMask >>> 8;
        /* no need to gamma correct alpha value ? */
        a = ((dstMask & 0xFF) * (0xFF - aA) >>> 8) + aA;
        if (a > 0xFF) {
            a = 0xFF;
        }
        answer = (((a << 8) + r << 8) + g << 8) + b;
        return answer;
    }

    /*
     * This version assumes combinationRule = 41 sourcePixSize = 32 destPixSize = 8 sourceForm ~=
     * destForm. Note: This is not real blending since we don't have the source colors available.
     */

    /* BitBltSimulation>>#rgbComponentAlpha8 */
    private long rgbComponentAlpha8() {
        long adjust;
        int deltaX;
        int deltaY;
        long destWord;
        long dstIndex;
        long dstMask;
        int dstY;
        final long mapperFlags;
        final long[] mappingTable;
        long sourceWord;
        long srcAlpha;
        long srcIndex;
        long srcShift;
        int srcY;

        /* This particular method should be optimized in itself */
        mappingTable = DEFAULT_8_TO_32_TABLE;
        mapperFlags = cmFlags & ~COLOR_MAP_NEW_STYLE;
        /* So we can pre-decrement */
        deltaY = bbH + 1;
        srcY = sy;
        dstY = dy;
        mask1 = (dx & 3) * 8;
        if (destMSB) {
            mask1 = 24 - mask1;
        }
        mask2 = ALL_ONES ^ shl(0xFF, mask1);
        if ((dx & 1) == 0) {
            adjust = 0;
        } else {
            adjust = 522133279;
        }
        if ((dy & 1) == 0) {
            adjust = adjust ^ 522133279;
        }
        while (--deltaY != 0) {
            adjust = adjust ^ 522133279;
            srcIndex = srcY * sourcePitch + sx * 4;
            dstIndex = dstY * destPitch + dx / 4 * 4;
            /* So we can pre-decrement */
            deltaX = bbW + 1;
            srcShift = mask1;
            /* This is the inner loop */
            dstMask = mask2;
            while (--deltaX != 0) {
                sourceWord = (srcLongAt(srcIndex) & ~adjust) + adjust;
                /* set srcAlpha to the average of the 3 separate aR,Ag,AB values */
                srcAlpha = sourceWord & 0xFFFFFF;
                srcAlpha = div((srcAlpha >>> 16) + (srcAlpha >>> 8 & 0xFF) + (srcAlpha & 0xFF), 3);
                if (srcAlpha > 0x1F) {
                    /* Everything below 31 is transparent */
                    if (srcAlpha > 224) {
                        /* treat everything above 224 as opaque */
                        sourceWord = 0xFFFFFFFFL;
                    }
                    /* begin dstLongAt: */
                    destWord = dstLongAt(dstIndex);
                    destWord = destWord & ~dstMask;
                    destWord = shr(destWord, srcShift);
                    destWord = mappingTable[(int) destWord];
                    sourceWord = rgbComponentAlpha32with(sourceWord, destWord);
                    sourceWord = mapPixelflags(sourceWord, mapperFlags);
                    /* Store back */
                    sourceWord = shl(sourceWord, srcShift);
                    destLongAtputmask(dstIndex, dstMask, sourceWord);
                }
                srcIndex += 4;
                if (destMSB) {
                    if (srcShift == 0) {
                        dstIndex += 4;
                        srcShift = 24;
                        dstMask = 0xFFFFFF;
                    } else {
                        srcShift -= 8;
                        dstMask = dstMask >>> 8 | 0xFF000000L;
                    }
                } else {
                    if (srcShift == 32) {
                        dstIndex += 4;
                        srcShift = 0;
                        dstMask = 0xFFFFFF00L;
                    } else {
                        srcShift += 8;
                        dstMask = dstMask << 8 | 0xFF;
                    }
                }
                adjust = adjust ^ 522133279;
            }
            srcY++;
            dstY++;
        }
        return 0;
    }

    /*
     * componentAlphaModeColor is the color, sourceWord contains an alpha value for each component
     * of RGB each of which is encoded as0 meaning 0.0 and 255 meaning 1.0 . the rule is...
     *
     * color = componentAlphaModeColor. colorAlpha = componentAlphaModeAlpha. mask = sourceWord.
     * dst.A = colorAlpha + (1 - colorAlpha) * dst.A dst.R = color.R * mask.R * colorAlpha + (1 -
     * (mask.R * colorAlpha)) * dst.R dst.G = color.G * mask.G * colorAlpha + (1 - (mask.G*
     * colorAlpha)) * dst.G dst.B = color.B * mask.B * colorAlpha + (1 - (mask.B* colorAlpha)) *
     * dst.B
     */

    /* BitBltSimulation>>#rgbComponentAlpha:with: */
    private long rgbComponentAlphawith(final long sourceWord, final long destinationWord) {
        final long alpha = sourceWord;
        if (alpha == 0) {
            return destinationWord;
        }
        return partitionedRgbComponentAlphadestnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW);
    }

    /*
     * Subtract the pixels in the source and destination, color by color, and return the sum of the
     * absolute value of all the differences. For non-rgb, return the number of differing pixels.
     */

    /* BitBltSimulation>>#rgbDiff:with: */
    private long rgbDiffwith(final long sourceWord, final long destinationWord) {
        final int bitsPerColor;
        long destPixVal;
        long destShifted;
        long diff;
        long maskShifted;
        final long pixMask;
        final long rgbMask;
        long sourcePixVal;
        long sourceShifted;

        pixMask = MASK_TABLE[destDepth];
        if (destDepth == 16) {
            bitsPerColor = 5;
            rgbMask = 0x1F;
        } else {
            bitsPerColor = 8;
            rgbMask = 0xFF;
        }
        maskShifted = destMask;
        destShifted = destinationWord;
        sourceShifted = sourceWord;
        for (int i = 1; i <= destPPW; i++) {
            if ((maskShifted & pixMask) > 0) {
                /* Only tally pixels within the destination rectangle */
                destPixVal = destShifted & pixMask;
                sourcePixVal = sourceShifted & pixMask;
                if (destDepth < 16) {
                    if (sourcePixVal == destPixVal) {
                        diff = 0;
                    } else {
                        diff = 1;
                    }
                } else {
                    diff = partitionedSubfromnBitsnPartitions(sourcePixVal, destPixVal, bitsPerColor, 3);
                    diff = (diff & rgbMask) + (diff >>> bitsPerColor & rgbMask) + (diff >>> bitsPerColor >>> bitsPerColor & rgbMask);
                }
                bitCount += diff;
            }
            maskShifted = maskShifted >>> destDepth;
            sourceShifted = sourceShifted >>> destDepth;
            destShifted = destShifted >>> destDepth;
        }
        return destinationWord;
    }

    /*
     * Convert the given 16bit pixel value to a 32bit RGBA value. Note: This method is intended to
     * deal with different source formats.
     */

    /* BitBltSimulation>>#rgbMap16To32: */
    private static long rgbMap16To32(final long sourcePixel) {
        return (sourcePixel & 0x1F) << 3 | (sourcePixel & 0x3E0) << 6 | (sourcePixel & 0x7C00) << 9;
    }

    /*
     * Convert the given 32bit pixel value to a 32bit RGBA value. Note: This method is intended to
     * deal with different source formats.
     */

    /* BitBltSimulation>>#rgbMap32To32: */
    private static long rgbMap32To32(final long sourcePixel) {
        return sourcePixel;
    }

    /* Perform the RGBA conversion for the given source pixel */

    /* BitBltSimulation>>#rgbMapPixel:flags: */
    private long rgbMapPixelflags(final long sourcePixel) {
        long val;
        val = shift(sourcePixel & cmMaskTable[0], cmShiftTable[0]);
        val = val | shift(sourcePixel & cmMaskTable[1], cmShiftTable[1]);
        val = val | shift(sourcePixel & cmMaskTable[2], cmShiftTable[2]);
        return val | shift(sourcePixel & cmMaskTable[3], cmShiftTable[3]);
    }

    /*
     * Convert the given pixel value with nBitsIn bits for each color component to a pixel value
     * with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or
     * 8.
     */

    /* BitBltSimulation>>#rgbMap:from:to: */
    private static long rgbMapfromto(final long sourcePixel, final long nBitsIn, final long nBitsOut) {
        long d;
        long destPix;
        long mask;
        long srcPix;

        if ((d = nBitsOut - nBitsIn) > 0) {
            /* Expand to more bits by zero-fill */
            /* Transfer mask */
            mask = shl(1, nBitsIn) - 1;
            srcPix = shl(sourcePixel, d);
            mask = shl(mask, d);
            destPix = srcPix & mask;
            mask = shl(mask, nBitsOut);
            srcPix = shl(srcPix, d);
            return destPix + (srcPix & mask) + (shl(srcPix, d) & shl(mask, nBitsOut));
        } else {
            /* Compress to fewer bits by truncation */
            if (d == 0) {
                if (nBitsIn == 5) {
                    /*
                     * Sometimes called with 16 bits, though pixel is 15, but we must never return
                     * more than 15.
                     */
                    return sourcePixel & 0x7FFF;
                }
                if (nBitsIn == 8) {
                    /*
                     * Sometimes called with 32 bits, though pixel is 24, but we must never return
                     * more than 24.
                     */
                    return sourcePixel & 0xFFFFFF;
                }
                return sourcePixel;
            }
            if (sourcePixel == 0) {
                return sourcePixel;
            }
            d = nBitsIn - nBitsOut;
            /* Transfer mask */
            mask = shl(1, nBitsOut) - 1;
            srcPix = shr(sourcePixel, d);
            destPix = srcPix & mask;
            mask = shl(mask, nBitsOut);
            srcPix = shr(srcPix, d);
            destPix = destPix + (srcPix & mask) + (shr(srcPix, d) & shl(mask, nBitsOut));
            if (destPix == 0) {
                return 1L;
            }
            return destPix;
        }
    }

    /* BitBltSimulation>>#rgbMax:with: */
    private long rgbMaxwith(final long sourceWord, final long destinationWord) {
        if (destDepth < 16) {
            /* Max each pixel separately */
            return partitionedMaxwithnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW);
        }
        if (destDepth == 16) {
            /* Max RGB components of each pixel separately */
            return partitionedMaxwithnBitsnPartitions(sourceWord, destinationWord, 5, 3) +
                            (partitionedMaxwithnBitsnPartitions(sourceWord >>> 16, destinationWord >>> 16, 5, 3) << 16);
        } else {
            /* Max RGBA components of the pixel separately */
            return partitionedMaxwithnBitsnPartitions(sourceWord, destinationWord, 8, 4);
        }
    }

    /* BitBltSimulation>>#rgbMinInvert:with: */
    private long rgbMinInvertwith(final long wordToInvert, final long destinationWord) {
        final long sourceWord;

        sourceWord = ~wordToInvert;
        if (destDepth < 16) {
            /* Min each pixel separately */
            return partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW);
        }
        if (destDepth == 16) {
            /* Min RGB components of each pixel separately */
            return partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, 5, 3) +
                            (partitionedMinwithnBitsnPartitions(sourceWord >>> 16, destinationWord >>> 16, 5, 3) << 16);
        } else {
            /* Min RGBA components of the pixel separately */
            return partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, 8, 4);
        }
    }

    /* BitBltSimulation>>#rgbMin:with: */
    private long rgbMinwith(final long sourceWord, final long destinationWord) {
        if (destDepth < 16) {
            /* Min each pixel separately */
            return partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW);
        }
        if (destDepth == 16) {
            /* Min RGB components of each pixel separately */
            return partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, 5, 3) +
                            (partitionedMinwithnBitsnPartitions(sourceWord >>> 16, destinationWord >>> 16, 5, 3) << 16);
        } else {
            /* Min RGBA components of the pixel separately */
            return partitionedMinwithnBitsnPartitions(sourceWord, destinationWord, 8, 4);
        }
    }

    /* BitBltSimulation>>#rgbMul:with: */
    private long rgbMulwith(final long sourceWord, final long destinationWord) {
        if (destDepth < 16) {
            /* Mul each pixel separately */
            return partitionedMulwithnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW);
        }
        if (destDepth == 16) {
            /* Mul RGB components of each pixel separately */
            return partitionedMulwithnBitsnPartitions(sourceWord, destinationWord, 5, 3) +
                            (partitionedMulwithnBitsnPartitions(sourceWord >>> 16, destinationWord >>> 16, 5, 3) << 16);
        } else {
            /* Mul RGBA components of the pixel separately */
            return partitionedMulwithnBitsnPartitions(sourceWord, destinationWord, 8, 4);
        }
    }

    /* BitBltSimulation>>#rgbSub:with: */
    private long rgbSubwith(final long sourceWord, final long destinationWord) {
        if (destDepth < 16) {
            /* Sub each pixel separately */
            return partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, destDepth, destPPW);
        }
        if (destDepth == 16) {
            /* Sub RGB components of each pixel separately */
            return partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, 5, 3) +
                            (partitionedSubfromnBitsnPartitions(sourceWord >>> 16, destinationWord >>> 16, 5, 3) << 16);
        } else {
            /* Sub RGBA components of the pixel separately */
            return partitionedSubfromnBitsnPartitions(sourceWord, destinationWord, 8, 4);
        }
    }

    /* WARNING: For WarpBlt w/ smoothing the source depth is wrong here! */

    /* BitBltSimulation>>#setupColorMasks */
    private void setupColorMasks() {
        long bits;
        long targetBits;

        bits = targetBits = 0;
        if (sourceDepth <= 8) {
            return;
        }
        if (sourceDepth == 16) {
            bits = 5;
        }
        if (sourceDepth == 32) {
            bits = 8;
        }
        if (cmBitsPerColor == 0) {
            /* Convert to destDepth */
            if (destDepth <= 8) {
                return;
            }
            if (destDepth == 16) {
                targetBits = 5;
            }
            if (destDepth == 32) {
                targetBits = 8;
            }
        } else {
            targetBits = cmBitsPerColor;
        }
        setupColorMasksFromto(bits, targetBits);
    }

    /*
     * Setup color masks for converting an incoming RGB pixel value from srcBits to targetBits.
     */

    /* BitBltSimulation>>#setupColorMasksFrom:to: */
    private void setupColorMasksFromto(final long srcBits, final long targetBits) {
        final int deltaBits;
        final long mask;
        final int[] masks = cmMaskTableTemplate;
        final int[] shifts = cmShiftTableTemplate;

        deltaBits = (int) (targetBits - srcBits);
        if (deltaBits == 0) {
            return;
        }
        if (deltaBits <= 0) {
            /* Mask for extracting a color part of the source */
            mask = shl(1, targetBits) - 1;
            masks[RED_INDEX] = (int) shl(mask, srcBits * 2 - deltaBits);
            masks[GREEN_INDEX] = (int) shl(mask, srcBits - deltaBits);
            masks[BLUE_INDEX] = (int) shl(mask, 0 - deltaBits);
            // masks[ALPHA_INDEX] = 0; // Always zero anyway.
        } else {
            /* Mask for extracting a color part of the source */
            mask = shl(1, srcBits) - 1;
            masks[RED_INDEX] = (int) shl(mask, srcBits * 2);
            masks[GREEN_INDEX] = (int) shl(mask, srcBits);
            masks[BLUE_INDEX] = (int) mask;
        }
        shifts[RED_INDEX] = deltaBits * 3;
        shifts[GREEN_INDEX] = deltaBits * 2;
        shifts[BLUE_INDEX] = deltaBits;
        // shifts[ALPHA_INDEX] = 0; // Always zero anyway.
        cmShiftTable = shifts;
        cmMaskTable = masks;
        cmFlags = cmFlags | COLOR_MAP_PRESENT | COLOR_MAP_FIXED_PART;
    }

    /* BitBltSimulation>>#showDisplayBits */
    private void showDisplayBits() {
        if (destForm.image.hasDisplay()) {
            destForm.image.getDisplay().showDisplayBitsLeftTopRightBottom(destForm, affectedL, affectedT, affectedR, affectedB);
        }
    }

    /*
     * This is only used when source and dest are same depth, ie, when the barrel-shift copy loop is
     * used.
     */

    /* BitBltSimulation>>#sourceSkewAndPointerInit (modified, copied from SqueakJS) */
    private void sourceSkewAndPointerInit() {
        assert destPPW == sourcePPW && destMSB == sourceMSB && destDepth == sourceDepth;
        /* A mask, assuming power of two */
        final int pixPerM11 = destPPW - 1;
        final int sxLowBits = sx & pixPerM11;
        /* how many pixels in first word */
        final int dxLowBits = dx & pixPerM11;
        final int startBits1 = hDir > 0 ? sourcePPW - (sx & pixPerM11) : (sx + bbW - 1 & pixPerM11) + 1;
        final long m1 = destMSB ? ALL_ONES >> 32 - startBits1 * destDepth : ALL_ONES << 32 - startBits1 * destDepth;
        /* i.e. there are some missing bits */
        /* calculate right-shift skew from source to dest */
        preload = bbW > startBits1 && (m1 & mask1) != mask1;
        /* -32..32 */
        skew = destDepth * (sourceMSB ? sxLowBits - dxLowBits : dxLowBits - sxLowBits);
        if (preload) {
            skew = skew < 0 ? skew + 32 : skew - 32;
        }
        /* calculate increments from end of 1 line to start of next */
        sourceIndex = sy * sourcePitch + sx / (32 / sourceDepth) * 4;
        sourceDelta = sourcePitch * vDir - 4 * (nWords * hDir);
        if (preload) {
            /* Compensate for extra source word fetched */
            sourceDelta -= 4 * hDir;
        }
        assert !(preload && skew == 0);
        assert -32 <= skew && skew <= 32; // Modified (image uses 31 instead of 32).
    }

    /* BitBltSimulation>>#sourceWord:with: */
    private long sourceWordwith(final long sourceWord, @SuppressWarnings("unused") final long destinationWord) {
        return sourceWord;
    }

    /* BitBltSimulation>>#subWord:with: */
    private long subWordwith(final long sourceWord, final long destinationWord) {
        return sourceWord - destinationWord;
    }

    /*
     * Tally pixels into the color map. Those tallied are exactly those in the destination
     * rectangle. Note that the source should be specified == destination, in order for the proper
     * color map checks to be performed at setup.
     */

    /* BitBltSimulation>>#tallyIntoMap:with: */
    private long tallyIntoMapwith(@SuppressWarnings("unused") final long sourceWord, final long destinationWord) {
        long destShifted;
        long mapIndex;
        long maskShifted;
        final long pixMask;
        long pixVal;
        long value;

        if ((cmFlags & (COLOR_MAP_PRESENT | COLOR_MAP_INDEXED_PART)) != (COLOR_MAP_PRESENT | COLOR_MAP_INDEXED_PART)) {
            return destinationWord;
        }
        pixMask = MASK_TABLE[destDepth];
        destShifted = destinationWord;
        maskShifted = destMask;
        for (int i = 1; i <= destPPW; i++) {
            if ((maskShifted & pixMask) != 0) {
                /* Only tally pixels within the destination rectangle */
                pixVal = destShifted & pixMask;
                if (destDepth < 16) {
                    mapIndex = pixVal;
                } else {
                    if (destDepth == 16) {
                        mapIndex = rgbMapfromto(pixVal, 5, cmBitsPerColor);
                    } else {
                        mapIndex = rgbMapfromto(pixVal, 8, cmBitsPerColor);
                    }
                }
                /* begin tallyMapAt:put: */
                final int index = (int) (mapIndex & cmMask);
                value = cmLookupTable[index] + 1;
                cmLookupTable[index] = (int) value;
            }
            maskShifted = maskShifted >>> destDepth;
            destShifted = destShifted >>> destDepth;
        }
        return destinationWord;
    }

    /*
     * Shortcut for stuff that's being run from the balloon engine. Since we do this at each scan
     * line we should avoid the expensive setup for source and destination.
     */
    /* We need a source. */

    /* BitBltSimulation>>#tryCopyingBitsQuickly */
    private boolean tryCopyingBitsQuickly() {
        if (noSource) {
            return false;
        }
        if (!(combinationRule == 34 || combinationRule == 41)) {
            return false;
        }
        if (sourceDepth != 32) {
            return false;
        }
        if (sourceForm == destForm) {
            return false;
        }
        if (combinationRule == 41) {
            if (destDepth == 32) {
                rgbComponentAlpha32();
                affectedL = dx;
                affectedR = dx + bbW;
                affectedT = dy;
                affectedB = dy + bbH;
                return true;
            }
            if (destDepth == 16) {
                rgbComponentAlpha16();
                affectedL = dx;
                affectedR = dx + bbW;
                affectedT = dy;
                affectedB = dy + bbH;
                return true;
            }
            if (destDepth == 8) {
                rgbComponentAlpha8();
                affectedL = dx;
                affectedR = dx + bbW;
                affectedT = dy;
                affectedB = dy + bbH;
                return true;
            }
            return false;
        }
        if (destDepth < 8) {
            return false;
        }
        if (destDepth == 8 && (cmFlags & COLOR_MAP_PRESENT) == 0) {
            return false;
        }
        if (destDepth == 32) {
            alphaSourceBlendBits32();
        }
        if (destDepth == 16) {
            alphaSourceBlendBits16();
        }
        if (destDepth == 8) {
            alphaSourceBlendBits8();
        }
        affectedL = dx;
        affectedR = dx + bbW;
        affectedT = dy;
        affectedB = dy + bbH;
        return true;
    }

    /* BitBltSimulation>>#unlockSurfaces */
    private void unlockSurfaces() {
        if (!hasSurfaceLock) {
            return;
        }
        // Actual unlocking code not needed for GraalSqueak.
        hasSurfaceLock = false;
    }

    /* BitBltSimulation>>#warpBits */
    private void warpBits(final long smoothingCount, final AbstractSqueakObject sourceMap) {
        final boolean ns = noSource;
        noSource = true;
        clipRange();
        noSource = ns;
        if (noSource || bbW <= 0 || bbH <= 0) {
            /* zero width or height; noop */
            affectedL = affectedR = affectedT = affectedB = 0;
            return;
        }
        if (!lockSurfaces()) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        destMaskAndPointerInit();
        warpLoop(smoothingCount, sourceMap);
        if (hDir > 0) {
            affectedL = dx;
            affectedR = dx + bbW;
        } else {
            affectedL = dx - bbW + 1;
            affectedR = dx + 1;
        }
        if (vDir > 0) {
            affectedT = dy;
            affectedB = dy + bbH;
        } else {
            affectedT = dy - bbH + 1;
            affectedB = dy + 1;
        }
        unlockSurfaces();
    }

    /*
     * This version of the inner loop traverses an arbirary quadrilateral source, thus producing a
     * general affine transformation.
     */

    /* BitBltSimulation>>#warpLoop */
    private long warpLoop(final long smoothingCountValue, final AbstractSqueakObject sourceMapOopValue) {
        final int deltaP12x;
        final int deltaP12y;
        final int deltaP43x;
        final int deltaP43y;
        long destWord;
        final int dstShiftInc;
        final int dstShiftLeft;
        final int endBits;
        long halftoneWord;
        final long mapperFlags;
        long mergeWord;
        int nPix;
        int nSteps;
        int pAx;
        int pAy;
        int pBx;
        int pBy;
        long skewWord;
        final long smoothingCount;
        final Object sourceMap;
        final boolean sourceMapIsWords;
        int startBits;
        int words;
        int xDelta;
        int yDelta;

        halftoneWord = 0;
        final LongBinaryOperator mergeFnwith = opTable[combinationRule + 1];
        if (slotSizeOf(bitBltOop) < BB_WARP_BASE + 12) {
            PrimitiveFailed.andTransferToInterpreter();
        }
        nSteps = height - 1;
        if (nSteps <= 0) {
            nSteps = 1;
        }
        pAx = fetchIntOrFloatofObject(BB_WARP_BASE, bitBltOop);
        words = fetchIntOrFloatofObject(BB_WARP_BASE + 3, bitBltOop);
        deltaP12x = deltaFromtonSteps(pAx, words, nSteps);
        if (deltaP12x < 0) {
            pAx = words - nSteps * deltaP12x;
        }
        pAy = fetchIntOrFloatofObject(BB_WARP_BASE + 1, bitBltOop);
        words = fetchIntOrFloatofObject(BB_WARP_BASE + 4, bitBltOop);
        deltaP12y = deltaFromtonSteps(pAy, words, nSteps);
        if (deltaP12y < 0) {
            pAy = words - nSteps * deltaP12y;
        }
        pBx = fetchIntOrFloatofObject(BB_WARP_BASE + 9, bitBltOop);
        words = fetchIntOrFloatofObject(BB_WARP_BASE + 6, bitBltOop);
        deltaP43x = deltaFromtonSteps(pBx, words, nSteps);
        if (deltaP43x < 0) {
            pBx = words - nSteps * deltaP43x;
        }
        pBy = fetchIntOrFloatofObject(BB_WARP_BASE + 10, bitBltOop);
        words = fetchIntOrFloatofObject(BB_WARP_BASE + 7, bitBltOop);
        deltaP43y = deltaFromtonSteps(pBy, words, nSteps);
        if (deltaP43y < 0) {
            pBy = words - nSteps * deltaP43y;
        }
        if (failed()) {
            return 0;
        }
        if (sourceMapOopValue != null) {
            smoothingCount = smoothingCountValue;
            if (sourceMapOopValue == NilObject.SINGLETON) {
                if (sourceDepth < 16) {
                    /* color map is required to smooth non-RGB dest */
                    PrimitiveFailed.andTransferToInterpreter();
                }
                sourceMap = null;
                sourceMapIsWords = false;
            } else {
                final NativeObject sourceMapNative = (NativeObject) sourceMapOopValue;
                final int sourceMapSize;
                if (sourceMapNative.isIntType()) {
                    sourceMapIsWords = true;
                    final int[] ints = sourceMapNative.getIntStorage();
                    sourceMap = ints;
                    sourceMapSize = ints.length * Integer.BYTES;
                } else {
                    sourceMapIsWords = false;
                    final byte[] bytes = sourceMapNative.getByteStorage();
                    sourceMap = bytes;
                    sourceMapSize = bytes.length;
                }
                if (sourceMapSize < shl(1, sourceDepth)) {
                    /* sourceMap must be long enough for sourceDepth */
                    PrimitiveFailed.andTransferToInterpreter();
                }
            }
        } else {
            smoothingCount = 1;
            sourceMap = null;
            sourceMapIsWords = false;
        }
        nSteps = width - 1;
        if (nSteps <= 0) {
            nSteps = 1;
        }
        startBits = destPPW - (dx & destPPW - 1);
        endBits = (dx + bbW - 1 & destPPW - 1) + 1;
        if (bbW < startBits) {
            startBits = bbW;
        }
        if (destY < clipY) {
            /* Advance increments if there was clipping in y */
            pAx += (clipY - destY) * deltaP12x;
            pAy += (clipY - destY) * deltaP12y;
            pBx += (clipY - destY) * deltaP43x;
            pBy += (clipY - destY) * deltaP43y;
        }
        warpLoopSetup();
        if (smoothingCount > 1 && (cmFlags & COLOR_MAP_NEW_STYLE) == 0) {
            if (cmLookupTable == null) {
                if (destDepth == 16) {
                    setupColorMasksFromto(8, 5);
                }
            } else {
                setupColorMasksFromto(8, cmBitsPerColor);
            }
        }
        mapperFlags = cmFlags & ~COLOR_MAP_NEW_STYLE;
        if (destMSB) {
            dstShiftInc = 0 - destDepth;
            dstShiftLeft = 32 - destDepth;
        } else {
            dstShiftInc = destDepth;
            dstShiftLeft = 0;
        }
        if (noHalftone) {
            halftoneWord = ALL_ONES;
        }
        for (int i = 1; i <= bbH; i++) {
            /* here is the vertical loop... */
            xDelta = deltaFromtonSteps(pAx, pBx, nSteps);
            if (xDelta >= 0) {
                sx = pAx;
            } else {
                sx = pBx - nSteps * xDelta;
            }
            yDelta = deltaFromtonSteps(pAy, pBy, nSteps);
            if (yDelta >= 0) {
                sy = pAy;
            } else {
                sy = pBy - nSteps * yDelta;
            }
            if (destMSB) {
                dstBitShift = 32 - ((dx & destPPW - 1) + 1) * destDepth;
            } else {
                dstBitShift = (dx & destPPW - 1) * destDepth;
            }
            if (destX < clipX) {
                /* Advance increments if there was clipping in x */
                sx += (clipX - destX) * xDelta;
                sy += (clipX - destX) * yDelta;
            }
            if (!noHalftone) {
                halftoneWord = halftoneLongAt(dy + i - 1);
            }
            destMask = mask1;
            /* Here is the inner loop... */
            nPix = startBits;
            words = nWords;
            do {
                if (smoothingCount == 1) {
                    /* Faster if not smoothing */
                    skewWord = warpPickSourcePixelsxDeltahyDeltahxDeltavyDeltavdstShiftIncflags(nPix, xDelta, yDelta, dstShiftInc, mapperFlags);
                } else {
                    /* more difficult with smoothing */
                    skewWord = warpPickSmoothPixelsxDeltahyDeltahxDeltavyDeltavsourceMapsmoothingdstShiftInc(nPix, xDelta, yDelta, deltaP12x, deltaP12y, sourceMap, sourceMapIsWords, smoothingCount,
                                    dstShiftInc);
                }
                dstBitShift = dstShiftLeft;
                if (destMask == ALL_ONES) {
                    /* avoid read-modify-write */
                    mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, dstLongAt(destIndex));
                    /* begin dstLongAt:put: */
                    dstLongAtput(destIndex, destMask & mergeWord);
                } else {
                    /* General version using dest masking */
                    /* begin dstLongAt: */
                    destWord = dstLongAt(destIndex);
                    mergeWord = mergeFnwith.applyAsLong(skewWord & halftoneWord, destWord & destMask);
                    destWord = destMask & mergeWord | destWord & ~destMask;
                    /* begin dstLongAt:put: */
                    dstLongAtput(destIndex, destWord);
                }
                /* begin incDestIndex: */
                destIndex += 4;
                if (words == 2) {
                    /* e.g., is the next word the last word? */
                    /* set mask for last word in this row */
                    destMask = mask2;
                    nPix = endBits;
                } else {
                    /* use fullword mask for inner loop */
                    destMask = ALL_ONES;
                    nPix = destPPW;
                }
            } while (--words > 0);
            pAx += deltaP12x;
            pAy += deltaP12y;
            pBx += deltaP43x;
            pBy += deltaP43y;
            /* begin incDestIndex: */
            destIndex += destDelta;
        }
        return 0;
    }

    /* Setup values for faster pixel fetching. */

    /* BitBltSimulation>>#warpLoopSetup */
    private void warpLoopSetup() {
        long words;

        /* warpSrcShift = log2(sourceDepth) */
        warpSrcShift = 0;
        /* recycle temp */
        words = sourceDepth;
        while (words != 1) {
            warpSrcShift++;
            words = words >>> 1;
        }
        /* warpAlignShift: Shift for aligning x position to word boundary */
        warpSrcMask = MASK_TABLE[sourceDepth];
        /* warpAlignMask: Mask for extracting the pixel position from an x position */
        warpAlignShift = 5 - warpSrcShift;
        /* Setup the lookup table for source bit shifts */
        /* warpBitShiftTable: given an sub-word x value what's the bit shift? */
        warpAlignMask = shl(1, warpAlignShift) - 1;
        for (int i = 0; i <= warpAlignMask; i++) {
            if (sourceMSB) {
                warpBitShiftTable[i] = (int) (32 - shl(i + 1, warpSrcShift));
            } else {
                warpBitShiftTable[i] = (int) shl(i, warpSrcShift);
            }
        }
    }

    /*
     * Pick n (sub-) pixels from the source form, mapped by sourceMap, average the RGB values, map
     * by colorMap and return the new word. This version is only called from WarpBlt with
     * smoothingCount > 1
     */

    /*
     * BitBltSimulation>>#warpPickSmoothPixels:xDeltah:yDeltah:xDeltav:yDeltav:sourceMap:smoothing:
     * dstShiftInc:
     */
    private long warpPickSmoothPixelsxDeltahyDeltahxDeltavyDeltavsourceMapsmoothingdstShiftInc(final int nPixels, final long xDeltah, final long yDeltah, final long xDeltav,
                    final long yDeltav, final Object sourceMap, final boolean sourceMapIsWords, final long n, final long dstShiftInc) {
        long a;
        long b;
        long destWord;
        final int dstMask;
        long g;
        long j;
        long k;
        long nPix;
        long r;
        long rgb;
        int x;
        final long xdh;
        final long xdv;
        int xx;
        int y;
        final long ydh;
        final long ydv;
        int yy;

        /* nope - too much stuff in here */
        dstMask = MASK_TABLE[destDepth];
        destWord = 0;
        if (n == 2) {
            /* Try avoiding divides for most common n (divide by 2 is generated as shift) */
            xdh = xDeltah / 2;
            ydh = yDeltah / 2;
            xdv = xDeltav / 2;
            ydv = yDeltav / 2;
        } else {
            xdh = div(xDeltah, n);
            ydh = div(yDeltah, n);
            xdv = div(xDeltav, n);
            ydv = div(yDeltav, n);
        }
        int i = nPixels;
        do {
            x = sx;
            y = sy;
            /* Pick and average n*n subpixels */
            a = r = g = b = 0;
            /* actual number of pixels (not clipped and not transparent) */
            nPix = 0;
            j = n;
            do {
                xx = x;
                yy = y;
                k = n;
                do {
                    rgb = pickWarpPixelAtXy(xx, yy);
                    if (!(combinationRule == 25 && rgb == 0)) {
                        /* If not clipped and not transparent, then tally rgb values */
                        nPix++;
                        if (sourceDepth < 16) {
                            /* Get RGBA values from sourcemap table */
                            final int rawValue;
                            if (sourceMapIsWords) {
                                rawValue = UnsafeUtils.getInt((int[]) sourceMap, rgb);
                            } else {
                                rawValue = UnsafeUtils.getInt((byte[]) sourceMap, rgb);
                            }
                            rgb = Integer.toUnsignedLong(rawValue);
                        } else {
                            /* Already in RGB format */
                            if (sourceDepth == 16) {
                                rgb = rgbMap16To32(rgb);
                            } else {
                                rgb = rgbMap32To32(rgb);
                            }
                        }
                        b += rgb & 0xFF;
                        g += rgb >>> 8 & 0xFF;
                        r += rgb >>> 16 & 0xFF;
                        a += rgb >>> 24;
                    }
                    xx += xdh;
                    yy += ydh;
                } while (--k > 0);
                x += xdv;
                y += ydv;
            } while (--j > 0);
            if (nPix == 0 || combinationRule == 25 && nPix < n * n / 2) {
                /* All pixels were 0, or most were transparent */
                rgb = 0;
            } else {
                /* normalize rgba sums */
                if (nPix == 4) {
                    /* Try to avoid divides for most common n */
                    r = r >>> 2;
                    g = g >>> 2;
                    b = b >>> 2;
                    a = a >>> 2;
                } else {
                    r = div(r, nPix);
                    g = div(g, nPix);
                    b = div(b, nPix);
                    a = div(a, nPix);
                }
                /* map the pixel */
                rgb = (a << 24) + (r << 16) + (g << 8) + b;
                if (rgb == 0 && r + g + b + a > 0) {
                    /* only generate zero if pixel is really transparent */
                    rgb = 1;
                }
                rgb = mapPixelflags(rgb, cmFlags);
            }
            destWord = destWord | shl(rgb & dstMask, dstBitShift);
            dstBitShift += dstShiftInc;
            sx += xDeltah;
            sy += yDeltah;
        } while (--i > 0);
        return destWord;
    }

    /*
     * Pick n pixels from the source form, map by colorMap and return aligned by dstBitShift. This
     * version is only called from WarpBlt with smoothingCount = 1
     */

    /* BitBltSimulation>>#warpPickSourcePixels:xDeltah:yDeltah:xDeltav:yDeltav:dstShiftInc:flags: */
    private long warpPickSourcePixelsxDeltahyDeltahxDeltavyDeltavdstShiftIncflags(final long nPixels, final long xDeltah, final long yDeltah, final long dstShiftInc, final long mapperFlags) {
        long destPix;
        long destWord;
        final int dstMask;
        long nPix;
        long sourcePix;

        dstMask = MASK_TABLE[destDepth];
        destWord = 0;
        nPix = nPixels;
        if (mapperFlags == (COLOR_MAP_PRESENT | COLOR_MAP_INDEXED_PART)) {
            /* a little optimization for (pretty crucial) blits using indexed lookups only */
            /* grab, colormap and mix in pixel */
            do {
                sourcePix = pickWarpPixelAtXy(sx, sy);
                destPix = cmLookupTable[(int) (sourcePix & cmMask)];
                destWord = destWord | shl(destPix & dstMask, dstBitShift);
                dstBitShift += dstShiftInc;
                sx += xDeltah;
                sy += yDeltah;
            } while (--nPix > 0);
        } else {
            /* grab, colormap and mix in pixel */
            do {
                sourcePix = pickWarpPixelAtXy(sx, sy);
                destPix = mapPixelflags(sourcePix, mapperFlags);
                destWord = destWord | shl(destPix & dstMask, dstBitShift);
                dstBitShift += dstShiftInc;
                sx += xDeltah;
                sy += yDeltah;
            } while (--nPix > 0);
        }
        return destWord;
    }

    /*
     * POLYFILLS
     */

    private int fetchIntegerofObject(final int index, final VariablePointersObject object) {
        final Object value = fetchPointerofObject(index, object);
        if (value instanceof Long) {
            return (int) (long) value;
        } else {
            successFlag = false;
            return 0;
        }
    }

    private int fetchIntegerofObject(final int index, final PointersObject object) {
        final Object value = fetchPointerofObject(index, object);
        if (value instanceof Long) {
            return (int) (long) value;
        } else {
            successFlag = false;
            return 0;
        }
    }

    private static PointersObject fetchPointerofObjectOrNull(final int index, final PointersObject object) {
        final Object value = fetchPointerofObject(index, object);
        if (value == NilObject.SINGLETON) {
            return null;
        } else {
            return (PointersObject) value;
        }
    }

    private static NativeObject fetchNativeofObjectOrNull(final int index, final VariablePointersObject object) {
        final Object value = fetchPointerofObject(index, object);
        if (value == NilObject.SINGLETON) {
            return null;
        } else {
            return (NativeObject) value;
        }
    }

    private static NativeObject fetchNativeofObjectOrNull(final int index, final PointersObject object) {
        final Object value = fetchPointerofObject(index, object);
        if (value == NilObject.SINGLETON) {
            return null;
        } else {
            return (NativeObject) value;
        }
    }

    private static Object fetchPointerofObject(final int index, final VariablePointersObject object) {
        return object.instVarAt0Slow(index);
    }

    private static Object fetchPointerofObject(final int index, final PointersObject object) {
        return object.instVarAt0Slow(index);
    }

    private static boolean isBytes(final NativeObject object) {
        return object.isByteType();
    }

    private static boolean isWords(final NativeObject object) {
        return object.isIntType();
    }

    private boolean isWords(final Object object) {
        return SqueakGuards.isNativeObject(object) && isWords((NativeObject) object);
    }

    private boolean isWordsOrBytes(final Object object) {
        return SqueakGuards.isNativeObject(object) && (isWords((NativeObject) object) || isBytes((NativeObject) object));
    }

    private static int slotSizeOfWords(final NativeObject object) {
        return object.getIntLength();
    }

    private static int slotSizeOf(final VariablePointersObject object) {
        return object.size();
    }

    private static int slotSizeOf(final PointersObject object) {
        return object.size();
    }

    private static boolean isPointers(final Object object) {
        return object != null && object instanceof PointersObject;
    }

    private boolean failed() {
        return !successFlag;
    }

    protected void resetSuccessFlag() {
        successFlag = true;
    }

    private static int div(final long a, final long b) {
        return (int) Math.floor(a / b);
    }

    private static int mod(final long a, final long b) {
        return (int) (a - div(a, b) * b);
    }

    private static long shl(final long a, final long b) {
        return b > 31 ? 0 : a << b;
    }

    private static long shr(final long a, final long b) {
        return b > 31 ? 0 : a >>> b;
    }

    private static long shift(final long a, final long b) {
        return b < 0 ? b < -31 ? 0 : a >>> 0 - b : b > 31 ? 0 : a << b;
    }

    private static void storeIntegerofObjectwithValue(final int index, final PointersObject target, final long value) {
        target.instVarAtPut0Slow(index, value);
    }

    private long dstLongAt(final long index) {
        final int i = (int) index >>> 2;
        assert i < endOfDestination;
        if (destBits != null) {
            return Integer.toUnsignedLong(destBits[i]);
        } else {
            if (destMSB) {
                return Integer.toUnsignedLong(UnsafeUtils.getInt(destBytes, i));
            } else {
                return Integer.toUnsignedLong(UnsafeUtils.getIntReversed(destBytes, i));
            }
        }
    }

    /*
     * Store the given value back into destination form, using dstMask to mask out the bits to be
     * modified. This is an essential read-modify-write operation on the destination form.
     */
    private void destLongAtputmask(final long dstIndex, final long dstMask, final long sourceWord) {
        long dstValue = dstLongAt(dstIndex);
        dstValue = dstValue & dstMask;
        dstValue = dstValue | sourceWord;
        dstLongAtput(dstIndex, dstValue);
    }

    private void dstLongAtput(final long index, final long value) {
        final int i = (int) index >>> 2;
        if (destBits != null) {
            destBits[i] = (int) value;
        } else {
            UnsafeUtils.putInt(destBytes, i, (int) value);
        }
    }

    private long halftoneLongAt(final long index) {
        return Integer.toUnsignedLong(halftoneBits[mod(index, halftoneHeight)]);
    }

    private long srcLongAt(final long index) {
        /**
         * Unfortunately, BitBlt tries to read past the end or before the start of
         * {@link sourceBits} sometimes, so return `0` in these cases. An example is
         * #testPivelValueAt (confirmed by SqueakJS's BitBltPlugin) or `PolygonMorph
         * arrowPrototype`.
         */
        if (0 <= index && index < endOfSource) {
            final long adjustedIndex = index >>> 2;
            final int rawValue;
            if (sourceBitsIsWords) {
                rawValue = UnsafeUtils.getInt((int[]) sourceBits, adjustedIndex);
            } else {
                rawValue = UnsafeUtils.getInt((byte[]) sourceBits, adjustedIndex);
            }
            return Integer.toUnsignedLong(rawValue);
        } else {
            return 0L;
        }
    }
}
