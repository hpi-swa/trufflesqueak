/*
 * Copyright (c) 2017-2025 Software Architecture Group, Hasso Plattner Institute
 * Copyright (c) 2021-2025 Oracle and/or its affiliates
 *
 * Licensed under the MIT License.
 */
package de.hpi.swa.trufflesqueak.nodes.plugins;

import com.oracle.truffle.api.CompilerDirectives.CompilationFinal;
import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;
import com.oracle.truffle.api.nodes.Node;

import de.hpi.swa.trufflesqueak.exceptions.PrimitiveFailed;
import de.hpi.swa.trufflesqueak.exceptions.SqueakExceptions.SqueakException;
import de.hpi.swa.trufflesqueak.image.SqueakImageContext;
import de.hpi.swa.trufflesqueak.model.AbstractSqueakObject;
import de.hpi.swa.trufflesqueak.model.AbstractSqueakObjectWithClassAndHash;
import de.hpi.swa.trufflesqueak.model.ArrayObject;
import de.hpi.swa.trufflesqueak.model.BooleanObject;
import de.hpi.swa.trufflesqueak.model.ClassObject;
import de.hpi.swa.trufflesqueak.model.FloatObject;
import de.hpi.swa.trufflesqueak.model.NativeObject;
import de.hpi.swa.trufflesqueak.model.NilObject;
import de.hpi.swa.trufflesqueak.model.PointersObject;
import de.hpi.swa.trufflesqueak.model.layout.ObjectLayouts.ERROR_TABLE;
import de.hpi.swa.trufflesqueak.nodes.SqueakGuards;
import de.hpi.swa.trufflesqueak.nodes.accessing.AbstractPointersObjectNodes.AbstractPointersObjectWriteNode;
import de.hpi.swa.trufflesqueak.util.UnsafeUtils;

/* Automatically generated by
    VMPluginCodeGenerator * VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1
   from
    BalloonEnginePlugin * VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1
 */

public final class B2D {

    private final SqueakImageContext image;

    /* Constants */
    private static final int BE_BALLOON_ENGINE_SIZE = 12;
    private static final int BE_BITBLT_INDEX = 2;
    private static final int BE_FORMS_INDEX = 3;
    private static final int BE_SPAN_INDEX = 1;
    private static final int BE_WORKBUFFER_INDEX = 0;
    private static final int ET_BALLOON_EDGE_DATA_SIZE = 6;
    private static final int ET_INDEX_INDEX = 0;
    private static final int ET_LINES_INDEX = 4;
    private static final int ET_X_VALUE_INDEX = 1;
    private static final int ET_Y_VALUE_INDEX = 2;
    private static final int ET_Z_VALUE_INDEX = 3;
    private static final int FT_BALLOON_FILL_DATA_SIZE = 6;
    private static final int FT_INDEX_INDEX = 0;
    private static final int FT_MAX_X_INDEX = 2;
    private static final int FT_MIN_X_INDEX = 1;
    private static final int FT_Y_VALUE_INDEX = 3;
    private static final int GB_BASE_SIZE = 16;
    private static final int GB_BITMAP_DEPTH = 12;
    private static final int GB_BITMAP_HEIGHT = 11;
    private static final int GB_BITMAP_RASTER = 14;
    private static final int GB_BITMAP_SIZE = 13;
    private static final int GB_BITMAP_WIDTH = 10;
    private static final int GB_COLORMAP_OFFSET = 18;
    private static final int GB_COLORMAP_SIZE = 15;
    private static final int GB_END_X = 14;
    private static final int GB_END_Y = 15;
    private static final int GB_FINAL_X = 21;
    private static final int GB_M_BASE_SIZE = 18;
    private static final int GB_TILE_FLAG = 16;
    private static final int GB_UPDATE_DATA = 10;
    private static final int GB_UPDATE_DDX = 4;
    private static final int GB_UPDATE_DDY = 5;
    private static final int GB_UPDATE_DX = 2;
    private static final int GB_UPDATE_DY = 3;
    private static final int GB_UPDATE_X = 0;
    private static final int GB_UPDATE_Y = 1;
    private static final int GB_VIA_X = 12;
    private static final int GB_VIA_Y = 13;
    private static final int GB_WIDE_ENTRY = 18;
    private static final int GB_WIDE_EXIT = 19;
    private static final int GB_WIDE_EXTENT = 20;
    private static final int GB_WIDE_FILL = 16;
    private static final int GB_WIDE_SIZE = 28;
    private static final int GB_WIDE_UPDATE_DATA = 22;
    private static final int GB_WIDE_WIDTH = 17;
    private static final int GE_BASE_EDGE_SIZE = 10;
    private static final int GE_BASE_FILL_SIZE = 4;
    private static final int GE_EDGE_FILLS_INVALID = 0x10000;
    private static final int GEF_ALREADY_FAILED = 100;
    private static final int GEF_BAD_POINT = 121;
    private static final int GEF_BITBLT_LOAD_FAILED = 122;
    private static final int GEF_CLASS_MISMATCH = 114;
    private static final int GEF_EDGE_DATA_TOO_SMALL = 112;
    // private static final int GEF_ENGINE_IS_INTEGER = 101;
    // private static final int GEF_ENGINE_IS_WORDS = 102;
    private static final int GEF_ENGINE_STOPPED = 104;
    private static final int GEF_ENGINE_TOO_SMALL = 103;
    private static final int GEF_ENTITY_CHECK_FAILED = 120;
    private static final int GEF_ENTITY_LOAD_FAILED = 119;
    private static final int GEF_FILL_DATA_TOO_SMALL = 113;
    private static final int GEF_FORM_LOAD_FAILED = 123;
    private static final int GE_FILL_INDEX_LEFT = 8;
    private static final int GE_FILL_INDEX_RIGHT = 9;
    private static final int GEF_SIZE_MISMATCH = 115;
    private static final int GEF_WORKBUFFER_BADMAGIC = 108;
    // private static final int GEF_WORKBUFFER_IS_INTEGER = 105;
    private static final int GEF_WORKBUFFER_IS_POINTERS = 106;
    private static final int GEF_WORKBUFFER_START_WRONG = 110;
    private static final int GEF_WORKBUFFER_TOO_SMALL = 107;
    private static final int GEF_WORKBUFFER_WRONG_SIZE = 109;
    private static final int GEF_WORK_TOO_BIG = 111;
    private static final int GEF_WRONG_EDGE = 118;
    private static final int GEF_WRONG_FILL = 117;
    private static final int GEF_WRONG_STATE = 116;
    private static final int GE_NUM_LINES = 7;
    private static final int GE_OBJECT_INDEX = 2;
    private static final int GE_OBJECT_LENGTH = 1;
    private static final int GE_OBJECT_TYPE = 0;
    private static final int GE_PRIMITIVE_BEZIER = 6;
    private static final int GE_PRIMITIVE_CLIPPED_BITMAP_FILL = 0x400;
    private static final int GE_PRIMITIVE_EDGE = 2;
    private static final int GE_PRIMITIVE_EDGE_MASK = 0xFF;
    private static final int GE_PRIMITIVE_FILL = 0x100;
    private static final int GE_PRIMITIVE_FILL_MASK = 0xFF00;
    private static final int GE_PRIMITIVE_LINE = 4;
    private static final int GE_PRIMITIVE_LINEAR_GRADIENT_FILL = 0x200;
    private static final int GE_PRIMITIVE_RADIAL_GRADIENT_FILL = 0x300;
    private static final int GE_PRIMITIVE_TYPE_MASK = 0xFFFF;
    private static final int GE_PRIMITIVE_WIDE = 1;
    private static final int GE_PRIMITIVE_WIDE_BEZIER = 7;
    private static final int GE_PRIMITIVE_WIDE_LINE = 5;
    private static final int GE_PRIMITIVE_WIDE_MASK = 0xFE;
    private static final int G_ERROR_AET_ENTRY = 6;
    private static final int G_ERROR_BAD_STATE = 2;
    private static final int G_ERROR_FILL_ENTRY = 5;
    private static final int G_ERROR_GET_ENTRY = 4;
    private static final int G_ERROR_NEED_FLUSH = 3;
    private static final int G_ERROR_NO_MORE_SPACE = 1;
    private static final int GE_STATE_ADDING_FROM_GET = 1;
    private static final int GE_STATE_BLIT_BUFFER = 5;
    private static final int GE_STATE_COMPLETED = 8;
    private static final int GE_STATE_SCANNING_AET = 3;
    private static final int GE_STATE_UNLOCKED = 0;
    private static final int GE_STATE_UPDATE_EDGES = 6;
    private static final int GE_STATE_WAITING_CHANGE = 7;
    private static final int GE_STATE_WAITING_FOR_EDGE = 2;
    private static final int GE_STATE_WAITING_FOR_FILL = 4;
    private static final int GE_X_VALUE = 4;
    private static final int GE_Y_VALUE = 5;
    private static final int GE_Z_VALUE = 6;
    private static final int GF_DIRECTION_X = 6;
    private static final int GF_DIRECTION_Y = 7;
    private static final int GF_NORMAL_X = 8;
    private static final int GF_NORMAL_Y = 9;
    private static final int GF_ORIGIN_X = 4;
    private static final int GF_ORIGIN_Y = 5;
    private static final int GF_RAMP_LENGTH = 10;
    private static final int GF_RAMP_OFFSET = 12;
    private static final int GG_BASE_SIZE = 12;
    private static final int GL_BASE_SIZE = 16;
    private static final int GL_END_X = 14;
    private static final int GL_END_Y = 15;
    private static final int GL_ERROR = 13;
    private static final int GL_ERROR_ADJ_DOWN = 15;
    private static final int GL_ERROR_ADJ_UP = 14;
    private static final int GL_WIDE_ENTRY = 18;
    private static final int GL_WIDE_EXIT = 19;
    private static final int GL_WIDE_EXTENT = 20;
    private static final int GL_WIDE_FILL = 16;
    private static final int GL_WIDE_SIZE = 21;
    private static final int GL_WIDE_WIDTH = 17;
    private static final int GL_X_DIRECTION = 10;
    private static final int GL_X_INCREMENT = 12;
    private static final int GL_Y_DIRECTION = 11;
    private static final int GW_AA_COLOR_MASK = 0x33;
    private static final int GW_AA_COLOR_SHIFT = 50;
    private static final int GW_AA_HALF_PIXEL = 53;
    private static final int GW_AA_LEVEL = 48;
    private static final int GW_AA_SCAN_MASK = 0x34;
    private static final int GW_AA_SHIFT = 49;
    private static final int GW_AET_START = 13;
    private static final int GW_AET_USED = 14;
    private static final int GW_BEZIER_HEIGHT_SUBDIVISIONS = 109;
    private static final int GW_BEZIER_LINE_CONVERSIONS = 111;
    private static final int GW_BEZIER_MONOTON_SUBDIVISIONS = 108;
    private static final int GW_BEZIER_OVERFLOW_SUBDIVISIONS = 110;
    private static final int GW_BUFFER_TOP = 10;
    private static final int GW_CLEAR_SPAN_BUFFER = 69;
    private static final int GW_CLIP_MAX_X = 43;
    private static final int GW_CLIP_MAX_Y = 45;
    private static final int GW_CLIP_MIN_X = 42;
    private static final int GW_CLIP_MIN_Y = 44;
    private static final int GW_COLOR_TRANSFORM = 24;
    private static final int GW_COUNT_ADD_AET_ENTRY = 97;
    private static final int GW_COUNT_CHANGE_AET_ENTRY = 107;
    private static final int GW_COUNT_DISPLAY_SPAN = 103;
    private static final int GW_COUNT_FINISH_TEST = 93;
    private static final int GW_COUNT_INITIALIZING = 91;
    private static final int GW_COUNT_MERGE_FILL = 101;
    private static final int GW_COUNT_NEXT_AET_ENTRY = 105;
    private static final int GW_COUNT_NEXT_FILL_ENTRY = 99;
    private static final int GW_COUNT_NEXT_GET_ENTRY = 95;
    private static final int GW_CURRENT_Y = 88;
    private static final int GW_CURRENT_Z = 113;
    private static final int GW_DEST_OFFSET_X = 46;
    private static final int GW_DEST_OFFSET_Y = 47;
    private static final int GW_EDGE_TRANSFORM = 18;
    private static final int GW_FILL_MAX_X = 37;
    private static final int GW_FILL_MAX_Y = 39;
    private static final int GW_FILL_MIN_X = 36;
    private static final int GW_FILL_MIN_Y = 38;
    private static final int GW_FILL_OFFSET_X = 40;
    private static final int GW_FILL_OFFSET_Y = 41;
    private static final int GW_GET_START = 11;
    private static final int GW_GET_USED = 12;
    private static final int GW_HAS_COLOR_TRANSFORM = 17;
    private static final int GW_HAS_EDGE_TRANSFORM = 16;
    private static final int GW_HEADER_SIZE = 128;
    private static final int GW_LAST_EXPORTED_EDGE = 65;
    private static final int GW_LAST_EXPORTED_FILL = 66;
    private static final int GW_LAST_EXPORTED_LEFT_X = 67;
    private static final int GW_LAST_EXPORTED_RIGHT_X = 68;
    private static final int GW_MAGIC_INDEX = 0;
    private static final int GW_MAGIC_NUMBER = 1097753705;
    protected static final int GW_MINIMAL_SIZE = 256;
    private static final int GW_NEEDS_FLUSH = 63;
    private static final int GW_OBJ_START = 8;
    private static final int GW_OBJ_USED = 9;
    private static final int GW_POINT_1 = 80;
    private static final int GW_POINT_2 = 82;
    private static final int GW_POINT_3 = 84;
    private static final int GW_POINT_4 = 86;
    private static final int GW_POINT_LIST_FIRST = 70;
    private static final int GW_SIZE = 1;
    private static final int GW_SPAN_END = 34;
    private static final int GW_SPAN_END_AA = 35;
    private static final int GW_SPAN_SIZE = 33;
    private static final int GW_SPAN_START = 32;
    private static final int GW_STATE = 2;
    private static final int GW_STOP_REASON = 64;
    private static final int GW_TIME_ADD_AET_ENTRY = 96;
    private static final int GW_TIME_CHANGE_AET_ENTRY = 106;
    private static final int GW_TIME_DISPLAY_SPAN = 102;
    private static final int GW_TIME_FINISH_TEST = 92;
    private static final int GW_TIME_INITIALIZING = 90;
    private static final int GW_TIME_MERGE_FILL = 100;
    private static final int GW_TIME_NEXT_AET_ENTRY = 104;
    private static final int GW_TIME_NEXT_FILL_ENTRY = 98;
    private static final int GW_TIME_NEXT_GET_ENTRY = 94;

    /* BalloonEnginePlugin>>#circleCosTable */
    @CompilationFinal(dimensions = 1) private static final double[] CIRCLE_COS_TABLE = {1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,
                    0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,
                    0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,
                    -0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,
                    -1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,
                    -0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,
                    0.0, 0.1950903220161282, 0.38268343236509, 0.555570233019602,
                    0.707106781186547, 0.831469612302545, 0.9238795325112865, 0.98078528040323,
                    1.0};

    /* BalloonEnginePlugin>>#circleSinTable */
    @CompilationFinal(dimensions = 1) private static final double[] CIRCLE_SIN_TABLE = {0.0, 0.1950903220161282, 0.3826834323650897, 0.555570233019602,
                    0.707106781186547, 0.831469612302545, 0.923879532511287, 0.98078528040323,
                    1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,
                    0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,
                    0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,
                    -0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,
                    -1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,
                    -0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,
                    0.0};

    /* BalloonEngineBase>>#smallSqrtTable */
    @CompilationFinal(dimensions = 1) private static final int[] SMALL_SQRT_TABLE = {0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6};

    /* BalloonEnginePlugin>>#rShiftTable */
    @CompilationFinal(dimensions = 1) private static final int[] R_SHIFT_TABLE = {0, 5, 4, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1};

    /* Variables */
    private int aetBufferIndex;
    private boolean doProfileStats;
    private PointersObject engine;
    private boolean engineStopped;
    private ArrayObject formArray;
    private long geProfileTime;
    private int getBufferIndex;

    private static final String MODULE_NAME = "B2DPlugin * VMMaker.oscog-eem.2480 (TruffleSqueak)";
    private int objBufferIndex;
    private int objUsed;
    private int[] spanBuffer;
    private int[] workBuffer;

    public B2D(final SqueakImageContext image) {
        this.image = image;
    }

    /* BalloonEngineBase>>#aaColorMaskGet */
    private int aaColorMaskGet() {
        return workBuffer[GW_AA_COLOR_MASK];
    }

    /* BalloonEngineBase>>#aaColorMaskPut: */
    private void aaColorMaskPut(final int value) {
        workBuffer[GW_AA_COLOR_MASK] = value;
    }

    /* BalloonEngineBase>>#aaColorShiftGet */
    private int aaColorShiftGet() {
        return workBuffer[GW_AA_COLOR_SHIFT];
    }

    /* BalloonEngineBase>>#aaColorShiftPut: */
    private void aaColorShiftPut(final int value) {
        workBuffer[GW_AA_COLOR_SHIFT] = value;
    }

    /* Common function to compute the first full pixel for AA drawing */

    /* BalloonEngineBase>>#aaFirstPixelFrom:to: */
    private int aaFirstPixelFromto(final int leftX, final int rightX) {
        final int firstPixel = leftX + aaLevelGet() - 1 & -aaLevelGet();
        return Math.min(firstPixel, rightX);
    }

    /* BalloonEngineBase>>#aaHalfPixelGet */
    @SuppressWarnings("unused")
    private int aaHalfPixelGet() {
        return workBuffer[GW_AA_HALF_PIXEL];
    }

    /* BalloonEngineBase>>#aaHalfPixelPut: */
    private void aaHalfPixelPut(final int value) {
        workBuffer[GW_AA_HALF_PIXEL] = value;
    }

    /* Common function to compute the last full pixel for AA drawing */

    /* BalloonEngineBase>>#aaLastPixelFrom:to: */
    private int aaLastPixelFromto(@SuppressWarnings("unused") final int leftX, final int rightX) {
        return rightX - 1 & -aaLevelGet();
    }

    /* BalloonEngineBase>>#aaLevelGet */
    private int aaLevelGet() {
        return workBuffer[GW_AA_LEVEL];
    }

    /* BalloonEngineBase>>#aaLevelPut: */
    private void aaLevelPut(final int value) {
        workBuffer[GW_AA_LEVEL] = value;
    }

    /* BalloonEngineBase>>#aaScanMaskGet */
    private int aaScanMaskGet() {
        return workBuffer[GW_AA_SCAN_MASK];
    }

    /* BalloonEngineBase>>#aaScanMaskPut: */
    private void aaScanMaskPut(final int value) {
        workBuffer[GW_AA_SCAN_MASK] = value;
    }

    /* BalloonEngineBase>>#aaShiftGet */
    private int aaShiftGet() {
        return workBuffer[GW_AA_SHIFT];
    }

    /* BalloonEngineBase>>#aaShiftPut: */
    private void aaShiftPut(final int value) {
        workBuffer[GW_AA_SHIFT] = value;
    }

    /*
     * Compute the squared value of a 8.24 number with 0.0 <= value < 1.0, e.g., compute (value *
     * value) bitShift: -24
     */

    /* BalloonEnginePlugin>>#absoluteSquared8Dot24: */
    private static int absoluteSquared8Dot24(final int value) {
        final int word1 = value & 0xFFFF;
        final int word2 = value >>> 16 & 0xFF;
        return (word1 * word1 >>> 16) + word1 * word2 * 2 + (word2 * word2 << 16) >>> 8;
    }

    /* Return the accurate length of the vector described by deltaX and deltaY */

    /* BalloonEngineBase>>#accurateLengthOf:with: */
    private static int accurateLengthOfwith(final int deltaX, final int deltaY) {
        if (deltaX == 0) {
            return Math.abs(deltaY);
        }
        if (deltaY == 0) {
            return Math.abs(deltaX);
        }
        final int length = deltaX * deltaX + deltaY * deltaY;
        return computeSqrt(length);
    }

    /* BalloonEngineBase>>#addEdgeToGET: */
    private void addEdgeToGET(final int edge) {
        if (!allocateGETEntry(1)) {
            return;
        }
        getBuffer(getUsedGet(), edge);
        getUsedPut(getUsedGet() + 1);
    }

    /*
     * Adjust the wide bezier curve (dx < 0) to start/end at the right point[] /
     *
     * /* BalloonEnginePlugin>>#adjustWideBezierLeft:width:offset:endX:
     */
    private void adjustWideBezierLeftwidthoffsetendX(final int bezier, final int lineWidth, final int lineOffset, final int endX) {
        bezierUpdateDataOf(bezier, GB_UPDATE_X, bezierUpdateDataOf(bezier, GB_UPDATE_X) - (lineOffset << 8));
        final int lastX = wideBezierUpdateDataOf(bezier, GB_UPDATE_X);
        wideBezierUpdateDataOf(bezier, GB_UPDATE_X, lastX + ((lineWidth - lineOffset) << 8));
        final int lastY = wideBezierUpdateDataOf(bezier, GB_UPDATE_Y);
        wideBezierUpdateDataOf(bezier, GB_UPDATE_Y, lastY + (lineWidth << 8));
        bezierFinalXOfput(bezier, endX - lineOffset);
    }

    /*
     * Adjust the wide bezier curve (dx >= 0) to start/end at the right point[] /
     *
     * /* BalloonEnginePlugin>>#adjustWideBezierRight:width:offset:endX:
     */
    private void adjustWideBezierRightwidthoffsetendX(final int bezier, final int lineWidth, final int lineOffset, final int endX) {
        bezierUpdateDataOf(bezier, GB_UPDATE_X, bezierUpdateDataOf(bezier, GB_UPDATE_X) + (lineOffset << 8));
        final int lastX = wideBezierUpdateDataOf(bezier, GB_UPDATE_X);
        wideBezierUpdateDataOf(bezier, GB_UPDATE_X, lastX - ((lineWidth - lineOffset) << 8));
        /* Set lineWidth pixels down */
        final int lastY = wideBezierUpdateDataOf(bezier, GB_UPDATE_Y);
        wideBezierUpdateDataOf(bezier, GB_UPDATE_Y, lastY + (lineWidth << 8));
        bezierFinalXOfput(bezier, endX - lineOffset + lineWidth);
    }

    /*
     * Adjust the wide line after it has been stepped from lastX to nextX. Special adjustments of
     * line width and start position are made here to simulate a rectangular brush
     */

    /* BalloonEnginePlugin>>#adjustWideLine:afterSteppingFrom:to: */
    private void adjustWideLineafterSteppingFromto(final int line, final int lastX, final int nextX) {
        /* Fetch the values the adjustment decisions are based on */
        final int yEntry = wideLineEntryOf(line);
        final int yExit = wideLineExitOf(line);
        final int baseWidth = wideLineExtentOf(line);
        final int lineOffset = offsetFromWidth(baseWidth);
        int lineWidth = wideLineWidthOf(line);
        final int xDir = lineXDirectionOf(line);

        /* Adjust the start of the line to fill an entire rectangle */
        final int deltaX = nextX - lastX;
        if (yEntry < baseWidth) {
            if (xDir < 0) {
                /* effectively adding */
                lineWidth -= deltaX;
            } else {
                lineWidth += deltaX;
                edgeXValueOfput(line, lastX);
            }
        }
        if (yExit + lineOffset == 0) {
            if (xDir > 0) {
                lineWidth -= lineXIncrementOf(line);
            } else {
                /* effectively subtracting */
                lineWidth += lineXIncrementOf(line);
                edgeXValueOfput(line, lastX);
            }
        }
        if (yExit + lineOffset > 0) {
            if (xDir < 0) {
                /* effectively subtracting */
                lineWidth += deltaX;
                edgeXValueOfput(line, lastX);
            } else {
                lineWidth -= deltaX;
            }
        }
        wideLineWidthOfput(line, lineWidth);
    }

    /* BalloonEngineBase>>#aetStartGet */
    private int aetStartGet() {
        return workBuffer[GW_AET_START];
    }

    /* BalloonEngineBase>>#aetStartPut: */
    private void aetStartPut(final int value) {
        workBuffer[GW_AET_START] = value;
    }

    /* BalloonEngineBase>>#aetUsedGet */
    private int aetUsedGet() {
        return workBuffer[GW_AET_USED];
    }

    /* BalloonEngineBase>>#aetUsedPut: */
    private void aetUsedPut(final int value) {
        workBuffer[GW_AET_USED] = value;
    }

    /* Allocate n slots in the active edge table */

    /* BalloonEngineBase>>#allocateAETEntry: */
    private boolean allocateAETEntry(final int nSlots) {
        return needAvailableSpace(nSlots);
    }

    /* BalloonEnginePlugin>>#allocateBezier */
    private int allocateBezier() {
        if (!allocateObjEntry(GB_BASE_SIZE)) {
            return 0;
        }
        final int bezier = objUsed;
        objUsed = bezier + GB_BASE_SIZE;
        objectTypeOfput(bezier, GE_PRIMITIVE_BEZIER);
        objectIndexOfput(bezier, 0);
        objectLengthOfput(bezier, GB_BASE_SIZE);
        return bezier;
    }

    /* BalloonEnginePlugin>>#allocateBezierStackEntry */
    private int allocateBezierStackEntry() {
        wbStackPush(6);
        return wbStackSize();
    }

    /* BalloonEnginePlugin>>#allocateBitmapFill:colormap: */
    private int allocateBitmapFillcolormap(final int cmSize, final int[] cmBits) {
        final int fillSize = GB_M_BASE_SIZE + cmSize;
        if (!allocateObjEntry(fillSize)) {
            return 0;
        }
        final int fill = objUsed;
        objUsed = fill + fillSize;
        objectTypeOfput(fill, GE_PRIMITIVE_CLIPPED_BITMAP_FILL);
        objectIndexOfput(fill, 0);
        objectLengthOfput(fill, fillSize);
        if (hasColorTransform()) {
            for (int i = 0; i < cmSize; i++) {
                colormapOf(fill, i, transformColor(cmBits[i]));
            }
        } else {
            for (int i = 0; i < cmSize; i++) {
                colormapOf(fill, i, cmBits[i]);
            }
        }
        bitmapCmSizeOfput(fill, cmSize);
        return fill;
    }

    /* Allocate n slots in the global edge table */

    /* BalloonEngineBase>>#allocateGETEntry: */
    private boolean allocateGETEntry(final int nSlots) {
        /* First allocate nSlots in the AET */
        if (!allocateAETEntry(nSlots)) {
            return false;
        }
        if (aetUsedGet() != 0) {
            /* Then move the AET upwards */
            int srcIndex = aetUsedGet();
            int dstIndex = aetUsedGet() + nSlots;
            for (int i = 1, iLimiT = aetUsedGet(); i <= iLimiT; i++) {
                aetBuffer(--dstIndex, aetBuffer(--srcIndex));
            }
        }
        aetBufferIndex += nSlots;
        return true;
    }

    /* BalloonEnginePlugin>>#allocateGradientFill:rampWidth:isRadial: */
    private int allocateGradientFillrampWidthisRadial(final int[] ramp, final int rampWidth, final boolean isRadial) {
        final int fillSize = GG_BASE_SIZE + rampWidth;
        if (!allocateObjEntry(fillSize)) {
            return 0;
        }
        final int fill = objUsed;
        objUsed = fill + fillSize;
        if (isRadial) {
            objectTypeOfput(fill, GE_PRIMITIVE_RADIAL_GRADIENT_FILL);
        } else {
            objectTypeOfput(fill, GE_PRIMITIVE_LINEAR_GRADIENT_FILL);
        }
        objectIndexOfput(fill, 0);
        objectLengthOfput(fill, fillSize);
        final int rampPtr = gradientRampIndexOf(fill);
        if (hasColorTransform()) {
            for (int i = 0; i < rampWidth; i++) {
                workBuffer[rampPtr + i] = transformColor(ramp[i]);
            }
        } else {
            UnsafeUtils.copyInts(ramp, 0L, workBuffer, rampPtr, rampWidth);
        }
        gradientRampLengthOfput(fill, rampWidth);
        return fill;
    }

    /* BalloonEnginePlugin>>#allocateLine */
    private int allocateLine() {
        if (!allocateObjEntry(GL_BASE_SIZE)) {
            return 0;
        }
        final int line = objUsed;
        objUsed = line + GL_BASE_SIZE;
        objectTypeOfput(line, GE_PRIMITIVE_LINE);
        objectIndexOfput(line, 0);
        objectLengthOfput(line, GL_BASE_SIZE);
        return line;
    }

    /* Allocate n slots in the object buffer */

    /* BalloonEngineBase>>#allocateObjEntry: */
    private boolean allocateObjEntry(final int nSlots) {
        /* First allocate nSlots in the GET */
        if (!allocateGETEntry(nSlots)) {
            return false;
        }
        if (getUsedGet() != 0) {
            /* Then move the GET upwards */
            int srcIndex = getUsedGet();
            int dstIndex = getUsedGet() + nSlots;
            for (int i = 1, iLimiT = getUsedGet(); i <= iLimiT; i++) {
                getBuffer(--dstIndex, getBuffer(--srcIndex));
            }
        }
        getBufferIndex += nSlots;
        return true;
    }

    /* AET and Stack allocation are symmetric */

    /* BalloonEngineBase>>#allocateStackEntry: */
    private boolean allocateStackEntry(final int nSlots) {
        return needAvailableSpace(nSlots);
    }

    /* BalloonEngineBase>>#allocateStackFillEntry */
    private boolean allocateStackFillEntry() {
        return wbStackPush(stackFillEntryLength());
    }

    /* BalloonEnginePlugin>>#allocateWideBezier */
    private int allocateWideBezier() {
        if (!allocateObjEntry(GB_WIDE_SIZE)) {
            return 0;
        }
        final int bezier = objUsed;
        objUsed = bezier + GB_WIDE_SIZE;
        objectTypeOfput(bezier, GE_PRIMITIVE_WIDE_BEZIER);
        objectIndexOfput(bezier, 0);
        objectLengthOfput(bezier, GB_WIDE_SIZE);
        return bezier;
    }

    /* BalloonEnginePlugin>>#allocateWideLine */
    private int allocateWideLine() {
        if (!allocateObjEntry(GL_WIDE_SIZE)) {
            return 0;
        }
        final int line = objUsed;
        objUsed = line + GL_WIDE_SIZE;
        objectTypeOfput(line, GE_PRIMITIVE_WIDE_LINE);
        objectIndexOfput(line, 0);
        objectLengthOfput(line, GL_WIDE_SIZE);
        return line;
    }

    /* BalloonEngineBase>>#areEdgeFillsValid: */
    private boolean areEdgeFillsValid(final int edge) {
        return (objectHeaderOf(edge) & GE_EDGE_FILLS_INVALID) == 0;
    }

    /* Make sure that val1 is between val2 and val3. */

    /* BalloonEnginePlugin>>#assureValue:between:and: */
    private static int assureValuebetweenand(final int val1, final int val2, final int val3) {
        if (val2 > val3) {
            if (val1 > val2) {
                return val2;
            }
            if (val1 < val3) {
                return val3;
            }
        } else {
            if (val1 < val2) {
                return val2;
            }
            if (val1 > val3) {
                return val3;
            }
        }
        return val1;
    }

    /* BalloonEnginePlugin>>#bezierEndXOf: */
    private int bezierEndXOf(final int bezier) {
        return objat(bezier, GB_END_X);
    }

    /* BalloonEnginePlugin>>#bezierEndXOf:put: */
    private void bezierEndXOfput(final int bezier, final int value) {
        objatput(bezier, GB_END_X, value);
    }

    /* BalloonEnginePlugin>>#bezierEndYOf: */
    private int bezierEndYOf(final int bezier) {
        return objat(bezier, GB_END_Y);
    }

    /* BalloonEnginePlugin>>#bezierEndYOf:put: */
    private void bezierEndYOfput(final int bezier, final int value) {
        objatput(bezier, GB_END_Y, value);
    }

    /* BalloonEnginePlugin>>#bezierFinalXOf: */
    private int bezierFinalXOf(final int bezier) {
        return objat(bezier, GB_FINAL_X);
    }

    /* BalloonEnginePlugin>>#bezierFinalXOf:put: */
    private void bezierFinalXOfput(final int bezier, final int value) {
        objatput(bezier, GB_FINAL_X, value);
    }

    /* BalloonEnginePlugin>>#bezierUpdateDataOf: */
    private int bezierUpdateDataOf(final int bezier, final int offset) {
        return workBuffer[bezierUpdateDataIndexOf(bezier) + offset];
    }

    private int bezierUpdateDataIndexOf(final int bezier) {
        return objBufferIndex + bezier + GB_UPDATE_DATA;
    }

    private void bezierUpdateDataOf(final int bezier, final int offset, final int value) {
        workBuffer[bezierUpdateDataIndexOf(bezier) + offset] = value;
    }

    /* BalloonEnginePlugin>>#bezierViaXOf: */
    private int bezierViaXOf(final int bezier) {
        return objat(bezier, GB_VIA_X);
    }

    /* BalloonEnginePlugin>>#bezierViaXOf:put: */
    private void bezierViaXOfput(final int bezier, final int value) {
        objatput(bezier, GB_VIA_X, value);
    }

    /* BalloonEnginePlugin>>#bezierViaYOf: */
    private int bezierViaYOf(final int bezier) {
        return objat(bezier, GB_VIA_Y);
    }

    /* BalloonEnginePlugin>>#bezierViaYOf:put: */
    private void bezierViaYOfput(final int bezier, final int value) {
        objatput(bezier, GB_VIA_Y, value);
    }

    /* BalloonEnginePlugin>>#bitmapCmSizeOf: */
    private int bitmapCmSizeOf(final int bmFill) {
        return objat(bmFill, GB_COLORMAP_SIZE);
    }

    /* BalloonEnginePlugin>>#bitmapCmSizeOf:put: */
    private void bitmapCmSizeOfput(final int bmFill, final int value) {
        objatput(bmFill, GB_COLORMAP_SIZE, value);
    }

    /* BalloonEnginePlugin>>#bitmapDepthOf: */
    private int bitmapDepthOf(final int bmFill) {
        return objat(bmFill, GB_BITMAP_DEPTH);
    }

    /* BalloonEnginePlugin>>#bitmapDepthOf:put: */
    private void bitmapDepthOfput(final int bmFill, final int value) {
        objatput(bmFill, GB_BITMAP_DEPTH, value);
    }

    /* BalloonEnginePlugin>>#bitmapHeightOf: */
    private int bitmapHeightOf(final int bmFill) {
        return objat(bmFill, GB_BITMAP_HEIGHT);
    }

    /* BalloonEnginePlugin>>#bitmapHeightOf:put: */
    private void bitmapHeightOfput(final int bmFill, final int value) {
        objatput(bmFill, GB_BITMAP_HEIGHT, value);
    }

    /* BalloonEnginePlugin>>#bitmapRasterOf: */
    private int bitmapRasterOf(final int bmFill) {
        return objat(bmFill, GB_BITMAP_RASTER);
    }

    /* BalloonEnginePlugin>>#bitmapRasterOf:put: */
    private void bitmapRasterOfput(final int bmFill, final int value) {
        objatput(bmFill, GB_BITMAP_RASTER, value);
    }

    /* BalloonEnginePlugin>>#bitmapSizeOf: */
    private int bitmapSizeOf(final int bmFill) {
        return objat(bmFill, GB_BITMAP_SIZE);
    }

    /* BalloonEnginePlugin>>#bitmapSizeOf:put: */
    private void bitmapSizeOfput(final int bmFill, final int value) {
        objatput(bmFill, GB_BITMAP_SIZE, value);
    }

    /* BalloonEnginePlugin>>#bitmapTileFlagOf: */
    private int bitmapTileFlagOf(final int bmFill) {
        return objat(bmFill, GB_TILE_FLAG);
    }

    /* BalloonEnginePlugin>>#bitmapTileFlagOf:put: */
    private void bitmapTileFlagOfput(final int bmFill, final int value) {
        objatput(bmFill, GB_TILE_FLAG, value);
    }

    /* BalloonEnginePlugin>>#bitmapValue:bits:atX:y: */
    private int bitmapValuebitsatXy(final int bmFill, final int[] bits, final int xp, final int yp) {
        final int bmDepth = bitmapDepthOf(bmFill);
        final int bmRaster = bitmapRasterOf(bmFill);
        if (bmDepth == 32) {
            int value = bits[bmRaster * yp + xp];
            if (value != 0 && (value & 0xFF000000L) == 0) {
                value = value | 0xFF000000;
            }
            return uncheckedTransformColor(value);
        }
        int rShift = R_SHIFT_TABLE[bmDepth];
        /* cMask - mask out the pixel from the word */
        int value = bits[bmRaster * yp + shr(xp, rShift)];
        /* rShift - shift value to move the pixel in the word to the lowest bit position */
        final int cMask = shl(1, bmDepth) - 1;
        rShift = 32 - bmDepth - (xp & shl(1, rShift) - 1) * bmDepth;
        value = shr(value, rShift) & cMask;
        if (bmDepth == 16) {
            /* Must convert by expanding bits */
            if (value != 0) {
                int b = (value & 0x1F) << 3;
                b += b >>> 5;
                int g = (value >>> 5 & 0x1F) << 3;
                g += g >>> 5;
                int r = (value >>> 10 & 0x1F) << 3;
                r += r >>> 5;
                final int a = 0xFF;
                value = b + (g << 8) + (r << 16) + (a << 24);
            }
        } else {
            /* Must convert by using color map */
            if (bitmapCmSizeOf(bmFill) == 0) {
                value = 0;
            } else {
                value = colormapOf(bmFill, value);
            }
        }
        return uncheckedTransformColor(value);
    }

    /* BalloonEnginePlugin>>#bitmapWidthOf: */
    private int bitmapWidthOf(final int bmFill) {
        return objat(bmFill, GB_BITMAP_WIDTH);
    }

    /* BalloonEnginePlugin>>#bitmapWidthOf:put: */
    private void bitmapWidthOfput(final int bmFill, final int value) {
        objatput(bmFill, GB_BITMAP_WIDTH, value);
    }

    /* BalloonEnginePlugin>>#bzEndX: */
    private int bzEndX(final int index) {
        return wbStackValue(wbStackSize() - index + 4);
    }

    /* BalloonEnginePlugin>>#bzEndX:put: */
    private void bzEndXput(final int index, final int value) {
        wbStackValueput(wbStackSize() - index + 4, value);
    }

    /* BalloonEnginePlugin>>#bzEndY: */
    private int bzEndY(final int index) {
        return wbStackValue(wbStackSize() - index + 5);
    }

    /* BalloonEnginePlugin>>#bzEndY:put: */
    private void bzEndYput(final int index, final int value) {
        wbStackValueput(wbStackSize() - index + 5, value);
    }

    /* BalloonEnginePlugin>>#bzStartX: */
    private int bzStartX(final int index) {
        return wbStackValue(wbStackSize() - index);
    }

    /* BalloonEnginePlugin>>#bzStartX:put: */
    private void bzStartXput(final int index, final int value) {
        wbStackValueput(wbStackSize() - index, value);
    }

    /* BalloonEnginePlugin>>#bzStartY: */
    private int bzStartY(final int index) {
        return wbStackValue(wbStackSize() - index + 1);
    }

    /* BalloonEnginePlugin>>#bzStartY:put: */
    private void bzStartYput(final int index, final int value) {
        wbStackValueput(wbStackSize() - index + 1, value);
    }

    /* BalloonEnginePlugin>>#bzViaX: */
    private int bzViaX(final int index) {
        return wbStackValue(wbStackSize() - index + 2);
    }

    /* BalloonEnginePlugin>>#bzViaX:put: */
    private void bzViaXput(final int index, final int value) {
        wbStackValueput(wbStackSize() - index + 2, value);
    }

    /* BalloonEnginePlugin>>#bzViaY: */
    private int bzViaY(final int index) {
        return wbStackValue(wbStackSize() - index + 3);
    }

    /* BalloonEnginePlugin>>#bzViaY:put: */
    private void bzViaYput(final int index, final int value) {
        wbStackValueput(wbStackSize() - index + 3, value);
    }

    /* Check the fill indexes in the run-length encoded fillList */

    /* BalloonEnginePlugin>>#checkCompressedFillIndexList:max:segments: */
    private static boolean checkCompressedFillIndexListmaxsegments(final NativeObject fillList, final int maxIndex, final int nSegs) {
        int nFills;
        int runLength;
        int runValue;

        final int[] fillPtr = fillList.getIntStorage();
        final int length = fillPtr.length;
        nFills = 0;
        for (int i = 0; i < length; i++) {
            runLength = shortRunLengthAtfrom(i, fillPtr);
            runValue = shortRunValueAtfrom(i, fillPtr);
            if (!(runValue >= 0 && runValue <= maxIndex)) {
                return false;
            }
            nFills += runLength;
        }
        return nFills == nSegs;
    }

    /* Check if the indexList (containing fill handles) is okay. */

    /* BalloonEnginePlugin>>#checkCompressedFills: */
    private boolean checkCompressedFills(final NativeObject indexList) {
        final int[] fillPtr = indexList.getIntStorage();
        for (final int j : fillPtr) {
            /* Make sure the fill is okay */
            if (!isFillOkay(j)) {
                return false;
            }
        }
        return true;
    }

    /* Check the run-length encoded lineWidthList matches nSegments */

    /* BalloonEnginePlugin>>#checkCompressedLineWidths:segments: */
    private static boolean checkCompressedLineWidthssegments(final NativeObject lineWidthList, final int nSegments) {
        final int[] ptr = lineWidthList.getIntStorage();
        final int length = ptr.length;
        int nItems = 0;
        int runLength;
        for (int i = 0; i < length; i++) {
            runLength = shortRunLengthAtfrom(i, ptr);
            nItems += runLength;
        }
        return nItems == nSegments;
    }

    /* Check if the given point array can be handled by the engine. */

    /* BalloonEnginePlugin>>#checkCompressedPoints:segments: */
    private static boolean checkCompressedPointssegments(final NativeObject points, final int nSegments) {
        assert points.isIntType();
        /*
         * The points must be either in PointArray format or ShortPointArray format. Also, we
         * currently handle only quadratic segments (e.g., 3 points each) and thus either pSize =
         * nSegments * 3, for ShortPointArrays or, pSize = nSegments * 6, for PointArrays
         */
        final int pSize = slotSizeOf(points);
        return pSize == nSegments * 3 || pSize == nSegments * 6;
    }

    /*
     * Check if the given shape can be handled by the engine. Since there are a number of
     * requirements this is an extra method.
     */

    /*
     * BalloonEnginePlugin>>#checkCompressedShape:segments:leftFills:rightFills:lineWidths:lineFills
     * :fillIndexList:
     */
    private boolean checkCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexList(final NativeObject points, final int nSegments, final NativeObject leftFills,
                    final NativeObject rightFills, final NativeObject lineWidths, final NativeObject lineFills, final NativeObject fillIndexList) {
        if (!checkCompressedPointssegments(points, nSegments)) {
            return false;
        }
        if (!checkCompressedFills(fillIndexList)) {
            return false;
        }
        final int maxFillIndex = slotSizeOf(fillIndexList);
        if (!checkCompressedFillIndexListmaxsegments(leftFills, maxFillIndex, nSegments)) {
            return false;
        }
        if (!checkCompressedFillIndexListmaxsegments(rightFills, maxFillIndex, nSegments)) {
            return false;
        }
        if (!checkCompressedFillIndexListmaxsegments(lineFills, maxFillIndex, nSegments)) {
            return false;
        }
        return checkCompressedLineWidthssegments(lineWidths, nSegments);
    }

    /*
     * Add the bezier to the global edge table if it intersects the clipping region
     */

    /* BalloonEnginePlugin>>#checkedAddBezierToGET: */
    private void checkedAddBezierToGET(final int bezier) {
        final int lineWidth;

        if (isWide(bezier)) {
            lineWidth = wideBezierExtentOf(bezier);
        } else {
            lineWidth = 0;
        }
        if (bezierEndYOf(bezier) + lineWidth < fillMinYGet()) {
            return;
        }
        if (edgeXValueOf(bezier) - lineWidth >= fillMaxXGet() && bezierEndXOf(bezier) - lineWidth >= fillMaxXGet()) {
            return;
        }
        addEdgeToGET(bezier);
    }

    /*
     * Add the edge to the global edge table. For known edge types, check if the edge intersects the
     * visible region
     */

    /* BalloonEnginePlugin>>#checkedAddEdgeToGET: */
    private void checkedAddEdgeToGET(final int edge) {
        if (isLine(edge)) {
            checkedAddLineToGET(edge);
            return;
        }
        if (isBezier(edge)) {
            checkedAddBezierToGET(edge);
            return;
        }
        addEdgeToGET(edge);
    }

    /* Add the line to the global edge table if it intersects the clipping region */

    /* BalloonEnginePlugin>>#checkedAddLineToGET: */
    private void checkedAddLineToGET(final int line) {
        final int lineWidth;

        if (isWide(line)) {
            lineWidth = wideLineExtentOf(line);
        } else {
            lineWidth = 0;
        }
        if (lineEndYOf(line) + lineWidth < fillMinYGet()) {
            return;
        }
        if (edgeXValueOf(line) - lineWidth >= fillMaxXGet() && lineEndXOf(line) - lineWidth >= fillMaxXGet()) {
            return;
        }
        addEdgeToGET(line);
    }

    /* BalloonEnginePlugin>>#clampValue:max: */
    private static int clampValuemax(final int value, final int maxValue) {
        if (value < 0) {
            return 0;
        } else {
            if (value >= maxValue) {
                return maxValue - 1;
            } else {
                return value;
            }
        }
    }

    /*
     * Clear the current span buffer. The span buffer is only cleared in the area that has been used
     * by the previous scan line.
     */

    /* BalloonEngineBase>>#clearSpanBuffer */
    private void clearSpanBuffer() {

        int x0 = shr(spanStartGet(), aaShiftGet());
        int x1 = shr(spanEndGet(), aaShiftGet()) + 1;
        if (x0 < 0) {
            x0 = 0;
        }
        if (x1 > spanSizeGet()) {
            x1 = spanSizeGet();
        }
        while (x0 < x1) {
            spanBuffer[x0] = 0;
            x0++;
        }
        spanStartPut(spanSizeGet());
        spanEndPut(0);
    }

    /* BalloonEngineBase>>#clearSpanBufferGet */
    private int clearSpanBufferGet() {
        return workBuffer[GW_CLEAR_SPAN_BUFFER];
    }

    /* BalloonEngineBase>>#clearSpanBufferPut: */
    private void clearSpanBufferPut(final int value) {
        workBuffer[GW_CLEAR_SPAN_BUFFER] = value;
    }

    /* BalloonEngineBase>>#clipMaxXGet */
    private int clipMaxXGet() {
        return workBuffer[GW_CLIP_MAX_X];
    }

    /* BalloonEngineBase>>#clipMaxXPut: */
    private void clipMaxXPut(final int value) {
        workBuffer[GW_CLIP_MAX_X] = value;
    }

    /* BalloonEngineBase>>#clipMaxYGet */
    private int clipMaxYGet() {
        return workBuffer[GW_CLIP_MAX_Y];
    }

    /* BalloonEngineBase>>#clipMaxYPut: */
    private void clipMaxYPut(final int value) {
        workBuffer[GW_CLIP_MAX_Y] = value;
    }

    /* BalloonEngineBase>>#clipMinXGet */
    private int clipMinXGet() {
        return workBuffer[GW_CLIP_MIN_X];
    }

    /* BalloonEngineBase>>#clipMinXPut: */
    private void clipMinXPut(final int value) {
        workBuffer[GW_CLIP_MIN_X] = value;
    }

    /* BalloonEngineBase>>#clipMinYGet */
    private int clipMinYGet() {
        return workBuffer[GW_CLIP_MIN_Y];
    }

    /* BalloonEngineBase>>#clipMinYPut: */
    private void clipMinYPut(final int value) {
        workBuffer[GW_CLIP_MIN_Y] = value;
    }

    /* BalloonEnginePlugin>>#colormapOf: */
    private int colormapOf(final int bmFill, final int index) {
        return workBuffer[colormapIndexOf(bmFill) + index];
    }

    private void colormapOf(final int bmFill, final int index, final int value) {
        workBuffer[colormapIndexOf(bmFill) + index] = value;
    }

    private int colormapIndexOf(final int bmFill) {
        return objBufferIndex + bmFill + GB_COLORMAP_OFFSET;
    }

    /* BalloonEngineBase>>#colorTransform */
    private int colorTransformGet(final int index) {
        return workBuffer[GW_COLOR_TRANSFORM + index];
    }

    private void colorTransformSet(final int index, final float value) {
        workBuffer[GW_COLOR_TRANSFORM + index] = (int) value;
    }

    /* Split the bezier curve at 0.5. */

    /* BalloonEnginePlugin>>#computeBezierSplitAtHalf: */
    private int computeBezierSplitAtHalf(final int index) {
        final int newIndex = allocateBezierStackEntry();
        if (engineStopped) {
            return 0;
        }
        final int startX = bzStartX(index);
        int leftViaX = startX;
        final int startY = bzStartY(index);
        int leftViaY = startY;
        final int viaX = bzViaX(index);
        int rightViaX = viaX;
        final int viaY = bzViaY(index);
        int rightViaY = viaY;
        final int endX = bzEndX(index);
        /* Compute intermediate points */
        final int endY = bzEndY(index);
        leftViaX += (viaX - startX) / 2;
        leftViaY += (viaY - startY) / 2;
        int sharedX = rightViaX += (endX - viaX) / 2;
        /* Compute new shared point */
        int sharedY = rightViaY += (endY - viaY) / 2;
        sharedX += (leftViaX - rightViaX) / 2;
        /* Store the first part back */
        sharedY += (leftViaY - rightViaY) / 2;
        bzViaXput(index, leftViaX);
        bzViaYput(index, leftViaY);
        bzEndXput(index, sharedX);
        bzEndYput(index, sharedY);
        bzStartXput(newIndex, sharedX);
        bzStartYput(newIndex, sharedY);
        bzViaXput(newIndex, rightViaX);
        bzViaYput(newIndex, rightViaY);
        bzEndXput(newIndex, endX);
        bzEndYput(newIndex, endY);
        return newIndex;
    }

    /*
     * Split the bezier curve at the given parametric value. Note: Since this method is only invoked
     * to make non-monoton beziers monoton we must check for the resulting y values to be *really*
     * between the start and end value.
     */

    /* BalloonEnginePlugin>>#computeBezier:splitAt: */
    private int computeBeziersplitAt(final int index, final double param) {
        final int startX = bzStartX(index);
        int leftViaX = startX;
        final int startY = bzStartY(index);
        int leftViaY = startY;
        final int viaX = bzViaX(index);
        int rightViaX = viaX;
        final int viaY = bzViaY(index);
        int rightViaY = viaY;
        final int endX = bzEndX(index);

        /* Compute intermediate points */
        final int endY = bzEndY(index);
        final int sharedX = leftViaX += (int) ((viaX - startX) * param);
        int sharedY = leftViaY += (int) ((viaY - startY) * param);
        rightViaX += (int) ((endX - viaX) * param);

        /*
         * Compute new shared point[] / rightViaY += ((long) ((((double) (endY - viaY))) * param));
         * sharedX += ((long) ((((double) (rightViaX - leftViaX))) * param));
         *
         * /* Check the new via points
         */
        sharedY += (int) ((rightViaY - leftViaY) * param);
        leftViaY = assureValuebetweenand(leftViaY, startY, sharedY);
        rightViaY = assureValuebetweenand(rightViaY, sharedY, endY);
        final int newIndex = allocateBezierStackEntry();
        if (engineStopped) {
            return 0;
        }
        bzViaXput(index, leftViaX);
        bzViaYput(index, leftViaY);
        bzEndXput(index, sharedX);
        bzEndYput(index, sharedY);
        bzStartXput(newIndex, sharedX);
        bzStartYput(newIndex, sharedY);
        bzViaXput(newIndex, rightViaX);
        bzViaYput(newIndex, rightViaY);
        bzEndXput(newIndex, endX);
        bzEndYput(newIndex, endY);
        return newIndex;
    }

    /*
     * Get both values from the two boundaries of the given bezier and compute the actual
     * position/width of the line
     */

    /* BalloonEnginePlugin>>#computeFinalWideBezierValues:width: */
    private void computeFinalWideBezierValueswidth(final int bezier, final int lineWidth) {
        int leftX;
        int rightX;
        final int temp;

        leftX = bezierUpdateDataOf(bezier, GB_UPDATE_X) / 256;
        rightX = wideBezierUpdateDataOf(bezier, GB_UPDATE_X) / 256;
        if (leftX > rightX) {
            temp = leftX;
            leftX = rightX;
            rightX = temp;
        }
        edgeXValueOfput(bezier, leftX);
        wideBezierWidthOfput(bezier, Math.max(rightX - leftX, lineWidth));
    }

    /* BalloonEngineBase>>#computeSqrt: */
    private static int computeSqrt(final int length) {
        if (length < 32) {
            return SMALL_SQRT_TABLE[length];
        } else {
            return (int) (Math.sqrt(length) + 0.5);
        }
    }

    /* BalloonEngineBase>>#copyBitsFrom:to:at: */
    private void copyBitsFromtoat(final int x0, final int x1, final int yValue) {
        image.bitblt.copyBitsFromtoat(x0, x1, yValue);
    }

    /* Create the global edge table */

    /* BalloonEngineBase>>#createGlobalEdgeTable */
    private void createGlobalEdgeTable() {
        int object = 0;
        final int end = objUsed;
        while (object < end) {
            /* Note: addEdgeToGET: may fail on insufficient space but that's not a problem here */
            if (isEdge(object) && edgeYValueOf(object) < fillMaxYGet()) {
                /* Check if the edge starts below fillMaxY. */
                checkedAddEdgeToGET(object);
            }
            object += objectLengthOf(object);
        }
    }

    /* BalloonEngineBase>>#currentYGet */
    private int currentYGet() {
        return workBuffer[GW_CURRENT_Y];
    }

    /* BalloonEngineBase>>#currentYPut: */
    private void currentYPut(final int value) {
        workBuffer[GW_CURRENT_Y] = value;
    }

    /* BalloonEngineBase>>#currentZGet */
    private int currentZGet() {
        return workBuffer[GW_CURRENT_Z];
    }

    /* BalloonEngineBase>>#currentZPut: */
    private void currentZPut(final int value) {
        workBuffer[GW_CURRENT_Z] = value;
    }

    /* BalloonEngineBase>>#destOffsetXGet */
    private int destOffsetXGet() {
        return workBuffer[GW_DEST_OFFSET_X];
    }

    /* BalloonEngineBase>>#destOffsetXPut: */
    private void destOffsetXPut(final int value) {
        workBuffer[GW_DEST_OFFSET_X] = value;
    }

    /* BalloonEngineBase>>#destOffsetYGet */
    private int destOffsetYGet() {
        return workBuffer[GW_DEST_OFFSET_Y];
    }

    /* BalloonEngineBase>>#destOffsetYPut: */
    private void destOffsetYPut(final int value) {
        workBuffer[GW_DEST_OFFSET_Y] = value;
    }

    /* Display the span buffer at the current scan line. */

    /* BalloonEngineBase>>#displaySpanBufferAt: */
    private void displaySpanBufferAt(final int y) {
        /* self aaLevelGet > 1 ifTrue:[self adjustAALevel]. */
        int targetX0 = shr(spanStartGet(), aaShiftGet());
        if (targetX0 < clipMinXGet()) {
            targetX0 = clipMinXGet();
        }
        int targetX1 = shr(spanEndGet() + aaLevelGet() - 1, aaShiftGet());
        if (targetX1 > clipMaxXGet()) {
            targetX1 = clipMaxXGet();
        }
        final int targetY = shr(y, aaShiftGet());
        if (targetY < clipMinYGet() || targetY >= clipMaxYGet() || targetX1 < clipMinXGet() || targetX0 >= clipMaxXGet()) {
            return;
        }
        copyBitsFromtoat(targetX0, targetX1, targetY);
    }

    /*
     * Draw the given edge starting from leftX with the edge's fill. Return the end value of the
     * drawing operation.
     */

    /* BalloonEngineBase>>#drawWideEdge:from: */
    @SuppressWarnings("unused")
    private int drawWideEdgefrom(final int edge, final int leftX) {
        /* Not for the moment */
        final int type = edgeTypeOf(edge);
        final int lineWidth = switch (type) {
            case 0, 1 -> errorWrongIndex();
            case 2 -> returnWideLineWidth(edge);
            case 3 -> returnWideBezierWidth(edge);
            default -> throw SqueakException.create("Unexpected type:", type);
        };
        final int fill = switch (type) {
            case 0, 1 -> errorWrongIndex();
            case 2 -> makeUnsignedFrom(returnWideLineFill(edge));
            case 3 -> makeUnsignedFrom(returnWideBezierFill(edge));
            default -> throw SqueakException.create("Unexpected type:", type);
        };
        if (fill == 0) {
            return leftX;
        }
        final int rightX = leftX + lineWidth;
        fillSpanfromto(fill, leftX, rightX);
        return rightX;
    }

    /* BalloonEngineBase>>#edgeFillsInvalidate: */
    private void edgeFillsInvalidate(final int edge) {
        objectTypeOfput(edge, objectTypeOf(edge) | GE_EDGE_FILLS_INVALID);
    }

    /* BalloonEngineBase>>#edgeFillsValidate: */
    private void edgeFillsValidate(final int edge) {
        objectTypeOfput(edge, objectTypeOf(edge) & ~GE_EDGE_FILLS_INVALID);
    }

    /* BalloonEngineBase>>#edgeLeftFillOf: */
    private int edgeLeftFillOf(final int edge) {
        return objat(edge, GE_FILL_INDEX_LEFT);
    }

    /* BalloonEngineBase>>#edgeLeftFillOf:put: */
    private void edgeLeftFillOfput(final int edge, final int value) {
        objatput(edge, GE_FILL_INDEX_LEFT, value);
    }

    /* BalloonEngineBase>>#edgeNumLinesOf: */
    private int edgeNumLinesOf(final int edge) {
        return objat(edge, GE_NUM_LINES);
    }

    /* BalloonEngineBase>>#edgeNumLinesOf:put: */
    private void edgeNumLinesOfput(final int edge, final int value) {
        objatput(edge, GE_NUM_LINES, value);
    }

    /* BalloonEngineBase>>#edgeRightFillOf: */
    private int edgeRightFillOf(final int edge) {
        return objat(edge, GE_FILL_INDEX_RIGHT);
    }

    /* BalloonEngineBase>>#edgeRightFillOf:put: */
    private void edgeRightFillOfput(final int edge, final int value) {
        objatput(edge, GE_FILL_INDEX_RIGHT, value);
    }

    /* BalloonEngineBase>>#edgeTransform */
    private float edgeTransformGet(final int index) {
        return Float.intBitsToFloat(workBuffer[GW_EDGE_TRANSFORM + index]);
    }

    private void edgeTransformSet(final int index, final float value) {
        workBuffer[GW_EDGE_TRANSFORM + index] = Float.floatToRawIntBits(value);
    }

    /* Return the edge type (e.g., witout the wide edge flag) */

    /* BalloonEngineBase>>#edgeTypeOf: */
    private int edgeTypeOf(final int edge) {
        return objectTypeOf(edge) >>> 1;
    }

    /* BalloonEngineBase>>#edgeXValueOf: */
    private int edgeXValueOf(final int edge) {
        return objat(edge, GE_X_VALUE);
    }

    /* BalloonEngineBase>>#edgeXValueOf:put: */
    private void edgeXValueOfput(final int edge, final int value) {
        objatput(edge, GE_X_VALUE, value);
    }

    /* BalloonEngineBase>>#edgeYValueOf: */
    private int edgeYValueOf(final int edge) {
        return objat(edge, GE_Y_VALUE);
    }

    /* BalloonEngineBase>>#edgeYValueOf:put: */
    private void edgeYValueOfput(final int edge, final int value) {
        objatput(edge, GE_Y_VALUE, value);
    }

    /* BalloonEngineBase>>#edgeZValueOf: */
    private int edgeZValueOf(final int edge) {
        return objat(edge, GE_Z_VALUE);
    }

    /* BalloonEngineBase>>#edgeZValueOf:put: */
    private void edgeZValueOfput(final int edge, final int value) {
        objatput(edge, GE_Z_VALUE, value);
    }

    /*
     * Ignore dispatch errors when translating to C (since we have no entry point for #error in the
     * VM proxy)
     */

    /* BalloonEngineBase>>#errorWrongIndex */
    private static int errorWrongIndex() {
        return 0;
    }

    /*
     * Estimate the length of the vector described by deltaX and deltaY. This method may be
     * extremely inaccurate - use it only if you know exactly that this doesn't matter. Otherwise
     * use #accurateLengthOf:width:
     */

    /* BalloonEngineBase>>#estimatedLengthOf:with: */
    @SuppressWarnings("unused")
    private static int estimatedLengthOfwith(final int deltaX, final int deltaY) {
        final int absDx;
        final int absDy;

        if (deltaX >= 0) {
            absDx = deltaX;
        } else {
            absDx = -deltaX;
        }
        if (deltaY >= 0) {
            absDy = deltaY;
        } else {
            absDy = -deltaY;
        }
        if (absDx > absDy) {
            return absDx + absDy / 2;
        } else {
            return absDy + absDx / 2;
        }
    }

    /* Fill the span buffer from leftX to rightX with the given fill. */

    /* BalloonEngineBase>>#fillAllFrom:to: */
    private void fillAllFromto(final int leftX, final int rightX) {
        int fill;
        int startX = leftX;
        int stopX = topRightX();

        while (stopX < rightX) {
            fill = makeUnsignedFrom(topFill());
            if (fill != 0 && fillSpanfromto(fill, startX, stopX)) {
                return;
            }
            quickRemoveInvalidFillsAt(stopX);
            startX = stopX;
            stopX = topRightX();
        }
        fill = makeUnsignedFrom(topFill());
        if (fill != 0) {
            fillSpanfromto(fill, startX, rightX);
        }
    }

    /* BalloonEnginePlugin>>#fillBitmapSpan */
    private void fillBitmapSpan() {
        fillBitmapSpanfromtoat(lastExportedFillGet(), lastExportedLeftXGet(), lastExportedRightXGet(), currentYGet());
    }

    /* BalloonEnginePlugin>>#fillBitmapSpanAA:from:to:at: */
    private void fillBitmapSpanAAfromtoat(final int bmFill, final int leftX, final int rightX, final int yValue) {
        final int[] bits = loadBitsFrom(bmFill);
        if (bits == null) {
            return;
        }
        final int bmWidth = bitmapWidthOf(bmFill);
        final int bmHeight = bitmapHeightOf(bmFill);
        final boolean tileFlag = bitmapTileFlagOf(bmFill) == 1;
        final int deltaX = leftX - fillOriginXOf(bmFill);
        final int deltaY = yValue - fillOriginYOf(bmFill);
        final int dsX = fillDirectionXOf(bmFill);
        final int dtX = fillNormalXOf(bmFill);
        int ds = deltaX * dsX + deltaY * fillDirectionYOf(bmFill);
        int dt = deltaX * dtX + deltaY * fillNormalYOf(bmFill);
        final int aaLevel = aaLevelGet();
        final int firstPixel = aaFirstPixelFromto(leftX, rightX);
        final int lastPixel = aaLastPixelFromto(leftX, rightX);
        final int baseShift = aaShiftGet();
        int cMask = aaColorMaskGet();
        int cShift = aaColorShiftGet();
        int x = leftX;
        while (x < firstPixel) {
            if (tileFlag) {
                ds = repeatValuemax(ds, bmWidth << 16);
                dt = repeatValuemax(dt, bmHeight << 16);
            }
            int xp = ds / 65536;
            int yp = dt / 65536;
            if (!tileFlag) {
                xp = clampValuemax(xp, bmWidth);
                yp = clampValuemax(yp, bmHeight);
            }
            if (xp >= 0 && yp >= 0 && xp < bmWidth && yp < bmHeight) {
                int fillValue = bitmapValuebitsatXy(bmFill, bits, xp, yp);
                fillValue = shr(fillValue & cMask, cShift);
                final int idx = shr(x, baseShift);
                spanBuffer[idx] = spanBuffer[idx] + fillValue;
            }
            ds += dsX;
            dt += dtX;
            x++;
        }
        cMask = shr(aaColorMaskGet(), aaShiftGet()) | 0xF0F0F0F0;
        cShift = aaShiftGet();
        while (x < lastPixel) {
            if (tileFlag) {
                ds = repeatValuemax(ds, bmWidth << 16);
                dt = repeatValuemax(dt, bmHeight << 16);
            }
            int xp = ds / 65536;
            int yp = dt / 65536;
            if (!tileFlag) {
                xp = clampValuemax(xp, bmWidth);
                yp = clampValuemax(yp, bmHeight);
            }
            if (xp >= 0 && yp >= 0 && xp < bmWidth && yp < bmHeight) {
                int fillValue = bitmapValuebitsatXy(bmFill, bits, xp, yp);
                fillValue = shr(fillValue & cMask, cShift);
                final int idx = shr(x, baseShift);
                spanBuffer[idx] = spanBuffer[idx] + fillValue;
            }
            ds += shl(dsX, cShift);
            dt += shl(dtX, cShift);
            x += aaLevel;
        }
        cMask = aaColorMaskGet();
        cShift = aaColorShiftGet();
        while (x < rightX) {
            if (tileFlag) {
                ds = repeatValuemax(ds, bmWidth << 16);
                dt = repeatValuemax(dt, bmHeight << 16);
            }
            int xp = ds / 65536;
            int yp = dt / 65536;
            if (!tileFlag) {
                xp = clampValuemax(xp, bmWidth);
                yp = clampValuemax(yp, bmHeight);
            }
            if (xp >= 0 && yp >= 0 && xp < bmWidth && yp < bmHeight) {
                int fillValue = bitmapValuebitsatXy(bmFill, bits, xp, yp);
                fillValue = shr(fillValue & cMask, cShift);
                final int idx = shr(x, baseShift);
                spanBuffer[idx] = spanBuffer[idx] + fillValue;
            }
            ds += dsX;
            dt += dtX;
            x++;
        }
    }

    /*
     * Fill the span buffer between leftEdge and rightEdge using the given bits. Note: We always
     * start from zero - this avoids using huge bitmap buffers if the bitmap is to be displayed at
     * the very far right hand side and also gives us a chance of using certain bitmaps (e.g., those
     * with depth 32) directly.
     */

    /* BalloonEngineBase>>#fillBitmapSpan:from:to: */
    private void fillBitmapSpanfromto(final int[] bits, final int leftX, final int rightX) {
        final int baseShift;
        int bitX;
        final int colorMask;
        final int colorShift;
        int fillValue;
        int x;
        int x0;
        final int x1;

        x0 = leftX;
        x1 = rightX;

        /* Hack for pre-increment */
        bitX = -1;
        if (aaLevelGet() == 1) {
            /* Speedy version for no anti-aliasing */
            while (x0 < x1) {
                fillValue = bits[++bitX];
                spanBuffer[x0] = fillValue;
                x0++;
            }
        } else {
            /* Generic version with anti-aliasing */
            colorMask = aaColorMaskGet();
            colorShift = aaColorShiftGet();
            baseShift = aaShiftGet();
            while (x0 < x1) {
                x = shr(x0, baseShift);
                fillValue = bits[++bitX];
                fillValue = shr(fillValue & colorMask, colorShift);
                spanBuffer[x] = spanBuffer[x] + fillValue;
                x0++;
            }
        }
        if (x1 > spanEndGet()) {
            spanEndPut(x1);
        }
        if (x1 > spanEndAAGet()) {
            spanEndAAPut(x1);
        }
    }

    /* BalloonEnginePlugin>>#fillBitmapSpan:from:to:at: */
    private void fillBitmapSpanfromtoat(final int bmFill, final int leftX, final int rightX, final int yValue) {
        if (aaLevelGet() != 1) {
            fillBitmapSpanAAfromtoat(bmFill, leftX, rightX, yValue);
            return;
        }
        final int[] bits = loadBitsFrom(bmFill);
        if (bits == null) {
            return;
        }
        final int bmWidth = bitmapWidthOf(bmFill);
        final int bmHeight = bitmapHeightOf(bmFill);
        final boolean tileFlag = bitmapTileFlagOf(bmFill) == 1;
        final int deltaX = leftX - fillOriginXOf(bmFill);
        final int deltaY = yValue - fillOriginYOf(bmFill);
        final int dsX = fillDirectionXOf(bmFill);
        final int dtX = fillNormalXOf(bmFill);
        int ds = deltaX * dsX + deltaY * fillDirectionYOf(bmFill);
        int dt = deltaX * dtX + deltaY * fillNormalYOf(bmFill);
        int x = leftX;
        final int x1 = rightX;
        while (x < x1) {
            if (tileFlag) {
                ds = repeatValuemax(ds, bmWidth << 16);
                dt = repeatValuemax(dt, bmHeight << 16);
            }
            int xp = ds / 65536;
            int yp = dt / 65536;
            if (!tileFlag) {
                xp = clampValuemax(xp, bmWidth);
                yp = clampValuemax(yp, bmHeight);
            }
            if (xp >= 0 && yp >= 0 && xp < bmWidth && yp < bmHeight) {
                spanBuffer[x] = bitmapValuebitsatXy(bmFill, bits, xp, yp);
            }
            ds += dsX;
            dt += dtX;
            x++;
        }
    }

    /*
     * This is the inner loop for solid color fills with anti-aliasing. This loop has been unrolled
     * for speed and quality into three parts: a) copy all pixels that fall into the first full
     * pixel. b) copy aaLevel pixels between the first and the last full pixel c) copy all pixels
     * that fall in the last full pixel
     */

    /* BalloonEngineBase>>#fillColorSpanAA:x0:x1: */
    private void fillColorSpanAAx0x1(final int pixelValue32, final int leftX, final int rightX) {
        final int aaLevel;
        final int baseShift;
        final int colorMask;
        final int firstPixel;
        int idx;
        final int lastPixel;
        int x;

        /* Not now -- maybe later */
        /* Compute the pixel boundaries. */
        firstPixel = aaFirstPixelFromto(leftX, rightX);
        lastPixel = aaLastPixelFromto(leftX, rightX);
        aaLevel = aaLevelGet();
        baseShift = aaShiftGet();
        /* Part a: Deal with the first n sub-pixels */
        x = leftX;
        if (x < firstPixel) {
            final int pv32 = shr(pixelValue32 & aaColorMaskGet(), aaColorShiftGet());
            while (x < firstPixel) {
                idx = shr(x, baseShift);
                spanBuffer[idx] = spanBuffer[idx] + pv32;
                x++;
            }
        }
        if (x < lastPixel) {
            colorMask = shr(aaColorMaskGet(), aaShiftGet()) | 0xF0F0F0F0;
            final int pv32 = shr(pixelValue32 & colorMask, aaShiftGet());
            while (x < lastPixel) {
                idx = shr(x, baseShift);
                spanBuffer[idx] = spanBuffer[idx] + pv32;
                x += aaLevel;
            }
        }
        if (x < rightX) {
            final int pv32 = shr(pixelValue32 & aaColorMaskGet(), aaColorShiftGet());
            while (x < rightX) {
                idx = shr(x, baseShift);
                spanBuffer[idx] = spanBuffer[idx] + pv32;
                x++;
            }
        }
    }

    /*
     * Fill the span buffer between leftEdge and rightEdge with the given pixel value.
     */

    /* BalloonEngineBase>>#fillColorSpan:from:to: */
    private void fillColorSpanfromto(final int pixelValue32, final int leftX, final int rightX) {
        /* Use a unrolled version for anti-aliased fills... */
        if (aaLevelGet() != 1) {
            fillColorSpanAAx0x1(pixelValue32, leftX, rightX);
            return;
        }
        int x0 = leftX;
        /* Unroll the inner loop four times, since we're only storing data. */
        final int x1 = rightX;
        while (x0 + 4 < x1) {
            spanBuffer[x0] = pixelValue32;
            spanBuffer[x0 + 1] = pixelValue32;
            spanBuffer[x0 + 2] = pixelValue32;
            spanBuffer[x0 + 3] = pixelValue32;
            x0 += 4;
        }
        while (x0 < x1) {
            spanBuffer[x0] = pixelValue32;
            x0++;
        }
    }

    /* BalloonEnginePlugin>>#fillDirectionXOf: */
    private int fillDirectionXOf(final int fill) {
        return objat(fill, GF_DIRECTION_X);
    }

    /* BalloonEnginePlugin>>#fillDirectionXOf:put: */
    private void fillDirectionXOfput(final int fill, final int value) {
        objatput(fill, GF_DIRECTION_X, value);
    }

    /* BalloonEnginePlugin>>#fillDirectionYOf: */
    private int fillDirectionYOf(final int fill) {
        return objat(fill, GF_DIRECTION_Y);
    }

    /* BalloonEnginePlugin>>#fillDirectionYOf:put: */
    private void fillDirectionYOfput(final int fill, final int value) {
        objatput(fill, GF_DIRECTION_Y, value);
    }

    /* BalloonEnginePlugin>>#fillLinearGradient */
    private void fillLinearGradient() {
        fillLinearGradientfromtoat(lastExportedFillGet(), lastExportedLeftXGet(), lastExportedRightXGet(), currentYGet());
    }

    /* This is the AA version of linear gradient filling. */

    /* BalloonEnginePlugin>>#fillLinearGradientAA:ramp:ds:dsX:from:to: */
    private int fillLinearGradientAArampdsdsXfromto(final int fill, final int rampPtr, final int deltaS, final int dsX, final int leftX, final int rightX) {
        final int aaLevel;
        final int baseShift;
        int colorMask;
        int colorShift;
        int ds;
        final int firstPixel;
        int idx;
        final int lastPixel;
        int rampIndex;
        final int rampSize;
        int x;

        aaLevel = aaLevelGet();
        baseShift = aaShiftGet();
        rampSize = gradientRampLengthOf(fill);
        ds = deltaS;
        x = leftX;
        rampIndex = ds / 65536;
        firstPixel = aaFirstPixelFromto(leftX, rightX);

        /* Deal with the first n sub-pixels */
        lastPixel = aaLastPixelFromto(leftX, rightX);
        colorMask = aaColorMaskGet();
        colorShift = aaColorShiftGet();
        while (x < firstPixel && rampIndex < rampSize && rampIndex >= 0) {
            int rampValue = unsignedAt(rampPtr + rampIndex);
            /* Copy as many pixels as possible */
            rampValue = shr(rampValue & colorMask, colorShift);
            while (x < firstPixel && ds / 65536 == rampIndex) {
                idx = shr(x, baseShift);
                spanBuffer[idx] = spanBuffer[idx] + rampValue;
                x++;
                ds += dsX;
            }
            rampIndex = ds / 65536;
        }
        colorMask = aaColorMaskGet() >> aaShiftGet() | 0xF0F0F0F0;
        colorShift = aaShiftGet();
        while (x < lastPixel && rampIndex < rampSize && rampIndex >= 0) {
            int rampValue = unsignedAt(rampPtr + rampIndex);
            /* Copy as many pixels as possible */
            rampValue = shr(rampValue & colorMask, colorShift);
            while (x < lastPixel && ds / 65536 == rampIndex) {
                idx = shr(x, baseShift);
                spanBuffer[idx] = spanBuffer[idx] + rampValue;
                x += aaLevel;
                ds += shl(dsX, colorShift);
            }
            rampIndex = ds / 65536;
        }
        colorMask = aaColorMaskGet();
        colorShift = aaColorShiftGet();
        while (x < rightX && rampIndex < rampSize && rampIndex >= 0) {
            int rampValue = unsignedAt(rampPtr + rampIndex);
            /* Copy as many pixels as possible */
            rampValue = shr(rampValue & colorMask, colorShift);
            while (x < rightX && ds / 65536 == rampIndex) {
                idx = shr(x, baseShift);
                spanBuffer[idx] = spanBuffer[idx] + rampValue;
                x++;
                ds += dsX;
            }
            rampIndex = ds / 65536;
        }
        return x;
    }

    /* Draw a linear gradient fill. */

    /* BalloonEnginePlugin>>#fillLinearGradient:from:to:at: */
    private void fillLinearGradientfromtoat(final int fill, final int leftX, final int rightX, final int yValue) {
        int ds;
        final int dsX;
        final int rampPtr;
        int rampIndex;
        final int rampSize;
        int x;
        final int x0;
        final int x1;

        rampPtr = gradientRampIndexOf(fill);
        rampSize = gradientRampLengthOf(fill);
        dsX = fillDirectionXOf(fill);
        ds = (leftX - fillOriginXOf(fill)) * dsX + (yValue - fillOriginYOf(fill)) * fillDirectionYOf(fill);
        x = x0 = leftX;
        /* Note: The inner loop has been divided into three parts for speed */
        /* Part one: Fill everything outside the left boundary */
        x1 = rightX;
        while (((rampIndex = ds / 65536) < 0 || rampIndex >= rampSize) && x < x1) {
            x++;
            ds += dsX;
        }
        if (x > x0) {
            if (rampIndex < 0) {
                rampIndex = 0;
            }
            if (rampIndex >= rampSize) {
                rampIndex = rampSize - 1;
            }
            fillColorSpanfromto(workBuffer[rampPtr + rampIndex], x0, x);
        }
        if (aaLevelGet() == 1) {
            /* Fast version w/o anti-aliasing */
            while ((rampIndex = ds / 65536) < rampSize && rampIndex >= 0 && x < x1) {
                spanBuffer[x] = unsignedAt(rampPtr + rampIndex);
                x++;
                ds += dsX;
            }
        } else {
            x = fillLinearGradientAArampdsdsXfromto(fill, rampPtr, ds, dsX, x, rightX);
        }
        if (x < x1) {
            if (rampIndex < 0) {
                rampIndex = 0;
            }
            if (rampIndex >= rampSize) {
                rampIndex = rampSize - 1;
            }
            fillColorSpanfromto(workBuffer[rampPtr + rampIndex], x, x1);
        }
    }

    /* BalloonEngineBase>>#fillMaxXGet */
    private int fillMaxXGet() {
        return workBuffer[GW_FILL_MAX_X];
    }

    /* BalloonEngineBase>>#fillMaxXPut: */
    private void fillMaxXPut(final int value) {
        workBuffer[GW_FILL_MAX_X] = value;
    }

    /* BalloonEngineBase>>#fillMaxYGet */
    private int fillMaxYGet() {
        return workBuffer[GW_FILL_MAX_Y];
    }

    /* BalloonEngineBase>>#fillMaxYPut: */
    private void fillMaxYPut(final int value) {
        workBuffer[GW_FILL_MAX_Y] = value;
    }

    /* BalloonEngineBase>>#fillMinXGet */
    private int fillMinXGet() {
        return workBuffer[GW_FILL_MIN_X];
    }

    /* BalloonEngineBase>>#fillMinXPut: */
    private void fillMinXPut(final int value) {
        workBuffer[GW_FILL_MIN_X] = value;
    }

    /* BalloonEngineBase>>#fillMinYGet */
    private int fillMinYGet() {
        return workBuffer[GW_FILL_MIN_Y];
    }

    /* BalloonEngineBase>>#fillMinYPut: */
    private void fillMinYPut(final int value) {
        workBuffer[GW_FILL_MIN_Y] = value;
    }

    /* BalloonEnginePlugin>>#fillNormalXOf: */
    private int fillNormalXOf(final int fill) {
        return objat(fill, GF_NORMAL_X);
    }

    /* BalloonEnginePlugin>>#fillNormalXOf:put: */
    private void fillNormalXOfput(final int fill, final int value) {
        objatput(fill, GF_NORMAL_X, value);
    }

    /* BalloonEnginePlugin>>#fillNormalYOf: */
    private int fillNormalYOf(final int fill) {
        return objat(fill, GF_NORMAL_Y);
    }

    /* BalloonEnginePlugin>>#fillNormalYOf:put: */
    private void fillNormalYOfput(final int fill, final int value) {
        objatput(fill, GF_NORMAL_Y, value);
    }

    /* BalloonEngineBase>>#fillOffsetXGet */
    @SuppressWarnings("unused")
    private int fillOffsetXGet() {
        return workBuffer[GW_FILL_OFFSET_X];
    }

    /* BalloonEngineBase>>#fillOffsetXPut: */
    @SuppressWarnings("unused")
    private int fillOffsetXPut(final int value) {
        return workBuffer[GW_FILL_OFFSET_X] = value;
    }

    /* BalloonEngineBase>>#fillOffsetYGet */
    @SuppressWarnings("unused")
    private int fillOffsetYGet() {
        return workBuffer[GW_FILL_OFFSET_Y];
    }

    /* BalloonEngineBase>>#fillOffsetYPut: */
    @SuppressWarnings("unused")
    private int fillOffsetYPut(final int value) {
        return workBuffer[GW_FILL_OFFSET_Y] = value;
    }

    /* BalloonEnginePlugin>>#fillOriginXOf: */
    private int fillOriginXOf(final int fill) {
        return objat(fill, GF_ORIGIN_X);
    }

    /* BalloonEnginePlugin>>#fillOriginXOf:put: */
    private void fillOriginXOfput(final int fill, final int value) {
        objatput(fill, GF_ORIGIN_X, value);
    }

    /* BalloonEnginePlugin>>#fillOriginYOf: */
    private int fillOriginYOf(final int fill) {
        return objat(fill, GF_ORIGIN_Y);
    }

    /* BalloonEnginePlugin>>#fillOriginYOf:put: */
    private void fillOriginYOfput(final int fill, final int value) {
        objatput(fill, GF_ORIGIN_Y, value);
    }

    /* Part 2a) Compute the decreasing part of the ramp */

    /* BalloonEnginePlugin>>#fillRadialDecreasingAA:ramp:deltaST:dsX:dtX:from:to: */
    private int fillRadialDecreasingAArampdeltaSTdsXdtXfromto(final int fill, final int rampPtr, final int dsX, final int dtX, final int leftX, final int rightX) {
        final int aaLevel;
        final int baseShift;
        int colorMask;
        int colorShift;
        int ds;
        int dt;
        final int firstPixel;
        int index;
        final int lastPixel;
        int length2;
        int nextLength;
        int rampIndex;
        int x;
        int x1;

        ds = point1GetX();
        dt = point1GetY();
        aaLevel = aaLevelGet();
        baseShift = aaShiftGet();
        rampIndex = accurateLengthOfwith(ds / 65536, dt / 65536);
        length2 = (rampIndex - 1) * (rampIndex - 1);
        x = leftX;
        x1 = fillOriginXOf(fill);
        if (x1 > rightX) {
            x1 = rightX;
        }
        firstPixel = aaFirstPixelFromto(leftX, x1);

        /* Deal with the first n sub-pixels */
        lastPixel = aaLastPixelFromto(leftX, x1);
        if (x < firstPixel) {
            colorMask = aaColorMaskGet();
            colorShift = aaColorShiftGet();
            int rampValue = unsignedAt(rampPtr + rampIndex);
            rampValue = shr(rampValue & colorMask, colorShift);
            while (x < firstPixel) {
                /* Try to copy the current value more than just once */
                while (x < firstPixel && squaredLengthOfwith(ds / 65536, dt / 65536) >= length2) {
                    index = shr(x, baseShift);
                    spanBuffer[index] = spanBuffer[index] + rampValue;
                    x++;
                    ds += dsX;
                    dt += dtX;
                }
                nextLength = squaredLengthOfwith(ds / 65536, dt / 65536);
                while (nextLength < length2) {
                    rampIndex--;
                    rampValue = unsignedAt(rampPtr + rampIndex);
                    rampValue = shr(rampValue & colorMask, colorShift);
                    length2 = (rampIndex - 1) * (rampIndex - 1);
                }
            }
        }
        if (x < lastPixel) {
            colorMask = shr(aaColorMaskGet(), aaShiftGet()) | 0xF0F0F0F0;
            colorShift = aaShiftGet();
            int rampValue = unsignedAt(rampPtr + rampIndex);
            rampValue = shr(rampValue & colorMask, colorShift);
            while (x < lastPixel) {
                /* Try to copy the current value more than just once */
                while (x < lastPixel && squaredLengthOfwith(ds / 65536, dt / 65536) >= length2) {
                    index = shr(x, baseShift);
                    spanBuffer[index] = spanBuffer[index] + rampValue;
                    x += aaLevel;
                    ds += shl(dsX, colorShift);
                    dt += shl(dtX, colorShift);
                }
                nextLength = squaredLengthOfwith(ds / 65536, dt / 65536);
                while (nextLength < length2) {
                    rampIndex--;
                    rampValue = unsignedAt(rampPtr + rampIndex);
                    rampValue = shr(rampValue & colorMask, colorShift);
                    length2 = (rampIndex - 1) * (rampIndex - 1);
                }
            }
        }
        if (x < x1) {
            colorMask = aaColorMaskGet();
            colorShift = aaColorShiftGet();
            int rampValue = unsignedAt(rampPtr + rampIndex);
            rampValue = shr(rampValue & colorMask, colorShift);
            while (x < x1) {
                /* Try to copy the current value more than just once */
                while (x < x1 && squaredLengthOfwith(ds / 65536, dt / 65536) >= length2) {
                    index = shr(x, baseShift);
                    spanBuffer[index] = spanBuffer[index] + rampValue;
                    x++;
                    ds += dsX;
                    dt += dtX;
                }
                nextLength = squaredLengthOfwith(ds / 65536, dt / 65536);
                while (nextLength < length2) {
                    rampIndex--;
                    rampValue = unsignedAt(rampPtr + rampIndex);
                    rampValue = shr(rampValue & colorMask, colorShift);
                    length2 = (rampIndex - 1) * (rampIndex - 1);
                }
            }
        }
        point1SetX(ds);
        point1SetY(dt);
        return x;
    }

    /* Part 2a) Compute the decreasing part of the ramp */

    /* BalloonEnginePlugin>>#fillRadialDecreasing:ramp:deltaST:dsX:dtX:from:to: */
    private int fillRadialDecreasingrampdeltaSTdsXdtXfromto(final int fill, final int rampPtr, final int dsX, final int dtX, final int leftX, final int rightX) {
        int ds;
        int dt;
        int length2;
        int nextLength;
        int rampIndex;
        int rampValue;
        int x;
        int x1;

        ds = point1GetX();
        dt = point1GetY();
        rampIndex = accurateLengthOfwith(ds / 65536, dt / 65536);
        rampValue = unsignedAt(rampPtr + rampIndex);
        length2 = (rampIndex - 1) * (rampIndex - 1);
        x = leftX;
        x1 = rightX;
        if (x1 > fillOriginXOf(fill)) {
            x1 = fillOriginXOf(fill);
        }
        while (x < x1) {
            /* Try to copy the current value more than just once */
            while (x < x1 && squaredLengthOfwith(ds / 65536, dt / 65536) >= length2) {
                spanBuffer[x] = rampValue;
                x++;
                ds += dsX;
                dt += dtX;
            }
            nextLength = squaredLengthOfwith(ds / 65536, dt / 65536);
            while (nextLength < length2) {
                rampIndex--;
                rampValue = unsignedAt(rampPtr + rampIndex);
                length2 = (rampIndex - 1) * (rampIndex - 1);
            }
        }
        point1SetX(ds);
        point1SetY(dt);
        return x;
    }

    /* BalloonEnginePlugin>>#fillRadialGradient */
    private void fillRadialGradient() {
        fillRadialGradientfromtoat(lastExportedFillGet(), lastExportedLeftXGet(), lastExportedRightXGet(), currentYGet());
    }

    /* Draw a radial gradient fill. */

    /* BalloonEnginePlugin>>#fillRadialGradient:from:to:at: */
    private void fillRadialGradientfromtoat(final int fill, final int leftX, final int rightX, final int yValue) {
        final int deltaX;
        final int deltaY;
        int ds;
        final int dsX;
        int dt;
        final int dtX;
        final int length2;
        final int rampPtr;
        final int rampSize;
        int x;
        final int x1;

        rampPtr = gradientRampIndexOf(fill);
        rampSize = gradientRampLengthOf(fill);
        deltaX = leftX - fillOriginXOf(fill);
        deltaY = yValue - fillOriginYOf(fill);
        dsX = fillDirectionXOf(fill);
        dtX = fillNormalXOf(fill);
        ds = deltaX * dsX + deltaY * fillDirectionYOf(fill);
        dt = deltaX * dtX + deltaY * fillNormalYOf(fill);
        x = leftX;

        /* Note: The inner loop has been divided into three parts for speed */
        /* Part one: Fill everything outside the left boundary */
        x1 = rightX;
        /* This is the upper bound */
        length2 = (rampSize - 1) * (rampSize - 1);
        while (squaredLengthOfwith(ds / 65536, dt / 65536) >= length2 && x < x1) {
            x++;
            ds += dsX;
            dt += dtX;
        }
        if (x > leftX) {
            fillColorSpanfromto(workBuffer[rampPtr + rampSize - 1], leftX, x);
        }
        point1SetX(ds);
        point1SetY(dt);
        if (x < fillOriginXOf(fill)) {
            /* Draw the decreasing part */
            if (aaLevelGet() == 1) {
                x = fillRadialDecreasingrampdeltaSTdsXdtXfromto(fill, rampPtr, dsX, dtX, x, x1);
            } else {
                x = fillRadialDecreasingAArampdeltaSTdsXdtXfromto(fill, rampPtr, dsX, dtX, x, x1);
            }
        }
        if (x < x1) {
            /* Draw the increasing part */
            if (aaLevelGet() == 1) {
                x = fillRadialIncreasingrampdeltaSTdsXdtXfromto(fill, rampPtr, dsX, dtX, x, x1);
            } else {
                x = fillRadialIncreasingAArampdeltaSTdsXdtXfromto(fill, rampPtr, dsX, dtX, x, x1);
            }
        }
        if (x < rightX) {
            fillColorSpanfromto(workBuffer[rampPtr + rampSize - 1], x, rightX);
        }
    }

    /* Part 2b) Compute the increasing part of the ramp */

    /* BalloonEnginePlugin>>#fillRadialIncreasingAA:ramp:deltaST:dsX:dtX:from:to: */
    private int fillRadialIncreasingAArampdeltaSTdsXdtXfromto(final int fill, final int rampPtr, final int dsX, final int dtX, final int leftX, final int rightX) {
        final int aaLevel;
        final int baseShift;
        int colorMask;
        int colorShift;
        int ds;
        int dt;
        final int firstPixel;
        int index;
        int lastLength;
        final int lastPixel;
        final int length2;
        int nextLength;
        int rampIndex;
        final int rampSize;
        int x;

        ds = point1GetX();
        dt = point1GetY();
        aaLevel = aaLevelGet();
        baseShift = aaShiftGet();
        rampIndex = accurateLengthOfwith(ds / 65536, dt / 65536);
        rampSize = gradientRampLengthOf(fill);
        /* This is the upper bound */
        length2 = (rampSize - 1) * (rampSize - 1);
        nextLength = (rampIndex + 1) * (rampIndex + 1);
        lastLength = squaredLengthOfwith(ds / 65536, dt / 65536);
        x = leftX;
        firstPixel = aaFirstPixelFromto(leftX, rightX);
        /* Deal with the first n subPixels */
        lastPixel = aaLastPixelFromto(leftX, rightX);
        if (x < firstPixel && lastLength < length2) {
            colorMask = aaColorMaskGet();
            colorShift = aaColorShiftGet();
            int rampValue = unsignedAt(rampPtr + rampIndex);
            rampValue = shr(rampValue & colorMask, colorShift);
            while (x < firstPixel && lastLength < length2) {
                /* Try to copy the current value more than once */
                while (x < firstPixel && squaredLengthOfwith(ds / 65536, dt / 65536) <= nextLength) {
                    index = shr(x, baseShift);
                    spanBuffer[index] = spanBuffer[index] + rampValue;
                    x++;
                    ds += dsX;
                    dt += dtX;
                }
                lastLength = squaredLengthOfwith(ds / 65536, dt / 65536);
                while (lastLength > nextLength) {
                    rampIndex++;
                    rampValue = unsignedAt(rampPtr + rampIndex);
                    rampValue = shr(rampValue & colorMask, colorShift);
                    nextLength = (rampIndex + 1) * (rampIndex + 1);
                }
            }
        }
        if (x < lastPixel && lastLength < length2) {
            colorMask = shr(aaColorMaskGet(), aaShiftGet()) | 0xF0F0F0F0;
            colorShift = aaShiftGet();
            int rampValue = unsignedAt(rampPtr + rampIndex);
            rampValue = shr(rampValue & colorMask, colorShift);
            while (x < lastPixel && lastLength < length2) {
                /* Try to copy the current value more than once */
                while (x < lastPixel && squaredLengthOfwith(ds / 65536, dt / 65536) <= nextLength) {
                    index = shr(x, baseShift);
                    spanBuffer[index] = spanBuffer[index] + rampValue;
                    x += aaLevel;
                    ds += dsX << colorShift;
                    dt += dtX << colorShift;
                }
                lastLength = squaredLengthOfwith(ds / 65536, dt / 65536);
                while (lastLength > nextLength) {
                    rampIndex++;
                    rampValue = unsignedAt(rampPtr + rampIndex);
                    rampValue = shr(rampValue & colorMask, colorShift);
                    nextLength = (rampIndex + 1) * (rampIndex + 1);
                }
            }
        }
        if (x < rightX && lastLength < length2) {
            colorMask = aaColorMaskGet();
            colorShift = aaColorShiftGet();
            int rampValue = unsignedAt(rampPtr + rampIndex);
            rampValue = shr(rampValue & colorMask, colorShift);
            while (x < rightX && lastLength < length2) {
                /* Try to copy the current value more than once */
                while (x < rightX && squaredLengthOfwith(ds / 65536, dt / 65536) <= nextLength) {
                    index = shr(x, baseShift);
                    spanBuffer[index] = spanBuffer[index] + rampValue;
                    x++;
                    ds += dsX;
                    dt += dtX;
                }
                lastLength = squaredLengthOfwith(ds / 65536, dt / 65536);
                while (lastLength > nextLength) {
                    rampIndex++;
                    rampValue = unsignedAt(rampPtr + rampIndex);
                    rampValue = shr(rampValue & colorMask, colorShift);
                    nextLength = (rampIndex + 1) * (rampIndex + 1);
                }
            }
        }
        point1SetX(ds);
        point1SetY(dt);
        return x;
    }

    /* Part 2b) Compute the increasing part of the ramp */

    /* BalloonEnginePlugin>>#fillRadialIncreasing:ramp:deltaST:dsX:dtX:from:to: */
    private int fillRadialIncreasingrampdeltaSTdsXdtXfromto(final int fill, final int rampPtr, final int dsX, final int dtX, final int leftX, final int rightX) {
        int ds;
        int dt;
        int lastLength;
        final int length2;
        int nextLength;
        int rampIndex;
        final int rampSize;
        int x;
        final int x1;

        ds = point1GetX();
        dt = point1GetY();
        rampIndex = accurateLengthOfwith(ds / 65536, dt / 65536);
        int rampValue = unsignedAt(rampPtr + rampIndex);
        rampSize = gradientRampLengthOf(fill);

        /* This is the upper bound */
        length2 = (rampSize - 1) * (rampSize - 1);
        nextLength = (rampIndex + 1) * (rampIndex + 1);
        lastLength = squaredLengthOfwith(ds / 65536, dt / 65536);
        x = leftX;
        x1 = rightX;
        while (x < x1 && lastLength < length2) {
            /* Try to copy the current value more than once */
            while (x < x1 && squaredLengthOfwith(ds / 65536, dt / 65536) <= nextLength) {
                spanBuffer[x] = rampValue;
                x++;
                ds += dsX;
                dt += dtX;
            }
            lastLength = squaredLengthOfwith(ds / 65536, dt / 65536);
            while (lastLength > nextLength) {
                rampIndex++;
                rampValue = unsignedAt(rampPtr + rampIndex);
                nextLength = (rampIndex + 1) * (rampIndex + 1);
            }
        }
        point1SetX(ds);
        point1SetY(dt);
        return x;
    }

    /* Return true if fillEntry1 should be drawn before fillEntry2 */

    /* BalloonEngineBase>>#fillSorts:before: */
    private boolean fillSortsbefore(final int fillEntry1, final int fillEntry2) {
        /* First check the depth value */
        final int diff = stackFillDepth(fillEntry1) - stackFillDepth(fillEntry2);
        if (diff != 0) {
            return diff > 0;
        }
        return makeUnsignedFrom(stackFillValue(fillEntry1)) < makeUnsignedFrom(stackFillValue(fillEntry2));
    }

    /*
     * Fill the span buffer from leftX to rightX with the given fill. Clip before performing any
     * operations. Return true if the fill must be handled by some Smalltalk code.
     */

    /* BalloonEngineBase>>#fillSpan:from:to: */
    private boolean fillSpanfromto(final int fill, final int leftX, final int rightX) {
        if (fill == 0) {
            return false;
        }
        int x0;
        int x1;
        x0 = Math.max(leftX, spanEndAAGet());
        x1 = Math.min(rightX, shl(spanSizeGet(), aaShiftGet()));
        if (x0 < fillMinXGet()) {
            x0 = fillMinXGet();
        }
        if (x1 > fillMaxXGet()) {
            x1 = fillMaxXGet();
        }
        if (x0 < spanStartGet()) {
            spanStartPut(x0);
        }
        if (x1 > spanEndGet()) {
            spanEndPut(x1);
        }
        if (x1 > spanEndAAGet()) {
            spanEndAAPut(x1);
        }
        if (x0 >= x1) {
            return false;
        }
        if (isFillColor(fill)) {
            fillColorSpanfromto(fill, x0, x1);
        } else {
            /* Store the values for the dispatch */
            lastExportedFillPut(fill);
            lastExportedLeftXPut(x0);
            lastExportedRightXPut(x1);
            final int type = fillTypeOf(fill);
            if (type <= 1) {
                return true;
            }
            switch (type) {
                case 0, 1 -> errorWrongIndex();
                case 2 -> fillLinearGradient();
                case 3 -> fillRadialGradient();
                case 4, 5 -> fillBitmapSpan();
            }
        }
        return false;
    }

    /* BalloonEngineBase>>#fillTypeOf: */
    private int fillTypeOf(final int fill) {
        return (objectTypeOf(fill) & GE_PRIMITIVE_FILL_MASK) >>> 8;
    }

    /* BalloonEngineBase>>#findNextAETEdgeFrom: -> has no senders */

    /*
     * Check the global edge table for any entries that cannot be handled by the engine itself. If
     * there are any, return true. Otherwise, initialize the the edge and add it to the AET
     */

    /* BalloonEngineBase>>#findNextExternalEntryFromGET */
    private boolean findNextExternalEntryFromGET() {
        int edge;
        int type;
        final int yValue;

        /* As long as we have entries in the GET */
        yValue = currentYGet();
        while (getStartGet() < getUsedGet()) {
            edge = getBuffer(getStartGet());
            if (edgeYValueOf(edge) > yValue) {
                return false;
            }
            type = objectTypeOf(edge);
            if ((type & GE_PRIMITIVE_WIDE_MASK) == GE_PRIMITIVE_EDGE) {
                return true;
            }
            if (!needAvailableSpace(1)) {
                return false;
            }
            switch (type) {
                case 0, 1, 2, 3 -> errorWrongIndex();
                case 4 -> stepToFirstLine();
                case 5 -> stepToFirstWideLine();
                case 6 -> stepToFirstBezier();
                case 7 -> stepToFirstWideBezier();
            }
            insertEdgeIntoAET(edge);
            getStartPut(getStartGet() + 1);
        }
        return false;
    }

    /*
     * Scan the active edge table. If there is any fill that cannot be handled by the engine itself,
     * return true. Otherwise handle the fills and return false.
     */
    /*
     * self currentYGet >= 680 ifTrue:[ self printAET. self halt. ].
     */

    /* BalloonEngineBase>>#findNextExternalFillFromAET */
    private boolean findNextExternalFillFromAET() {
        int leftEdge;
        int leftX;
        int rightEdge;
        int rightX = fillMaxXGet();

        while (aetStartGet() < aetUsedGet()) {
            /*
             * TODO: We should check if leftX from last operation is greater than leftX from next
             * edge. Currently, we rely here on spanEndAA from the span buffer fill.
             */
            leftEdge = aetBuffer(aetStartGet());
            leftX = rightX = edgeXValueOf(leftEdge);
            if (leftX >= fillMaxXGet()) {
                return false;
            }
            quickRemoveInvalidFillsAt(leftX);
            if (isWide(leftEdge)) {
                toggleWideFillOf(leftEdge);
            }
            if (areEdgeFillsValid(leftEdge)) {
                toggleFillsOf(leftEdge);
                if (engineStopped) {
                    return false;
                }
            }
            aetStartPut(aetStartGet() + 1);
            if (aetStartGet() < aetUsedGet()) {
                rightEdge = aetBuffer(aetStartGet());
                rightX = edgeXValueOf(rightEdge);
                if (rightX >= fillMinXGet()) {
                    /* This is the visible portion */
                    fillAllFromto(leftX, rightX);
                }
            }
        }
        if (rightX < fillMaxXGet()) {
            fillAllFromto(rightX, fillMaxXGet());
        }
        return false;
    }

    /*
     * Check the active edge table for any entries that cannot be handled by the engine itself. If
     * there are any, return true. Otherwise, step the the edge to the next y value.
     */

    /* BalloonEngineBase>>#findNextExternalUpdateFromAET */
    private boolean findNextExternalUpdateFromAET() {
        int count;
        int edge;
        int type;

        while (aetStartGet() < aetUsedGet()) {
            edge = aetBuffer(aetStartGet());
            count = edgeNumLinesOf(edge) - 1;
            if (count == 0) {
                /* Edge at end -- remove it */
                removeFirstAETEntry();
            } else {
                /* Store remaining lines back */
                edgeNumLinesOfput(edge, count);
                type = objectTypeOf(edge);
                if ((type & GE_PRIMITIVE_WIDE_MASK) == GE_PRIMITIVE_EDGE) {
                    return true;
                }
                switch (type) {
                    case 0, 1, 2, 3 -> errorWrongIndex();
                    case 4 -> stepToNextLine();
                    case 5 -> stepToNextWideLine();
                    case 6 -> stepToNextBezier();
                    case 7 -> stepToNextWideBezier();
                    default -> throw SqueakException.create("Unexpected type:", type);
                }
                resortFirstAETEntry();
                aetStartPut(aetStartGet() + 1);
            }
        }
        return false;
    }

    /* BalloonEngineBase>>#findStackFill:depth: */
    private int findStackFilldepth(final int fillIndex, final int depth) {
        int index = 0;
        while (index < stackFillSize() && (stackFillValue(index) != fillIndex || stackFillDepth(index) != depth)) {
            index += stackFillEntryLength();
        }
        if (index >= stackFillSize()) {
            return -1;
        } else {
            return index;
        }
    }

    /* Return true if processing is finished */

    /* BalloonEngineBase>>#finishedProcessing */
    private boolean finishedProcessing() {
        return stateGet() == GE_STATE_COMPLETED;
    }

    /* BalloonEngineBase>>#firstPointListGet */
    @SuppressWarnings("unused")
    private int firstPointListGet() {
        return workBuffer[GW_POINT_LIST_FIRST];
    }

    /* BalloonEngineBase>>#firstPointListPut: */
    @SuppressWarnings("unused")
    private int firstPointListPut(final int value) {
        return workBuffer[GW_POINT_LIST_FIRST] = value;
    }

    /* BalloonEngineBase>>#freeStackFillEntry */
    private void freeStackFillEntry() {
        wbStackPop(stackFillEntryLength());
    }

    /*
     * Note: This is hardcoded so it can be run from Squeak. The module name is used for validating
     * a module *after* it is loaded to check if it does really contain the module we're thinking it
     * contains. This is important!
     */

    /* InterpreterPlugin>>#getModuleName */
    public static String getModuleName() {
        return MODULE_NAME;
    }

    /* Return true if the edge at index i should sort before the edge at index j. */

    /* BalloonEngineBase>>#getSorts:before: */
    private boolean getSortsbefore(final int edge1, final int edge2) {
        if (edge1 == edge2) {
            return true;
        }
        final int diff = edgeYValueOf(edge1) - edgeYValueOf(edge2);
        if (diff != 0) {
            return diff < 0;
        }
        return edgeXValueOf(edge1) - edgeXValueOf(edge2) < 0;
    }

    /* BalloonEngineBase>>#getStartGet */
    private int getStartGet() {
        return workBuffer[GW_GET_START];
    }

    /* BalloonEngineBase>>#getStartPut: */
    private void getStartPut(final int value) {
        workBuffer[GW_GET_START] = value;
    }

    /* BalloonEngineBase>>#getUsedGet */
    private int getUsedGet() {
        return workBuffer[GW_GET_USED];
    }

    /* BalloonEngineBase>>#getUsedPut: */
    private void getUsedPut(final int value) {
        workBuffer[GW_GET_USED] = value;
    }

    /* BalloonEnginePlugin>>#gradientRampLengthOf: */
    private int gradientRampLengthOf(final int fill) {
        return objat(fill, GF_RAMP_LENGTH);
    }

    /* BalloonEnginePlugin>>#gradientRampLengthOf:put: */
    private void gradientRampLengthOfput(final int fill, final int value) {
        objatput(fill, GF_RAMP_LENGTH, value);
    }

    /* BalloonEnginePlugin>>#gradientRampOf: */
    private int gradientRampIndexOf(final int fill) {
        return objBufferIndex + fill + GF_RAMP_OFFSET;
    }

    /* BalloonEngineBase>>#hasColorTransform */
    private boolean hasColorTransform() {
        return hasColorTransformGet() != 0;
    }

    /* BalloonEngineBase>>#hasColorTransformGet */
    private int hasColorTransformGet() {
        return workBuffer[GW_HAS_COLOR_TRANSFORM];
    }

    /* BalloonEngineBase>>#hasColorTransformPut: */
    private void hasColorTransformPut(final int value) {
        workBuffer[GW_HAS_COLOR_TRANSFORM] = value;
    }

    /* BalloonEngineBase>>#hasEdgeTransform */
    private boolean hasEdgeTransform() {
        return hasEdgeTransformGet() != 0;
    }

    /* BalloonEngineBase>>#hasEdgeTransformGet */
    private int hasEdgeTransformGet() {
        return workBuffer[GW_HAS_EDGE_TRANSFORM];
    }

    /* BalloonEngineBase>>#hasEdgeTransformPut: */
    private void hasEdgeTransformPut(final int value) {
        workBuffer[GW_HAS_EDGE_TRANSFORM] = value;
    }

    /* Make the fill style with the given index invisible */

    /* BalloonEngineBase>>#hideFill:depth: */
    private boolean hideFilldepth(final int fillIndex, final int depth) {
        int index = findStackFilldepth(fillIndex, depth);
        if (index == -1) {
            return false;
        }
        if (index == 0) {
            freeStackFillEntry();
            return true;
        }
        stackFillValueput(index, stackFillValue(0));
        stackFillDepthput(index, stackFillDepth(0));
        stackFillRightXput(index, stackFillRightX(0));
        freeStackFillEntry();
        if (stackFillSize() <= stackFillEntryLength()) {
            return true;
        }
        int newTopIndex = 0;
        index = stackFillEntryLength();
        while (index < stackFillSize()) {
            if (fillSortsbefore(index, newTopIndex)) {
                newTopIndex = index;
            }
            index += stackFillEntryLength();
        }
        if (newTopIndex + stackFillEntryLength() == stackFillSize()) {
            return true;
        }
        final int newTop = stackFillValue(newTopIndex);
        stackFillValueput(newTopIndex, topFillValue());
        topFillValuePut(newTop);
        final int newDepth = stackFillDepth(newTopIndex);
        stackFillDepthput(newTopIndex, topFillDepth());
        topFillDepthPut(newDepth);
        final int newRightX = stackFillRightX(newTopIndex);
        stackFillRightXput(newTopIndex, topFillRightX());
        topFillRightXPut(newRightX);
        return true;
    }

    /* BalloonEngineBase>>#incrementPoint:by: */
    @SuppressWarnings("unused")
    private static void incrementPointby(final int[] point, final int delta) {
        point[0] = point[0] + delta;
        point[1] = point[1] + delta;
    }

    /* BalloonEngineBase>>#incrementStat:by: */
    private void incrementStatby(final int statIndex, final long value) {
        workBuffer[statIndex] = workBuffer[statIndex] + (int) value;
    }

    /* Find insertion point for the given edge in the AET */

    /* BalloonEngineBase>>#indexForInsertingIntoAET: */
    private int indexForInsertingIntoAET(final int edge) {
        int index;
        final int initialX;

        initialX = edgeXValueOf(edge);
        index = 0;
        while (index < aetUsedGet() && edgeXValueOf(aetBuffer(index)) < initialX) {
            index++;
        }
        while (index < aetUsedGet() && edgeXValueOf(aetBuffer(index)) == initialX && getSortsbefore(aetBuffer(index), edge)) {
            index++;
        }
        return index;
    }

    /* BalloonEngineBase>>#initColorTransform */
    private void initColorTransform() {
        colorTransformSet(0, 1.0f);
        colorTransformSet(1, 0.0f);
        colorTransformSet(2, 1.0f);
        colorTransformSet(3, 0.0f);
        colorTransformSet(4, 1.0f);
        colorTransformSet(5, 0.0f);
        colorTransformSet(6, 1.0f);
        colorTransformSet(7, 0.0f);
        hasColorTransformPut(0);
    }

    /* BalloonEngineBase>>#initEdgeTransform */
    private void initEdgeTransform() {
        edgeTransformSet(0, 1.0f);
        edgeTransformSet(1, 0.0f);
        edgeTransformSet(2, 0.0f);
        edgeTransformSet(3, 0.0f);
        edgeTransformSet(4, 1.0f);
        edgeTransformSet(5, 0.0f);
        hasEdgeTransformPut(0);
    }

    /* BalloonEngineBase>>#initialiseModule omitted */

    /*
     * Initialization stuff that needs to be done before any processing can take place.
     */
    /* Make sure aaLevel is initialized */

    /* BalloonEngineBase>>#initializeGETProcessing */
    private void initializeGETProcessing() {
        setAALevel(aaLevelGet());
        if (clipMinXGet() < 0) {
            clipMinXPut(0);
        }
        if (clipMaxXGet() > spanSizeGet()) {
            clipMaxXPut(spanSizeGet());
        }
        fillMinXPut(shl(clipMinXGet(), aaShiftGet()));
        fillMinYPut(shl(clipMinYGet(), aaShiftGet()));
        fillMaxXPut(shl(clipMaxXGet(), aaShiftGet()));
        fillMaxYPut(shl(clipMaxYGet(), aaShiftGet()));
        getUsedPut(0);
        aetUsedPut(0);
        getBufferIndex = objBufferIndex + objUsed;
        /* Create the global edge table */
        aetBufferIndex = objBufferIndex + objUsed;
        createGlobalEdgeTable();
        if (engineStopped) {
            return;
        }
        if (getUsedGet() == 0) {
            /* Nothing to do */
            currentYPut(fillMaxYGet());
            return;
        }
        sortGlobalEdgeTable();
        currentYPut(edgeYValueOf(getBuffer(0)));
        if (currentYGet() < fillMinYGet()) {
            currentYPut(fillMinYGet());
        }
        spanStartPut(0);
        spanEndPut(shl(spanSizeGet(), aaShiftGet()) - 1);
        clearSpanBuffer();
    }

    /*
     * Insert the edge with the given index from the global edge table into the active edge table.
     * The edge has already been stepped to the initial yValue -- thus remainingLines and rasterX
     * are both set.
     */

    /* BalloonEngineBase>>#insertEdgeIntoAET: */
    private void insertEdgeIntoAET(final int edge) {
        /* Check for the number of lines remaining */
        if (edgeNumLinesOf(edge) <= 0) {
            return;
        }

        /* And insert edge */
        final int index = indexForInsertingIntoAET(edge);
        insertToAETbeforeIndex(edge, index);
    }

    /* Insert the given edge into the AET. */

    /* BalloonEngineBase>>#insertToAET:beforeIndex: */
    private void insertToAETbeforeIndex(final int edge, final int index) {
        /* Make sure we have space in the AET */
        if (!allocateAETEntry(1)) {
            return;
        }
        int i = aetUsedGet() - 1;
        while (i >= index) {
            aetBuffer(i + 1, aetBuffer(i));
            i--;
        }
        aetBuffer(index, edge);
        aetUsedPut(aetUsedGet() + 1);
    }

    /* BalloonEnginePlugin>>#isBezier: */
    private boolean isBezier(final int bezier) {
        return (objectTypeOf(bezier) & GE_PRIMITIVE_WIDE_MASK) == GE_PRIMITIVE_BEZIER;
    }

    /* BalloonEngineBase>>#isEdge: */
    private boolean isEdge(final int edge) {
        final int type;

        type = objectTypeOf(edge);
        if (type > GE_PRIMITIVE_EDGE_MASK) {
            return false;
        }
        return (objectTypeOf(edge) & GE_PRIMITIVE_EDGE_MASK) != 0;
    }

    /* BalloonEngineBase>>#isFillColor: */
    private static boolean isFillColor(final int fill) {
        return (makeUnsignedFrom(fill) & 0xFF000000L) != 0;
    }

    /* BalloonEnginePlugin>>#isFillOkay: */
    private boolean isFillOkay(final int fill) {
        return fill == 0 || isFillColor(fill) || isObject(fill) && isFill(fill);
    }

    /* BalloonEngineBase>>#isFill: */
    private boolean isFill(final int fill) {
        return isFillColor(fill) || isRealFill(fill);
    }

    /* BalloonEnginePlugin>>#isLine: */
    private boolean isLine(final int line) {
        return (objectTypeOf(line) & GE_PRIMITIVE_WIDE_MASK) == GE_PRIMITIVE_LINE;
    }

    /* BalloonEngineBase>>#isObject: */
    private boolean isObject(final int obj) {
        return obj >= 0 && obj < objUsed;
    }

    /* BalloonEngineBase>>#isRealFill: */
    private boolean isRealFill(final int fill) {
        return (objectTypeOf(fill) & GE_PRIMITIVE_FILL_MASK) != 0;
    }

    /* BalloonEngineBase>>#isStackEntry: */
    @SuppressWarnings("unused")
    private boolean isStackEntry(final int entry) {
        return entry >= wbTopGet() && entry < wbSizeGet();
    }

    /* BalloonEngineBase>>#isStackIndex: */
    @SuppressWarnings("unused")
    private boolean isStackIndex(final int index) {
        return index >= 0 && index < wbStackSize();
    }

    /* BalloonEnginePlugin>>#isWideBezier: */
    @SuppressWarnings("unused")
    private boolean isWideBezier(final int bezier) {
        return isBezier(bezier) && isWide(bezier);
    }

    /* BalloonEnginePlugin>>#isWideLine: */
    @SuppressWarnings("unused")
    private boolean isWideLine(final int line) {
        return isLine(line) && isWide(line);
    }

    /* BalloonEngineBase>>#isWide: */
    private boolean isWide(final int object) {
        return (objectTypeOf(object) & GE_PRIMITIVE_WIDE) != 0;
    }

    /* BalloonEngineBase>>#lastExportedEdgeGet */
    private int lastExportedEdgeGet() {
        return workBuffer[GW_LAST_EXPORTED_EDGE];
    }

    /* BalloonEngineBase>>#lastExportedEdgePut: */
    private void lastExportedEdgePut(final int value) {
        workBuffer[GW_LAST_EXPORTED_EDGE] = value;
    }

    /* BalloonEngineBase>>#lastExportedFillGet */
    private int lastExportedFillGet() {
        return workBuffer[GW_LAST_EXPORTED_FILL];
    }

    /* BalloonEngineBase>>#lastExportedFillPut: */
    private void lastExportedFillPut(final int value) {
        workBuffer[GW_LAST_EXPORTED_FILL] = value;
    }

    /* BalloonEngineBase>>#lastExportedLeftXGet */
    private int lastExportedLeftXGet() {
        return workBuffer[GW_LAST_EXPORTED_LEFT_X];
    }

    /* BalloonEngineBase>>#lastExportedLeftXPut: */
    private void lastExportedLeftXPut(final int value) {
        workBuffer[GW_LAST_EXPORTED_LEFT_X] = value;
    }

    /* BalloonEngineBase>>#lastExportedRightXGet */
    private int lastExportedRightXGet() {
        return workBuffer[GW_LAST_EXPORTED_RIGHT_X];
    }

    /* BalloonEngineBase>>#lastExportedRightXPut: */
    private void lastExportedRightXPut(final int value) {
        workBuffer[GW_LAST_EXPORTED_RIGHT_X] = value;
    }

    /* BalloonEnginePlugin>>#lineEndXOf: */
    private int lineEndXOf(final int line) {
        return objat(line, GL_END_X);
    }

    /* BalloonEnginePlugin>>#lineEndXOf:put: */
    private void lineEndXOfput(final int line, final int value) {
        objatput(line, GL_END_X, value);
    }

    /* BalloonEnginePlugin>>#lineEndYOf: */
    private int lineEndYOf(final int line) {
        return objat(line, GL_END_Y);
    }

    /* BalloonEnginePlugin>>#lineEndYOf:put: */
    private void lineEndYOfput(final int line, final int value) {
        objatput(line, GL_END_Y, value);
    }

    /* BalloonEnginePlugin>>#lineErrorAdjDownOf: */
    private int lineErrorAdjDownOf(final int line) {
        return objat(line, GL_ERROR_ADJ_DOWN);
    }

    /* BalloonEnginePlugin>>#lineErrorAdjDownOf:put: */
    private void lineErrorAdjDownOfput(final int line, final int value) {
        objatput(line, GL_ERROR_ADJ_DOWN, value);
    }

    /* BalloonEnginePlugin>>#lineErrorAdjUpOf: */
    private int lineErrorAdjUpOf(final int line) {
        return objat(line, GL_ERROR_ADJ_UP);
    }

    /* BalloonEnginePlugin>>#lineErrorAdjUpOf:put: */
    private void lineErrorAdjUpOfput(final int line, final int value) {
        objatput(line, GL_ERROR_ADJ_UP, value);
    }

    /* BalloonEnginePlugin>>#lineErrorOf: */
    private int lineErrorOf(final int line) {
        return objat(line, GL_ERROR);
    }

    /* BalloonEnginePlugin>>#lineErrorOf:put: */
    private void lineErrorOfput(final int line, final int value) {
        objatput(line, GL_ERROR, value);
    }

    /* BalloonEnginePlugin>>#lineXDirectionOf: */
    private int lineXDirectionOf(final int line) {
        return objat(line, GL_X_DIRECTION);
    }

    /* BalloonEnginePlugin>>#lineXDirectionOf:put: */
    private void lineXDirectionOfput(final int line, final int value) {
        objatput(line, GL_X_DIRECTION, value);
    }

    /* BalloonEnginePlugin>>#lineXIncrementOf: */
    private int lineXIncrementOf(final int line) {
        return objat(line, GL_X_INCREMENT);
    }

    /* BalloonEnginePlugin>>#lineXIncrementOf:put: */
    private void lineXIncrementOfput(final int line, final int value) {
        objatput(line, GL_X_INCREMENT, value);
    }

    /* BalloonEnginePlugin>>#lineYDirectionOf: */
    @SuppressWarnings("unused")
    private int lineYDirectionOf(final int line) {
        return objat(line, GL_Y_DIRECTION);
    }

    /* BalloonEnginePlugin>>#lineYDirectionOf:put: */
    private void lineYDirectionOfput(final int line, final int value) {
        objatput(line, GL_Y_DIRECTION, value);
    }

    /*
     * Load and subdivide the bezier curve from point1/point2/point3. If wideFlag is set then make
     * sure the curve is monoton in X.
     */

    /* BalloonEnginePlugin>>#loadAndSubdivideBezierFrom:via:to:isWide: */
    private int loadAndSubdivideBezierFromviatoisWide(final boolean wideFlag) {
        final int bz1 = allocateBezierStackEntry();
        if (engineStopped) {
            return 0;
        }
        bzStartXput(bz1, point1GetX());
        bzStartYput(bz1, point1GetY());
        bzViaXput(bz1, point2GetX());
        bzViaYput(bz1, point2GetY());
        bzEndXput(bz1, point3GetX());
        bzEndYput(bz1, point3GetY());
        int index2 = subdivideToBeMonotoninX(bz1, wideFlag);
        final int bz2 = index2;
        for (int index = bz1; index <= bz2; index += 6) {
            final int index1 = subdivideBezierFrom(index);
            if (index1 > index2) {
                index2 = index1;
            }
            if (engineStopped) {
                return 0;
            }
        }
        return div(index2, 6);
    }

    /* BalloonEnginePlugin>>#loadArrayPolygon:nPoints:fill:lineWidth:lineFill: */
    private void loadArrayPolygonnPointsfilllineWidthlineFill(final ArrayObject points, final int nPoints, final int fillIndex, final int lineWidth, final int lineFill) {
        loadPointfrom(GW_POINT_1, fetchPointerofObject(0, points));
        if (failed()) {
            return;
        }
        int x0 = point1GetX();
        int y0 = point1GetY();
        for (int i = 1; i < nPoints; i++) {
            loadPointfrom(GW_POINT_1, fetchPointerofObject(i, points));
            if (failed()) {
                return;
            }
            final int x1 = point1GetX();
            final int y1 = point1GetY();
            point1SetX(x0);
            point1SetY(y0);
            point2SetX(x1);
            point2SetY(y1);
            transformPoints(2);
            loadWideLinefromtolineFillleftFillrightFill(lineWidth, GW_POINT_1, GW_POINT_2, lineFill, fillIndex, 0);
            if (engineStopped) {
                return;
            }
            x0 = x1;
            y0 = y1;
        }
    }

    /* BalloonEnginePlugin>>#loadArrayShape:nSegments:fill:lineWidth:lineFill: */
    private void loadArrayShapenSegmentsfilllineWidthlineFill(final ArrayObject points, final int nSegments, final int fillIndex, final int lineWidth, final int lineFill) {
        PointersObject pointOop;
        int segs;
        int x0;
        int x1;
        int x2;
        int y0;
        int y1;
        int y2;

        for (int i = 0; i < nSegments; i++) {
            pointOop = fetchPointerofObject(i * 3, points);
            loadPointfrom(GW_POINT_1, pointOop);
            pointOop = fetchPointerofObject(i * 3 + 1, points);
            loadPointfrom(GW_POINT_2, pointOop);
            pointOop = fetchPointerofObject(i * 3 + 2, points);
            loadPointfrom(GW_POINT_3, pointOop);
            if (failed()) {
                return;
            }
            transformPoints(3);
            x0 = point1GetX();
            y0 = point1GetY();
            x1 = point2GetX();
            y1 = point2GetY();
            x2 = point3GetX();
            /* Check if we can use a line */
            y2 = point3GetY();
            if (x0 == y0 && x1 == y1 || x1 == x2 && y1 == y2) {
                loadWideLinefromtolineFillleftFillrightFill(lineWidth, GW_POINT_1, GW_POINT_3, lineFill, fillIndex, 0);
            } else {
                /* Need bezier */
                segs = loadAndSubdivideBezierFromviatoisWide(lineWidth != 0 && lineFill != 0);
                if (engineStopped) {
                    return;
                }
                loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, fillIndex, 0, segs);
            }
            if (engineStopped) {
                return;
            }
        }
    }

    /* Load a transformation from the given array. */

    /* BalloonEngineBase>>#loadArrayTransformFrom:into:length: */
    private void loadArrayTransformFromintolength(final ArrayObject transformOop, final int destPtr, final int n) {
        for (int i = 0; i < n; i++) {
            final Object value = transformOop.getObjectStorage()[i];
            workbufferAtput(destPtr + i, toInt(value));
        }
    }

    /* Initialize the bezier segment stored on the stack */

    /* BalloonEnginePlugin>>#loadBezier:segment:leftFill:rightFill:offset: */
    private void loadBeziersegmentleftFillrightFilloffset(final int bezier, final int index, final int leftFillIndex, final int rightFillIndex, final int yOffset) {
        if (bzEndY(index) >= bzStartY(index)) {
            /* Top to bottom */
            edgeXValueOfput(bezier, bzStartX(index));
            edgeYValueOfput(bezier, bzStartY(index) - yOffset);
            bezierViaXOfput(bezier, bzViaX(index));
            bezierViaYOfput(bezier, bzViaY(index) - yOffset);
            bezierEndXOfput(bezier, bzEndX(index));
            bezierEndYOfput(bezier, bzEndY(index) - yOffset);
        } else {
            edgeXValueOfput(bezier, bzEndX(index));
            edgeYValueOfput(bezier, bzEndY(index) - yOffset);
            bezierViaXOfput(bezier, bzViaX(index));
            bezierViaYOfput(bezier, bzViaY(index) - yOffset);
            bezierEndXOfput(bezier, bzStartX(index));
            bezierEndYOfput(bezier, bzStartY(index) - yOffset);
        }
        edgeZValueOfput(bezier, currentZGet());
        edgeLeftFillOfput(bezier, leftFillIndex);
        edgeRightFillOfput(bezier, rightFillIndex);
    }

    /* BalloonEngineBase>>#loadBitBltFrom: */
    private boolean loadBitBltFrom(final PointersObject bbObj) {
        return image.bitblt.loadBitBltFrom(bbObj);
    }

    /* Load the bitmap fill. */

    /* BalloonEnginePlugin>>#loadBitmapFill:colormap:tile:from:along:normal:xIndex: */
    private int loadBitmapFillcolormaptilefromalongnormalxIndex(final PointersObject formOop, final AbstractSqueakObject cmOop, final boolean tileFlag, final int xIndex) {
        final NativeObject bmBits;
        final int bmBitsSize;
        final int bmDepth;
        final int bmFill;
        final int bmHeight;
        final int bmRaster;
        final int bmWidth;
        final int[] cmBits;
        final int cmSize;
        final int ppw;

        if (cmOop == NilObject.SINGLETON) {
            cmSize = 0;
            cmBits = null;
        } else {
            if (!isBitmap((AbstractSqueakObjectWithClassAndHash) cmOop)) {
                throw PrimitiveFailed.andTransferToInterpreter();
            }
            cmBits = ((NativeObject) cmOop).getIntStorage();
            cmSize = cmBits.length;
        }
        if (!isPointers(formOop)) {
            throw PrimitiveFailed.andTransferToInterpreter();
        }
        if (slotSizeOf(formOop) < 5) {
            throw PrimitiveFailed.andTransferToInterpreter();
        }
        bmBits = fetchNativeofObject(0, formOop);
        if (!isBitmap(bmBits)) {
            throw PrimitiveFailed.andTransferToInterpreter();
        }
        bmBitsSize = slotSizeOf(bmBits);
        bmWidth = fetchIntegerofObject(1, formOop);
        bmHeight = fetchIntegerofObject(2, formOop);
        bmDepth = fetchIntegerofObject(3, formOop);
        assert !failed();
        if (!(bmWidth >= 0 && bmHeight >= 0)) {
            throw PrimitiveFailed.andTransferToInterpreter();
        }
        if (!(bmDepth == 32 || bmDepth == 8 || bmDepth == 16 || bmDepth == 1 || bmDepth == 2 || bmDepth == 4)) {
            throw PrimitiveFailed.andTransferToInterpreter();
        }
        if (!(cmSize == 0 || cmSize == 1L << bmDepth)) {
            throw PrimitiveFailed.andTransferToInterpreter();
        }
        ppw = div(32, bmDepth);
        bmRaster = div(bmWidth + ppw - 1, ppw);
        if (bmBitsSize != bmRaster * bmHeight) {
            throw PrimitiveFailed.andTransferToInterpreter();
        }
        bmFill = allocateBitmapFillcolormap(cmSize, cmBits);
        assert !engineStopped;
        bitmapWidthOfput(bmFill, bmWidth);
        bitmapHeightOfput(bmFill, bmHeight);
        bitmapDepthOfput(bmFill, bmDepth);
        bitmapRasterOfput(bmFill, bmRaster);
        bitmapSizeOfput(bmFill, bmBitsSize);
        bitmapTileFlagOfput(bmFill, tileFlag ? 1 : 0);
        objectIndexOfput(bmFill, xIndex);
        loadFillOrientationfromalongnormalwidthheight(bmFill, bmWidth, bmHeight);
        return bmFill;
    }

    /* Note: Assumes that the contents of formArray has been checked before */

    /* BalloonEnginePlugin>>#loadBitsFrom: */
    private int[] loadBitsFrom(final int bmFill) {
        final int xIndex = objectIndexOf(bmFill);
        if (xIndex > slotSizeOf(formArray)) {
            return null;
        }
        final PointersObject formOop = fetchPointerofObject(xIndex, formArray);
        final NativeObject bitsOop = fetchNativeofObject(0, formOop);
        final int[] words = bitsOop.getIntStorage();
        final int bitsLen = words.length;
        if (bitsLen != bitmapSizeOf(bmFill)) {
            return null;
        }
        return words;
    }

    /*
     * Load a 2x3 transformation matrix from the given oop. Return true if the matrix is not nil,
     * false otherwise
     */

    /* BalloonEngineBase>>#loadColorTransformFrom: */
    private void loadColorTransformFrom(final AbstractSqueakObject transformOop) {
        hasColorTransformPut(0);
        if (!loadTransformFromintolength(transformOop, GW_COLOR_TRANSFORM, 8)) {
            return;
        }
        hasColorTransformPut(1);
        colorTransformSet(1, colorTransformGet(1) * 256.0f);
        colorTransformSet(3, colorTransformGet(3) * 256.0f);
        colorTransformSet(5, colorTransformGet(5) * 256.0f);
        colorTransformSet(7, colorTransformGet(7) * 256.0f);
    }

    /* Load the compressed segment identified by segment index */

    /*
     * BalloonEnginePlugin>>#loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:
     * lineColor:
     */
    private void loadCompressedSegmentfromshortleftFillrightFilllineWidthlineColor(final int segmentIndex, final int[] points, final boolean pointsShort, final int leftFill,
                    final int rightFill, final int lineWidth, final int lineFill) {
        /* Check if have anything to do at all */
        if (leftFill == rightFill && (lineWidth == 0 || lineFill == 0)) {
            return;
        }
        /* 3 points with x/y each */
        final int index = segmentIndex * 6;
        final int x0;
        final int x1;
        final int x2;
        final int y0;
        final int y1;
        final int y2;
        if (pointsShort) {
            /* Load short points */
            x0 = loadPointShortAtfrom(index, points);
            y0 = loadPointShortAtfrom(index + 1, points);
            x1 = loadPointShortAtfrom(index + 2, points);
            y1 = loadPointShortAtfrom(index + 3, points);
            x2 = loadPointShortAtfrom(index + 4, points);
            y2 = loadPointShortAtfrom(index + 5, points);
        } else {
            x0 = loadPointIntAtfrom(index, points);
            y0 = loadPointIntAtfrom(index + 1, points);
            x1 = loadPointIntAtfrom(index + 2, points);
            y1 = loadPointIntAtfrom(index + 3, points);
            x2 = loadPointIntAtfrom(index + 4, points);
            y2 = loadPointIntAtfrom(index + 5, points);
        }
        if (x0 == x1 && y0 == y1 || x1 == x2 && y1 == y2) {
            /* We can use a line from x0/y0 to x2/y2 */
            if (x0 == x2 && y0 == y2) {
                return;
            }
            point1SetX(x0);
            point1SetY(y0);
            point2SetX(x2);
            point2SetY(y2);
            transformPoints(2);
            loadWideLinefromtolineFillleftFillrightFill(lineWidth, GW_POINT_1, GW_POINT_2, lineFill, leftFill, rightFill);
            return;
        }
        point1SetX(x0);
        point1SetY(y0);
        point2SetX(x1);
        point2SetY(y1);
        point3SetX(x2);
        point3SetY(y2);
        transformPoints(3);
        final int segs = loadAndSubdivideBezierFromviatoisWide(lineWidth != 0 && lineFill != 0);
        if (engineStopped) {
            return;
        }
        loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, leftFill, rightFill, segs);
    }

    /*
     * Load a compressed shape into the engine. WARNING: THIS METHOD NEEDS THE FULL FRAME SIZE!!!!
     */

    /*
     * BalloonEnginePlugin>>#loadCompressedShape:segments:leftFills:rightFills:lineWidths:lineFills:
     * fillIndexList:pointShort:
     */
    private void loadCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexListpointShort(final int[] points, final int nSegments, final int[] leftFills,
                    final int[] rightFills, final int[] lineWidths, final int[] lineFills, final int[] fillIndexList, final boolean pointsShort) {
        if (nSegments == 0) {
            return;
        }
        /* Initialize run length encodings */
        int leftRun = -1;
        int rightRun = -1;
        int widthRun = -1;
        int lineFillRun = -1;
        int leftLength = 1;
        int rightLength = 1;
        int widthLength = 1;
        int lineFillLength = 1;
        int leftValue = 0;
        int rightValue = 0;
        int widthValue = 0;
        int lineFillValue = 0;
        for (int i = 1; i <= nSegments; i++) {
            /* Decrement current run length and load new stuff */
            if (--leftLength <= 0) {
                leftRun++;
                leftLength = shortRunLengthAtfrom(leftRun, leftFills);
                leftValue = shortRunValueAtfrom(leftRun, leftFills);
                if (leftValue != 0) {
                    leftValue = fillIndexList[leftValue - 1];
                    leftValue = transformColor(leftValue);
                    if (engineStopped) {
                        return;
                    }
                }
            }
            if (--rightLength <= 0) {
                rightRun++;
                rightLength = shortRunLengthAtfrom(rightRun, rightFills);
                rightValue = shortRunValueAtfrom(rightRun, rightFills);
                if (rightValue != 0) {
                    rightValue = fillIndexList[rightValue - 1];
                    rightValue = transformColor(rightValue);
                }
            }
            if (--widthLength <= 0) {
                widthRun++;
                widthLength = shortRunLengthAtfrom(widthRun, lineWidths);
                widthValue = shortRunValueAtfrom(widthRun, lineWidths);
                if (widthValue != 0) {
                    widthValue = transformWidth(widthValue);
                }
            }
            if (--lineFillLength <= 0) {
                lineFillRun++;
                lineFillLength = shortRunLengthAtfrom(lineFillRun, lineFills);
                lineFillValue = shortRunValueAtfrom(lineFillRun, lineFills);
                if (lineFillValue != 0) {
                    lineFillValue = fillIndexList[lineFillValue - 1];
                }
            }
            loadCompressedSegmentfromshortleftFillrightFilllineWidthlineColor(i - 1, points, pointsShort, leftValue, rightValue, widthValue, lineFillValue);
            if (engineStopped) {
                return;
            }
        }
    }

    /* BalloonEngineBase>>#loadEdgeStateFrom: */
    private int loadEdgeStateFrom(final PointersObject edgeOop) {
        final int edge = lastExportedEdgeGet();
        if (slotSizeOf(edgeOop) < ET_BALLOON_EDGE_DATA_SIZE) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_EDGE_DATA_TOO_SMALL);
        }
        edgeXValueOfput(edge, fetchIntegerofObject(ET_X_VALUE_INDEX, edgeOop));
        edgeYValueOfput(edge, fetchIntegerofObject(ET_Y_VALUE_INDEX, edgeOop));
        edgeZValueOfput(edge, fetchIntegerofObject(ET_Z_VALUE_INDEX, edgeOop));
        edgeNumLinesOfput(edge, fetchIntegerofObject(ET_LINES_INDEX, edgeOop));
        return edge;
    }

    /*
     * Load a 2x3 transformation matrix from the given oop. Return true if the matrix is not nil,
     * false otherwise
     */

    /* BalloonEngineBase>>#loadEdgeTransformFrom: */
    private void loadEdgeTransformFrom(final AbstractSqueakObject transformOop) {
        hasEdgeTransformPut(0);
        final boolean okay = loadTransformFromintolength(transformOop, GW_EDGE_TRANSFORM, 6);
        assert !failed();
        if (!okay) {
            return;
        }
        hasEdgeTransformPut(1);
        edgeTransformSet(2, (float) (edgeTransformGet(2) + (double) destOffsetXGet()));
        edgeTransformSet(5, (float) (edgeTransformGet(5) + (double) destOffsetYGet()));
    }

    /* Transform the points */

    /* BalloonEnginePlugin>>#loadFillOrientation:from:along:normal:width:height: */
    private void loadFillOrientationfromalongnormalwidthheight(final int fill, final int fillWidth, final int fillHeight) {
        final int dirX;
        final int dirY;
        final int dsLength2;
        final int dsX;
        final int dsY;
        final int dtLength2;
        final int dtX;
        final int dtY;
        final int nrmX;
        final int nrmY;

        point2SetX(point2GetX() + point1GetX());
        point2SetY(point2GetY() + point1GetY());
        point3SetX(point3GetX() + point1GetX());
        point3SetY(point3GetY() + point1GetY());
        transformPoint(GW_POINT_1);
        transformPoint(GW_POINT_2);
        transformPoint(GW_POINT_3);
        dirX = point2GetX() - point1GetX();
        dirY = point2GetY() - point1GetY();
        nrmX = point3GetX() - point1GetX();
        nrmY = point3GetY() - point1GetY();
        /* Compute the scale from direction/normal into ramp size */
        dsLength2 = dirX * dirX + dirY * dirY;
        if (dsLength2 > 0) {
            dsX = (int) ((float) dirX * (float) fillWidth * 65536.0 / dsLength2);
            dsY = (int) ((float) dirY * (float) fillWidth * 65536.0 / dsLength2);
        } else {
            dsX = 0;
            dsY = 0;
        }
        dtLength2 = nrmX * nrmX + nrmY * nrmY;
        if (dtLength2 > 0) {
            dtX = (int) ((float) nrmX * (float) fillHeight * 65536.0 / dtLength2);
            dtY = (int) ((float) nrmY * (float) fillHeight * 65536.0 / dtLength2);
        } else {
            dtX = 0;
            dtY = 0;
        }
        fillOriginXOfput(fill, point1GetX());
        fillOriginYOfput(fill, point1GetY());
        fillDirectionXOfput(fill, dsX);
        fillDirectionYOfput(fill, dsY);
        fillNormalXOfput(fill, dtX);
        fillNormalYOfput(fill, dtY);
    }

    /* Check all the forms from arrayOop. */

    /* BalloonEngineBase>>#loadFormsFrom: */
    private boolean loadFormsFrom(final ArrayObject arrayOop) {
        NativeObject bmBits;
        int bmBitsSize;
        int bmDepth;
        int bmHeight;
        int bmRaster;
        int bmWidth;
        PointersObject formOop;
        int ppw;

        formArray = arrayOop;
        for (int i = 0, iLimiT = slotSizeOf(formArray) - 1; i <= iLimiT; i++) {
            formOop = fetchPointerofObject(i, formArray);
            if (!isPointers(formOop)) {
                return false;
            }
            if (slotSizeOf(formOop) < 5) {
                return false;
            }
            bmBits = fetchNativeofObject(0, formOop);
            if (!isBitmap(bmBits)) {
                return false;
            }
            bmBitsSize = slotSizeOf(bmBits);
            bmWidth = fetchIntegerofObject(1, formOop);
            bmHeight = fetchIntegerofObject(2, formOop);
            bmDepth = fetchIntegerofObject(3, formOop);
            if (failed()) {
                return false;
            }
            if (!(bmWidth >= 0 && bmHeight >= 0)) {
                return false;
            }
            ppw = div(32, bmDepth);
            bmRaster = div(bmWidth + ppw - 1, ppw);
            if (bmBitsSize != bmRaster * bmHeight) {
                return false;
            }
        }
        return true;
    }

    /* Load the gradient fill as defined by the color ramp. */

    /* BalloonEnginePlugin>>#loadGradientFill:from:along:normal:isRadial: */
    private int loadGradientFillfromalongnormalisRadial(final NativeObject rampOop, final boolean isRadial) {
        final int fill;
        final int rampWidth;

        assert isBitmap(rampOop);
        rampWidth = slotSizeOf(rampOop);
        fill = allocateGradientFillrampWidthisRadial(rampOop.getIntStorage(), rampWidth, isRadial);
        assert !engineStopped;
        loadFillOrientationfromalongnormalwidthheight(fill, rampWidth, rampWidth);
        return fill;
    }

    /* Load the line defined by point1 and point2. */

    /* BalloonEnginePlugin>>#loadLine:from:to:offset:leftFill:rightFill: */
    private void loadLinefromtooffsetleftFillrightFill(final int line, final int point1Index, final int point2Index, final int yOffset, final int leftFill, final int rightFill) {
        final int p1Index;
        final int p2Index;
        final int yDir;

        if (pointGetY(point1Index) <= pointGetY(point2Index)) {
            p1Index = point1Index;
            p2Index = point2Index;
            yDir = 1;
        } else {
            p1Index = point2Index;
            p2Index = point1Index;
            yDir = -1;
        }
        edgeXValueOfput(line, pointGetX(p1Index));
        edgeYValueOfput(line, pointGetY(p1Index) - yOffset);
        edgeZValueOfput(line, currentZGet());
        edgeLeftFillOfput(line, leftFill);
        edgeRightFillOfput(line, rightFill);
        lineEndXOfput(line, pointGetX(p2Index));
        lineEndYOfput(line, pointGetY(p2Index) - yOffset);
        lineYDirectionOfput(line, yDir);
    }

    /* BalloonEnginePlugin>>#loadOvalSegment:w:h:cx:cy: */
    private void loadOvalSegmentwhcxcy(final int seg, final int w, final int h, final int cx, final int cy) {
        final int x0;
        int x1;
        final int x2;
        final int y0;
        int y1;
        final int y2;

        /* Load start point of segment */
        x0 = (int) (CIRCLE_COS_TABLE[seg * 2] * w + cx);
        y0 = (int) (CIRCLE_SIN_TABLE[seg * 2] * h + cy);
        point1SetX(x0);
        point1SetY(y0);
        x2 = (int) (CIRCLE_COS_TABLE[seg * 2 + 2] * w + cx);
        y2 = (int) (CIRCLE_SIN_TABLE[seg * 2 + 2] * h + cy);
        point3SetX(x2);
        point3SetY(y2);
        x1 = (int) (CIRCLE_COS_TABLE[seg * 2 + 1] * w + cx);
        /*
         * NOTE: The intermediate point is the point ON the curve and not yet the control point
         * (which is OFF the curve)
         */
        y1 = (int) (CIRCLE_SIN_TABLE[seg * 2 + 1] * h + cy);
        x1 = x1 * 2 - (x0 + x2) / 2;
        y1 = y1 * 2 - (y0 + y2) / 2;
        point2SetX(x1);
        point2SetY(y1);
    }

    /* Load a rectangular oval currently defined by point1/point2 */

    /* BalloonEnginePlugin>>#loadOval:lineFill:leftFill:rightFill: */
    private void loadOvallineFillleftFillrightFill(final int lineWidth, final int lineFill, final int leftFill, final int rightFill) {
        final int cx;
        final int cy;
        final int h;
        int nSegments;
        final int w;

        w = (point2GetX() - point1GetX()) / 2;
        h = (point2GetY() - point1GetY()) / 2;
        cx = (point2GetX() + point1GetX()) / 2;
        cy = (point2GetY() + point1GetY()) / 2;
        for (int i = 0; i <= 15; i++) {
            loadOvalSegmentwhcxcy(i, w, h, cx, cy);
            transformPoints(3);
            nSegments = loadAndSubdivideBezierFromviatoisWide(lineWidth != 0 && lineFill != 0);
            if (engineStopped) {
                return;
            }
            loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, leftFill, rightFill, nSegments);
            if (engineStopped) {
                return;
            }
        }
    }

    /* Load the int value from the given index in intArray */

    /* BalloonEnginePlugin>>#loadPointIntAt:from: */
    private static int loadPointIntAtfrom(final int index, final int[] intArray) {
        return intArray[index];
    }

    /* Load the short value from the given index in shortArray */

    /* BalloonEnginePlugin>>#loadPointShortAt:from: */
    private static short loadPointShortAtfrom(final int index, final int[] shortArray) {
        final int value = shortArray[index / 2];
        if (index % 2 == 0) {
            return (short) value;
        } else {
            return (short) (value >> 16);
        }
    }

    /* Load the contents of pointOop into pointArray */

    /* BalloonEngineBase>>#loadPoint:from: */
    private void loadPointfrom(final int pointIndex, final PointersObject pointOop) {
        assert SqueakImageContext.getSlow().isPointClass(pointOop.getSqueakClass()) : "Not a point (VMMaker code lets primitive fail)";
        pointSetX(pointIndex, toInt(fetchObjectofObject(0, pointOop)));
        pointSetY(pointIndex, toInt(fetchObjectofObject(1, pointOop)));
    }

    /* BalloonEnginePlugin>>#loadPolygon:nPoints:fill:lineWidth:lineFill:pointsShort: */
    private void loadPolygonnPointsfilllineWidthlineFillpointsShort(final int[] points, final int nPoints, final int fillIndex, final int lineWidth, final int lineFill, final boolean isShort) {
        int x0;
        int x1;
        int y0;
        int y1;

        if (isShort) {
            x0 = loadPointShortAtfrom(0, points);
            y0 = loadPointShortAtfrom(1, points);
        } else {
            x0 = loadPointIntAtfrom(0, points);
            y0 = loadPointIntAtfrom(1, points);
        }
        for (int i = 1; i < nPoints; i++) {
            if (isShort) {
                x1 = loadPointShortAtfrom(i * 2, points);
                y1 = loadPointShortAtfrom(i * 2 + 1, points);
            } else {
                x1 = loadPointIntAtfrom(i * 2, points);
                y1 = loadPointIntAtfrom(i * 2 + 1, points);
            }
            point1SetX(x0);
            point1SetY(y0);
            point2SetX(x1);
            point2SetY(y1);
            transformPoints(2);
            loadWideLinefromtolineFillleftFillrightFill(lineWidth, GW_POINT_1, GW_POINT_2, lineFill, fillIndex, 0);
            if (engineStopped) {
                return;
            }
            x0 = x1;
            y0 = y1;
        }
    }

    /* Load a rectangle currently defined by point1-point4 */

    /* BalloonEnginePlugin>>#loadRectangle:lineFill:leftFill:rightFill: */
    private void loadRectanglelineFillleftFillrightFill(final int lineWidth, final int lineFill, final int leftFill, final int rightFill) {
        loadWideLinefromtolineFillleftFillrightFill(lineWidth, GW_POINT_1, GW_POINT_2, lineFill, leftFill, rightFill);
        loadWideLinefromtolineFillleftFillrightFill(lineWidth, GW_POINT_2, GW_POINT_3, lineFill, leftFill, rightFill);
        loadWideLinefromtolineFillleftFillrightFill(lineWidth, GW_POINT_3, GW_POINT_4, lineFill, leftFill, rightFill);
        loadWideLinefromtolineFillleftFillrightFill(lineWidth, GW_POINT_4, GW_POINT_1, lineFill, leftFill, rightFill);
    }

    /*
     * Load the entire state from the interpreter for the rendering primitives. Answer 0 on success
     * or a non-zero failure code on failure.
     */

    /* BalloonEngineBase>>#loadRenderingState */
    private int loadRenderingState(final PointersObject receiver, final PointersObject edgeOop, final PointersObject fillOop) {
        int failCode;
        if ((failCode = quickLoadEngineFrom(receiver)) != 0) {
            return failCode;
        }
        if ((failCode = loadSpanBufferFrom(fetchNativeofObject(BE_SPAN_INDEX, engine))) != 0) {
            return failCode;
        }
        if (!loadBitBltFrom(fetchPointerofObject(BE_BITBLT_INDEX, engine))) {
            return GEF_BITBLT_LOAD_FAILED;
        }
        if (!loadFormsFrom(fetchArrayofObject(BE_FORMS_INDEX, engine))) {
            return GEF_FORM_LOAD_FAILED;
        }
        if (slotSizeOf(edgeOop) < ET_BALLOON_EDGE_DATA_SIZE) {
            return GEF_EDGE_DATA_TOO_SMALL;
        }
        if (slotSizeOf(fillOop) < FT_BALLOON_FILL_DATA_SIZE) {
            return GEF_FILL_DATA_TOO_SMALL;
        }
        final int state = stateGet();
        if (state == GE_STATE_WAITING_FOR_EDGE || state == GE_STATE_WAITING_FOR_FILL || state == GE_STATE_WAITING_CHANGE) {
            return GEF_WRONG_STATE;
        }
        return 0;
    }

    /* BalloonEnginePlugin>>#loadShape:nSegments:fill:lineWidth:lineFill:pointsShort: */
    private void loadShapenSegmentsfilllineWidthlineFillpointsShort(final int[] points, final int nSegments, final int fillIndex, final int lineWidth, final int lineFill,
                    final boolean pointsShort) {
        for (int i = 1; i <= nSegments; i++) {
            loadCompressedSegmentfromshortleftFillrightFilllineWidthlineColor(i - 1, points, pointsShort, fillIndex, 0, lineWidth, lineFill);
            if (engineStopped) {
                return;
            }
        }
    }

    /*
     * Load the span buffer from the given oop. Answer 0 on success or a non-zero failure code on
     * failure.
     */

    /* BalloonEngineBase>>#loadSpanBufferFrom: */
    private int loadSpanBufferFrom(final NativeObject spanOop) {
        if (!isBitmap(spanOop)) {
            return GEF_CLASS_MISMATCH;
        }
        /* Leave last entry unused to avoid complications */
        spanBuffer = spanOop.getIntStorage();
        final int value = slotSizeOf(spanOop) - 1;
        spanSizePut(value);
        return 0;
    }

    /*
     * Load a transformation from transformOop into the float array defined by destPtr. The
     * transformation is assumed to be either an array or a FloatArray of length n.
     */

    /* BalloonEngineBase>>#loadTransformFrom:into:length: */
    private boolean loadTransformFromintolength(final AbstractSqueakObject transformOop, final int destPtr, final int n) {
        if (transformOop == NilObject.SINGLETON) {
            return false;
        }

        if (transformOop instanceof final NativeObject transformNative) {
            if (slotSizeOf(transformNative) != n) {
                throw PrimitiveFailed.andTransferToInterpreter();
            }
            loadWordTransformFromintolength(transformNative, destPtr, n);
        } else {
            final ArrayObject transformArray = (ArrayObject) transformOop;
            if (slotSizeOf(transformArray) != n) {
                throw PrimitiveFailed.andTransferToInterpreter();
            }
            loadArrayTransformFromintolength(transformArray, destPtr, n);
        }
        return true;
    }

    /*
     * Load the (possibly wide) bezier from the segments currently on the bezier stack.
     */

    /* BalloonEnginePlugin>>#loadWideBezier:lineFill:leftFill:rightFill:n: */
    private void loadWideBezierlineFillleftFillrightFilln(final int lineWidth, final int lineFill, final int leftFill, final int rightFill, final int nSegments) {
        int bezier;
        int index;
        final int offset;
        final boolean wide;

        if (lineWidth == 0 || lineFill == 0) {
            wide = false;
            offset = 0;
        } else {
            wide = true;
            offset = offsetFromWidth(lineWidth);
        }
        index = nSegments * 6;
        while (index > 0) {
            if (wide) {
                bezier = allocateWideBezier();
            } else {
                bezier = allocateBezier();
            }
            if (engineStopped) {
                return;
            }
            loadBeziersegmentleftFillrightFilloffset(bezier, index, leftFill, rightFill, offset);
            if (wide) {
                wideBezierFillOfput(bezier, lineFill);
                wideBezierWidthOfput(bezier, lineWidth);
                wideBezierExtentOfput(bezier, lineWidth);
            }
            index -= 6;
        }
        wbStackClear();
    }

    /* Load a (possibly wide) line defined by the points p1 and p2 */

    /* BalloonEnginePlugin>>#loadWideLine:from:to:lineFill:leftFill:rightFill: */
    private void loadWideLinefromtolineFillleftFillrightFill(final int lineWidth, final int point1Index, final int point2Index, final int lineFill, final int leftFill, final int rightFill) {
        final int line;
        final int offset;

        if (lineWidth == 0 || lineFill == 0) {
            line = allocateLine();
            offset = 0;
        } else {
            line = allocateWideLine();
            offset = offsetFromWidth(lineWidth);
        }
        if (engineStopped) {
            return;
        }
        loadLinefromtooffsetleftFillrightFill(line, point1Index, point2Index, offset, leftFill, rightFill);
        if (isWide(line)) {
            wideLineFillOfput(line, lineFill);
            wideLineWidthOfput(line, lineWidth);
            wideLineExtentOfput(line, lineWidth);
        }
    }

    /* Load a float array transformation from the given oop */

    /* BalloonEngineBase>>#loadWordTransformFrom:into:length: */
    private void loadWordTransformFromintolength(final NativeObject transformOop, final int destPtr, final int n) {
        final int[] srcPtr = transformOop.getIntStorage();
        for (int i = 0; i < n; i++) {
            workbufferAtput(destPtr + i, srcPtr[i]);
        }
    }

    /* Load the working buffer from the given oop */

    /* BalloonEngineBase>>#loadWorkBufferFrom: */
    private int loadWorkBufferFrom(final NativeObject wbOop) {
        if (!isWords(wbOop)) {
            return GEF_WORKBUFFER_IS_POINTERS;
        }
        if (slotSizeOf(wbOop) < GW_MINIMAL_SIZE) {
            return GEF_WORKBUFFER_TOO_SMALL;
        }
        workBufferPut(wbOop);
        if (magicNumberGet() != GW_MAGIC_NUMBER) {
            return GEF_WORKBUFFER_BADMAGIC;
        }
        if (wbSizeGet() != slotSizeOf(wbOop)) {
            return GEF_WORKBUFFER_WRONG_SIZE;
        }
        if (objStartGet() != GW_HEADER_SIZE) {
            return GEF_WORKBUFFER_START_WRONG;
        }
        objBufferIndex = objStartGet();
        getBufferIndex = objBufferIndex + objUsedGet();
        /* Make sure we don't exceed the work buffer */
        aetBufferIndex = getBufferIndex + getUsedGet();
        if (GW_HEADER_SIZE + objUsedGet() + getUsedGet() + aetUsedGet() > wbSizeGet()) {
            return GEF_WORK_TOO_BIG;
        }
        return 0;
    }

    /* BalloonEngineBase>>#magicNumberGet */
    private int magicNumberGet() {
        return workBuffer[GW_MAGIC_INDEX];
    }

    /* BalloonEngineBase>>#magicNumberPut: */
    private void magicNumberPut(final int value) {
        workBuffer[GW_MAGIC_INDEX] = value;
    }

    /* BalloonEnginePlugin>>#makeRectFromPoints */
    @SuppressWarnings("unused")
    private void makeRectFromPoints() {
        point2SetX(point3GetX());
        point2SetY(point1GetY());
        point4SetX(point1GetX());
        point4SetY(point3GetY());
    }

    /* BalloonEngineBase>>#makeUnsignedFrom: */
    private static int makeUnsignedFrom(final int someIntegerValue) {
        return someIntegerValue;
    }

    /* BalloonEngineBase>>#moduleUnloaded: omitted */

    /*
     * The entry at index is not in the right position of the AET. Move it to the left until the
     * position is okay.
     */

    /* BalloonEngineBase>>#moveAETEntryFrom:edge:x: */
    private void moveAETEntryFromedgex(final int index, final int edge, final int xValue) {
        int newIndex = index;
        while (newIndex > 0 && edgeXValueOf(aetBuffer(newIndex - 1)) > xValue) {
            aetBuffer(newIndex, aetBuffer(newIndex - 1));
            newIndex--;
        }
        aetBuffer(newIndex, edge);
    }

    /* Check if we have n slots available */

    /* BalloonEngineBase>>#needAvailableSpace: */
    private boolean needAvailableSpace(final int nSlots) {
        if (GW_HEADER_SIZE + objUsed + getUsedGet() + aetUsedGet() + nSlots > wbTopGet()) {
            stopBecauseOf(G_ERROR_NO_MORE_SPACE);
            return false;
        }
        return true;
    }

    /* BalloonEngineBase>>#needsFlush */
    private boolean needsFlush() {
        return needsFlushGet() != 0;
    }

    /* BalloonEngineBase>>#needsFlushGet */
    private int needsFlushGet() {
        return workBuffer[GW_NEEDS_FLUSH];
    }

    /* BalloonEngineBase>>#needsFlushPut: */
    private void needsFlushPut(final int value) {
        workBuffer[GW_NEEDS_FLUSH] = value;
    }

    /* BalloonEngineBase>>#objectHeaderOf: */
    private int objectHeaderOf(final int obj) {
        return makeUnsignedFrom(objat(obj, GE_OBJECT_TYPE));
    }

    /* BalloonEngineBase>>#objectIndexOf: */
    private int objectIndexOf(final int obj) {
        return objat(obj, GE_OBJECT_INDEX);
    }

    /* BalloonEngineBase>>#objectIndexOf:put: */
    private void objectIndexOfput(final int obj, final int value) {
        objatput(obj, GE_OBJECT_INDEX, value);
    }

    /* BalloonEngineBase>>#objectLengthOf: */
    private int objectLengthOf(final int obj) {
        return objat(obj, GE_OBJECT_LENGTH);
    }

    /* BalloonEngineBase>>#objectLengthOf:put: */
    private void objectLengthOfput(final int obj, final int value) {
        objatput(obj, GE_OBJECT_LENGTH, value);
    }

    /* BalloonEngineBase>>#objectTypeOf: */
    private int objectTypeOf(final int obj) {
        return makeUnsignedFrom(objat(obj, GE_OBJECT_TYPE)) & GE_PRIMITIVE_TYPE_MASK;
    }

    /* BalloonEngineBase>>#objectTypeOf:put: */
    private void objectTypeOfput(final int obj, final int value) {
        objatput(obj, GE_OBJECT_TYPE, value);
    }

    /* BalloonEngineBase>>#objStartGet */
    private int objStartGet() {
        return workBuffer[GW_OBJ_START];
    }

    /* BalloonEngineBase>>#objStartPut: */
    private void objStartPut(final int value) {
        workBuffer[GW_OBJ_START] = value;
    }

    /* BalloonEngineBase>>#objUsedGet */
    private int objUsedGet() {
        return workBuffer[GW_OBJ_USED];
    }

    /* BalloonEngineBase>>#objUsedPut: */
    private void objUsedPut(final int value) {
        workBuffer[GW_OBJ_USED] = value;
    }

    /* BalloonEngineBase>>#obj:at: */
    private int objat(final int object, final int index) {
        return workBuffer[objBufferIndex + object + index];
    }

    /* BalloonEngineBase>>#obj:at:put: */
    private void objatput(final int object, final int index, final int value) {
        workBuffer[objBufferIndex + object + index] = value;
    }

    /*
     * Common function so that we don't compute that wrong in any place and can easily find all the
     * places where we deal with one-pixel offsets.
     */

    /* BalloonEnginePlugin>>#offsetFromWidth: */
    private static int offsetFromWidth(final int lineWidth) {
        return lineWidth / 2;
    }

    /* Point helper */
    private int pointGetX(final int index) {
        return workBuffer[index];
    }

    private int pointGetY(final int index) {
        return workBuffer[index + 1];
    }

    private void pointSetX(final int index, final int value) {
        workBuffer[index] = value;
    }

    private void pointSetY(final int index, final int value) {
        workBuffer[index + 1] = value;
    }

    /* BalloonEngineBase>>#point1Get */
    private int point1GetX() {
        return workBuffer[GW_POINT_1];
    }

    private int point1GetY() {
        return workBuffer[GW_POINT_1 + 1];
    }

    private void point1SetX(final int value) {
        workBuffer[GW_POINT_1] = value;
    }

    private void point1SetY(final int value) {
        workBuffer[GW_POINT_1 + 1] = value;
    }

    /* BalloonEngineBase>>#point2Get */
    private int point2GetX() {
        return workBuffer[GW_POINT_2];
    }

    private int point2GetY() {
        return workBuffer[GW_POINT_2 + 1];
    }

    private void point2SetX(final int value) {
        workBuffer[GW_POINT_2] = value;
    }

    private void point2SetY(final int value) {
        workBuffer[GW_POINT_2 + 1] = value;
    }

    /* BalloonEngineBase>>#point3Get */
    private int point3GetX() {
        return workBuffer[GW_POINT_3];
    }

    private int point3GetY() {
        return workBuffer[GW_POINT_3 + 1];
    }

    private void point3SetX(final int value) {
        workBuffer[GW_POINT_3] = value;
    }

    private void point3SetY(final int value) {
        workBuffer[GW_POINT_3 + 1] = value;
    }

    /* BalloonEngineBase>>#point4Get not needed (using GW_POINT_4 directly) */

    private void point4SetX(final int value) {
        workBuffer[GW_POINT_4] = value;
    }

    private void point4SetY(final int value) {
        workBuffer[GW_POINT_4 + 1] = value;
    }

    /*
     * We have just blitted a scan line to the screen. Do whatever seems to be a good idea here.
     */
    /*
     * Note: In the future we may check the time needed for this scan line and interrupt processing
     * to give the Smalltalk code a chance to run at a certain time.
     */
    /* Check if there is any more work to do. */

    /* BalloonEngineBase>>#postDisplayAction */
    private void postDisplayAction() {
        if (getStartGet() >= getUsedGet() && aetUsedGet() == 0) {
            /* No more entries to process */
            statePut(GE_STATE_COMPLETED);
        }
        if (currentYGet() >= fillMaxYGet()) {
            /* Out of clipping range */
            statePut(GE_STATE_COMPLETED);
        }
    }

    /* BalloonEngineBase>>#primitiveAbortProcessing -> no senders */

    /* Note: No need to load either bitBlt or spanBuffer */

    /* BalloonEngineBase>>#primitiveAddActiveEdgeEntry */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveAddActiveEdgeEntry(final PointersObject receiver, final PointersObject edgeEntry) {
        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_WAITING_FOR_EDGE);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        final int edge = loadEdgeStateFrom(edgeEntry);
        if (!needAvailableSpace(1)) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WORK_TOO_BIG);
        }
        if (edgeNumLinesOf(edge) > 0) {
            insertEdgeIntoAET(edge);
        }
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        statePut(GE_STATE_ADDING_FROM_GET);
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GW_COUNT_ADD_AET_ENTRY, 1);
            incrementStatby(GW_TIME_ADD_AET_ENTRY, ioMicroMSecs() - geProfileTime);
        }
    }

    /* BalloonEnginePlugin>>#primitiveAddBezier */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveAddBezier(final PointersObject receiver, final PointersObject start, final PointersObject end, final PointersObject via, final int leftFillValue,
                    final int rightFillValue) {
        final int nSegments;
        int leftFill = leftFillValue;
        int rightFill = rightFillValue;

        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        if (!(isFillOkay(leftFill) && isFillOkay(rightFill))) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WRONG_FILL);
        }
        // if ((leftFill == rightFill) && false) {
        // return receiver;
        // }
        loadPointfrom(GW_POINT_1, start);
        loadPointfrom(GW_POINT_2, via);
        loadPointfrom(GW_POINT_3, end);
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(ERROR_TABLE.BAD_ARGUMENT.ordinal());
        }
        transformPoints(3);
        nSegments = loadAndSubdivideBezierFromviatoisWide(false);
        needAvailableSpace(nSegments * GB_BASE_SIZE);
        if (!engineStopped) {
            leftFill = transformColor(leftFill);
            rightFill = transformColor(rightFill);
        }
        if (!engineStopped) {
            loadWideBezierlineFillleftFillrightFilln(0, 0, leftFill, rightFill, nSegments);
        }
        if (engineStopped) {
            /* Make sure the stack is okay */
            wbStackClear();
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENTITY_LOAD_FAILED);
        }
        storeEngineStateInto(engine);
    }

    /* BalloonEnginePlugin>>#primitiveAddBezierShape */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveAddBezierShape(final PointersObject receiver, final AbstractSqueakObject points, final int nSegments, final int fillIndexValue, final int lineWidthValue,
                    final int lineFillValue) {
        final int length;
        final boolean pointsIsArray;
        final int segSize;
        int lineWidth = lineWidthValue;

        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        if (isWords(points)) {
            /* Either PointArray or ShortPointArray */
            pointsIsArray = false;
            length = slotSizeOf((NativeObject) points);
            if (!(length == nSegments * 3 || length == nSegments * 6)) {
                throw PrimitiveFailed.andTransferToInterpreter(ERROR_TABLE.BAD_ARGUMENT.ordinal());
            }
        } else {
            /* Must be Array of points */
            if (!isArray(points)) {
                throw PrimitiveFailed.andTransferToInterpreter(ERROR_TABLE.BAD_ARGUMENT.ordinal());
            }
            length = slotSizeOf((ArrayObject) points);
            if (length != nSegments * 3) {
                throw PrimitiveFailed.andTransferToInterpreter(ERROR_TABLE.BAD_ARGUMENT.ordinal());
            }
            pointsIsArray = true;
        }
        if (lineWidth == 0 || lineFillValue == 0) {
            segSize = GL_BASE_SIZE;
        } else {
            segSize = GL_WIDE_SIZE;
        }
        if (!needAvailableSpace(segSize * nSegments)) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WORK_TOO_BIG);
        }
        if (!(isFillOkay(lineFillValue) && isFillOkay(fillIndexValue))) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WRONG_FILL);
        }
        final int lineFill = transformColor(lineFillValue);
        final int fillIndex = transformColor(fillIndexValue);
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if ((lineFill == 0 || lineWidth == 0) && fillIndex == 0) {
            return;
        }
        if (lineWidth != 0) {
            lineWidth = transformWidth(lineWidth);
            if (lineWidth < 1) {
                lineWidth = 1;
            }
        }
        if (pointsIsArray) {
            loadArrayShapenSegmentsfilllineWidthlineFill((ArrayObject) points, nSegments, fillIndex, lineWidth, lineFill);
        } else {
            loadShapenSegmentsfilllineWidthlineFillpointsShort(((NativeObject) points).getIntStorage(), nSegments, fillIndex, lineWidth, lineFill, nSegments * 3 == length);
        }
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENTITY_LOAD_FAILED);
        }
        needsFlushPut(1);
        storeEngineStateInto(engine);
    }

    /* BalloonEnginePlugin>>#primitiveAddBitmapFill */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public long primitiveAddBitmapFill(final PointersObject receiver, final PointersObject formOop, final AbstractSqueakObject cmOop, final boolean tileFlag, final PointersObject origin,
                    final PointersObject direction, final PointersObject normal, final int xIndex) {
        final int fill;

        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        loadPointfrom(GW_POINT_1, origin);
        loadPointfrom(GW_POINT_2, direction);
        loadPointfrom(GW_POINT_3, normal);
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_BAD_POINT);
        }
        fill = loadBitmapFillcolormaptilefromalongnormalxIndex(formOop, cmOop, tileFlag, xIndex - 1);
        if (engineStopped) {
            /* Make sure the stack is okay */
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENTITY_LOAD_FAILED);
        }
        storeEngineStateInto(engine);
        return fill;
    }

    /* BalloonEnginePlugin>>#primitiveAddCompressedShape */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveAddCompressedShape(final PointersObject receiver, final NativeObject points, final int nSegments, final NativeObject leftFills,
                    final NativeObject rightFills, final NativeObject lineWidths, final NativeObject lineFills, final NativeObject fillIndexList) {
        final boolean pointsShort;

        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(ERROR_TABLE.BAD_ARGUMENT.ordinal());
        }
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        if (!checkCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexList(points, nSegments, leftFills, rightFills, lineWidths, lineFills, fillIndexList)) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENTITY_CHECK_FAILED);
        }
        if (!needAvailableSpace(GL_BASE_SIZE * nSegments)) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WORK_TOO_BIG);
        }

        /* Then actually load the compressed shape */
        pointsShort = slotSizeOf(points) == nSegments * 3;
        loadCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexListpointShort(points.getIntStorage(), nSegments, leftFills.getIntStorage(), rightFills.getIntStorage(),
                        lineWidths.getIntStorage(), lineFills.getIntStorage(), fillIndexList.getIntStorage(), pointsShort);
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENTITY_LOAD_FAILED);
        }
        needsFlushPut(1);
        storeEngineStateInto(engine);
    }

    /* BalloonEnginePlugin>>#primitiveAddGradientFill */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public long primitiveAddGradientFill(final PointersObject receiver, final NativeObject colorRamp, final PointersObject origin, final PointersObject direction, final PointersObject normal,
                    final boolean isRadial) {
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        loadPointfrom(GW_POINT_1, origin);
        loadPointfrom(GW_POINT_2, direction);
        loadPointfrom(GW_POINT_3, normal);
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_BAD_POINT);
        }
        final int fill = loadGradientFillfromalongnormalisRadial(colorRamp, isRadial);
        if (engineStopped) {
            /* Make sure the stack is okay */
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENTITY_LOAD_FAILED);
        }
        storeEngineStateInto(engine);
        return fill;
    }

    /* BalloonEnginePlugin>>#primitiveAddLine */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveAddLine(final PointersObject receiver, final PointersObject start, final PointersObject end, final int leftFillValue, final int rightFillValue) {
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        if (!(isFillOkay(leftFillValue) && isFillOkay(rightFillValue))) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WRONG_FILL);
        }
        loadPointfrom(GW_POINT_1, start);
        loadPointfrom(GW_POINT_2, end);
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_BAD_POINT);
        }
        transformPoints(2);
        final int leftFill = transformColor(leftFillValue);
        final int rightFill = transformColor(rightFillValue);
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        loadWideLinefromtolineFillleftFillrightFill(0, GW_POINT_1, GW_POINT_2, 0, leftFill, rightFill);
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENTITY_LOAD_FAILED);
        }
        storeEngineStateInto(engine);
    }

    /* BalloonEnginePlugin>>#primitiveAddOval */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveAddOval(final PointersObject receiver, final PointersObject start, final PointersObject end, final int fillIndexValue, final int borderWidthValue,
                    final int borderIndexValue) {
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        if (!(isFillOkay(borderIndexValue) && isFillOkay(fillIndexValue))) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WRONG_FILL);
        }
        final int fillIndex = transformColor(fillIndexValue);
        final int borderIndex = transformColor(borderIndexValue);
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if (fillIndex == 0 && (borderIndex == 0 || borderWidthValue <= 0)) {
            return;
        }
        if (!needAvailableSpace(16 * GB_BASE_SIZE)) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WORK_TOO_BIG);
        }
        final int borderWidth;
        if (borderWidthValue > 0 && borderIndex != 0) {
            borderWidth = transformWidth(borderWidthValue);
        } else {
            borderWidth = 0;
        }
        loadPointfrom(GW_POINT_1, start);
        loadPointfrom(GW_POINT_2, end);
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_BAD_POINT);
        }
        loadOvallineFillleftFillrightFill(borderWidth, borderIndex, 0, fillIndex);
        if (engineStopped) {
            wbStackClear();
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENTITY_LOAD_FAILED);
        }
        needsFlushPut(1);
        storeEngineStateInto(engine);
    }

    /* BalloonEnginePlugin>>#primitiveAddPolygon */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveAddPolygon(final PointersObject receiver, final AbstractSqueakObject points, final int nPoints, final int fillIndexValue, final int lineWidthValue, final int lineFillValue) {
        final int length;
        final boolean pointsIsArray;
        final int segSize;
        int lineWidth = lineWidthValue;

        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        if (isWords(points)) {
            /* Either PointArray or ShortPointArray */
            pointsIsArray = false;
            length = slotSizeOf((NativeObject) points);
            if (!(length == nPoints || nPoints * 2 == length)) {
                throw PrimitiveFailed.andTransferToInterpreter(ERROR_TABLE.BAD_ARGUMENT.ordinal());
            }
        } else {
            /* Must be Array of points */
            if (!isArray(points)) {
                throw PrimitiveFailed.andTransferToInterpreter(ERROR_TABLE.BAD_ARGUMENT.ordinal());
            }
            length = slotSizeOf((ArrayObject) points);
            if (length != nPoints) {
                throw PrimitiveFailed.andTransferToInterpreter(ERROR_TABLE.BAD_ARGUMENT.ordinal());
            }
            pointsIsArray = true;
        }
        if (lineWidth == 0 || lineFillValue == 0) {
            segSize = GL_BASE_SIZE;
        } else {
            segSize = GL_WIDE_SIZE;
        }
        if (!needAvailableSpace(segSize * nPoints)) {
            throw PrimitiveFailed.andTransferToInterpreter();
        }
        if (!(isFillOkay(lineFillValue) && isFillOkay(fillIndexValue))) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WRONG_FILL);
        }
        final int lineFill = transformColor(lineFillValue);
        final int fillIndex = transformColor(fillIndexValue);
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if ((lineFill == 0 || lineWidth == 0) && fillIndex == 0) {
            return;
        }
        if (lineWidth != 0) {
            lineWidth = transformWidth(lineWidth);
        }
        if (pointsIsArray) {
            loadArrayPolygonnPointsfilllineWidthlineFill((ArrayObject) points, nPoints, fillIndex, lineWidth, lineFill);
        } else {
            loadPolygonnPointsfilllineWidthlineFillpointsShort(((NativeObject) points).getIntStorage(), nPoints, fillIndex, lineWidth, lineFill, nPoints == length);
        }
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENTITY_LOAD_FAILED);
        }
        needsFlushPut(1);
        storeEngineStateInto(engine);
    }

    /* BalloonEnginePlugin>>#primitiveAddRect */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveAddRect(final PointersObject receiver, final PointersObject start, final PointersObject end, final int fillIndexValue, final int borderWidthValue,
                    final int borderIndexValue) {
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        if (!(isFillOkay(borderIndexValue) && isFillOkay(fillIndexValue))) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WRONG_FILL);
        }
        final int borderIndex = transformColor(borderIndexValue);
        final int fillIndex = transformColor(fillIndexValue);
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if (fillIndex == 0 && (borderIndex == 0 || borderWidthValue == 0)) {
            return;
        }
        if (!needAvailableSpace(4 * GL_BASE_SIZE)) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WORK_TOO_BIG);
        }
        final int borderWidth;
        if (borderWidthValue > 0 && borderIndex != 0) {
            borderWidth = transformWidth(borderWidthValue);
        } else {
            borderWidth = 0;
        }
        loadPointfrom(GW_POINT_1, start);
        loadPointfrom(GW_POINT_3, end);
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_BAD_POINT);
        }
        point2SetX(point3GetX());
        point2SetY(point1GetY());
        point4SetX(point1GetX());
        point4SetY(point3GetY());
        transformPoints(4);
        loadRectanglelineFillleftFillrightFill(borderWidth, borderIndex, 0, fillIndex);
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENTITY_LOAD_FAILED);
        }
        needsFlushPut(1);
        storeEngineStateInto(engine);
    }

    /* Note: No need to load either bitBlt or spanBuffer */

    /* BalloonEngineBase>>#primitiveChangedActiveEdgeEntry */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveChangedActiveEdgeEntry(final PointersObject receiver, final PointersObject edgeEntry) {
        final int edge;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_WAITING_CHANGE);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        edge = loadEdgeStateFrom(edgeEntry);
        if (edgeNumLinesOf(edge) == 0) {
            removeFirstAETEntry();
        } else {
            resortFirstAETEntry();
            aetStartPut(aetStartGet() + 1);
        }
        statePut(GE_STATE_UPDATE_EDGES);
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GW_COUNT_CHANGE_AET_ENTRY, 1);
            incrementStatby(GW_TIME_CHANGE_AET_ENTRY, ioMicroMSecs() - geProfileTime);
        }
    }

    /* BalloonEngineBase>>#primitiveCopyBuffer */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveCopyBuffer(final NativeObject buf1, final NativeObject buf2) {
        final int diff;

        /* Make sure the old buffer is properly initialized */
        final int failureCode1 = loadWorkBufferFrom(buf1);
        if (failureCode1 != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode1);
        }
        if (fetchClassOf(buf1) != fetchClassOf(buf2)) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_CLASS_MISMATCH);
        }
        diff = slotSizeOf(buf2) - slotSizeOf(buf1);
        if (diff < 0) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_SIZE_MISMATCH);
        }
        final int[] src = workBuffer;
        final int[] dst = buf2.getIntStorage();
        for (int i = 0, iLimiT = wbTopGet() - 1; i <= iLimiT; i++) {
            dst[i] = src[i];
        }
        dst[GW_BUFFER_TOP] = wbTopGet() + diff;
        dst[GW_SIZE] = wbSizeGet() + diff;
        final int srcOffset = wbTopGet();
        final int dstOffset = wbTopGet() + diff;
        for (int i = 0, iLimiT = wbSizeGet() - wbTopGet() - 1; i <= iLimiT; i++) {
            dst[dstOffset + i] = src[srcOffset + i];
        }
        final int failureCode2 = loadWorkBufferFrom(buf2);
        if (failureCode2 != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode2);
        }
    }

    /* Note: Must load bitBlt and spanBuffer */

    /* BalloonEngineBase>>#primitiveDisplaySpanBuffer */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveDisplaySpanBuffer(final PointersObject receiver) {
        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        final int failureCode1 = quickLoadEngineFromrequiredState(receiver, GE_STATE_BLIT_BUFFER);
        if (failureCode1 != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode1);
        }
        final int failureCode2 = loadSpanBufferFrom(fetchNativeofObject(BE_SPAN_INDEX, engine));
        if (failureCode2 != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode2);
        }
        if (!loadBitBltFrom(fetchPointerofObject(BE_BITBLT_INDEX, engine))) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_BITBLT_LOAD_FAILED);
        }
        if ((currentYGet() & aaScanMaskGet()) == aaScanMaskGet()) {
            displaySpanBufferAt(currentYGet());
            postDisplayAction();
        }
        if (!finishedProcessing()) {
            aetStartPut(0);
            currentYPut(currentYGet() + 1);
            statePut(GE_STATE_UPDATE_EDGES);
        }
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GW_COUNT_DISPLAY_SPAN, 1);
            incrementStatby(GW_TIME_DISPLAY_SPAN, ioMicroMSecs() - geProfileTime);
        }
    }

    /* Turn on/off profiling. Return the old value of the flag. */

    /* BalloonEngineBase>>#primitiveDoProfileStats */
    public boolean primitiveDoProfileStats(final boolean newValue) {
        final boolean oldValue = doProfileStats;
        doProfileStats = newValue;
        return BooleanObject.wrap(oldValue);
    }

    /* BalloonEngineBase>>#primitiveFinishedProcessing */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public boolean primitiveFinishedProcessing(final PointersObject receiver) {
        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        final int failureCode = quickLoadEngineFrom(receiver);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        final boolean finished = finishedProcessing();
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GW_COUNT_FINISH_TEST, 1);
            incrementStatby(GW_TIME_FINISH_TEST, ioMicroMSecs() - geProfileTime);
        }
        return BooleanObject.wrap(finished);
    }

    /* BalloonEngineBase>>#primitiveGetAALevel */
    public long primitiveGetAALevel(final PointersObject receiver) {
        final int failureCode = quickLoadEngineFrom(receiver);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        return aaLevelGet();
    }

    /* BalloonEnginePlugin>>#primitiveGetBezierStats */
    public void primitiveGetBezierStats(final PointersObject receiver, final NativeObject statOop) {
        final int failureCode = quickLoadEngineFrom(receiver);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        final int[] stats = statOop.getIntStorage();
        stats[0] += workBuffer[GW_BEZIER_MONOTON_SUBDIVISIONS];
        stats[1] += workBuffer[GW_BEZIER_HEIGHT_SUBDIVISIONS];
        stats[2] += workBuffer[GW_BEZIER_OVERFLOW_SUBDIVISIONS];
        stats[3] += workBuffer[GW_BEZIER_LINE_CONVERSIONS];
    }

    /* BalloonEngineBase>>#primitiveGetClipRect */
    public void primitiveGetClipRect(final AbstractPointersObjectWriteNode writeNode, final Node inlineTarget, final PointersObject receiver, final PointersObject rectOop) {
        final int failureCode = quickLoadEngineFrom(receiver);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        PointersObject pointOop = image.asPoint(writeNode, inlineTarget, clipMinXGet(), clipMinYGet());
        storeValue(0, rectOop, pointOop);
        pointOop = image.asPoint(writeNode, inlineTarget, clipMaxXGet(), clipMaxYGet());
        storeValue(1, rectOop, pointOop);
    }

    /* BalloonEngineBase>>#primitiveGetCounts */
    public void primitiveGetCounts(final PointersObject receiver, final NativeObject statOop) {
        final int failureCode = quickLoadEngineFrom(receiver);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        final int[] stats = statOop.getIntStorage();
        stats[0] += workBuffer[GW_COUNT_INITIALIZING];
        stats[1] += workBuffer[GW_COUNT_FINISH_TEST];
        stats[2] += workBuffer[GW_COUNT_NEXT_GET_ENTRY];
        stats[3] += workBuffer[GW_COUNT_ADD_AET_ENTRY];
        stats[4] += workBuffer[GW_COUNT_NEXT_FILL_ENTRY];
        stats[5] += workBuffer[GW_COUNT_MERGE_FILL];
        stats[6] += workBuffer[GW_COUNT_DISPLAY_SPAN];
        stats[7] += workBuffer[GW_COUNT_NEXT_AET_ENTRY];
        stats[8] += workBuffer[GW_COUNT_CHANGE_AET_ENTRY];
    }

    /* BalloonEngineBase>>#primitiveGetDepth */
    public long primitiveGetDepth(final PointersObject receiver) {
        final int failureCode = quickLoadEngineFrom(receiver);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        return currentZGet();
    }

    /* Return the reason why the last operation failed. */

    /* BalloonEngineBase>>#primitiveGetFailureReason */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public long primitiveGetFailureReason(final PointersObject receiver) {
        /*
         * Note -- don't call loadEngineFrom here because this will override the stopReason with
         * Zero
         */
        engine = receiver;
        if (slotSizeOf(engine) < BE_BALLOON_ENGINE_SIZE) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_TOO_SMALL);
        }
        final int failCode = loadWorkBufferFrom(fetchNativeofObject(BE_WORKBUFFER_INDEX, engine));
        if (failCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failCode);
        }
        return stopReasonGet();
    }

    /* BalloonEngineBase>>#primitiveGetOffset */
    public PointersObject primitiveGetOffset(final AbstractPointersObjectWriteNode writeNode, final Node inlineTarget, final PointersObject receiver) {
        final int failureCode = quickLoadEngineFrom(receiver);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        return image.asPoint(writeNode, inlineTarget, destOffsetXGet(), destOffsetYGet());
    }

    /* BalloonEngineBase>>#primitiveGetTimes */
    public void primitiveGetTimes(final PointersObject receiver, final NativeObject statsArray) {
        final int failureCode = quickLoadEngineFrom(receiver);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        final int[] stats = statsArray.getIntStorage();
        stats[0] += workBuffer[GW_TIME_INITIALIZING];
        stats[1] += workBuffer[GW_TIME_FINISH_TEST];
        stats[2] += workBuffer[GW_TIME_NEXT_GET_ENTRY];
        stats[3] += workBuffer[GW_TIME_ADD_AET_ENTRY];
        stats[4] += workBuffer[GW_TIME_NEXT_FILL_ENTRY];
        stats[5] += workBuffer[GW_TIME_MERGE_FILL];
        stats[6] += workBuffer[GW_TIME_DISPLAY_SPAN];
        stats[7] += workBuffer[GW_TIME_NEXT_AET_ENTRY];
        stats[8] += workBuffer[GW_TIME_CHANGE_AET_ENTRY];
    }

    /* BalloonEngineBase>>#primitiveInitializeBuffer */
    public void primitiveInitializeBuffer(final NativeObject wbOop) {
        final int size = wbOop.getIntLength();

        workBufferPut(wbOop);
        objBufferIndex = GW_HEADER_SIZE;
        magicNumberPut(GW_MAGIC_NUMBER);
        wbSizePut(size);
        wbTopPut(size);
        statePut(GE_STATE_UNLOCKED);
        objStartPut(GW_HEADER_SIZE);
        objUsedPut(4);
        objectTypeOfput(0, GE_PRIMITIVE_FILL);
        objectLengthOfput(0, 4);
        objectIndexOfput(0, 0);
        getStartPut(0);
        getUsedPut(0);
        aetStartPut(0);
        aetUsedPut(0);
        stopReasonPut(0);
        needsFlushPut(0);
        clipMinXPut(0);
        clipMaxXPut(0);
        clipMinYPut(0);
        clipMaxYPut(0);
        currentZPut(0);
        resetGraphicsEngineStats();
        initEdgeTransform();
        initColorTransform();
    }

    /* Note: No need to load bitBlt but must load spanBuffer */

    /* BalloonEngineBase>>#primitiveInitializeProcessing */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveInitializeProcessing(final PointersObject receiver) {
        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        final int failureCode1 = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode1 != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode1);
        }
        final int failureCode2 = loadSpanBufferFrom(fetchNativeofObject(BE_SPAN_INDEX, engine));
        if (failureCode2 != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode2);
        }
        initializeGETProcessing();
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        statePut(GE_STATE_ADDING_FROM_GET);
        if (!failed()) {
            storeEngineStateInto(engine);
        }
        if (doProfileStats) {
            incrementStatby(GW_COUNT_INITIALIZING, 1);
            incrementStatby(GW_TIME_INITIALIZING, ioMicroMSecs() - geProfileTime);
        }
    }

    /* Note: No need to load bitBlt but must load spanBuffer */

    /* BalloonEngineBase>>#primitiveMergeFillFrom */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveMergeFillFrom(final PointersObject receiver, final NativeObject bitsOop, final PointersObject fillOop) {
        int value;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        final int failureCode1 = quickLoadEngineFromrequiredState(receiver, GE_STATE_WAITING_FOR_FILL);
        if (failureCode1 != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode1);
        }
        final int failureCode2 = loadSpanBufferFrom(fetchNativeofObject(BE_SPAN_INDEX, engine));
        if (failureCode2 != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode2);
        }
        /* Check bitmap */
        if (slotSizeOf(fillOop) < FT_BALLOON_FILL_DATA_SIZE) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_FILL_DATA_TOO_SMALL);
        }
        value = fetchIntegerofObject(FT_INDEX_INDEX, fillOop);
        if (objectIndexOf(lastExportedFillGet()) != value) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WRONG_FILL);
        }
        value = fetchIntegerofObject(FT_MIN_X_INDEX, fillOop);
        if (lastExportedLeftXGet() != value) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WRONG_FILL);
        }
        value = fetchIntegerofObject(FT_MAX_X_INDEX, fillOop);
        if (lastExportedRightXGet() != value) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WRONG_FILL);
        }
        if (slotSizeOf(bitsOop) < lastExportedRightXGet() - lastExportedLeftXGet()) {
            throw PrimitiveFailed.andTransferToInterpreter(ERROR_TABLE.BAD_ARGUMENT.ordinal());
        }
        if (failed()) {
            return;
        }
        fillBitmapSpanfromto(bitsOop.getIntStorage(), lastExportedLeftXGet(), lastExportedRightXGet());
        statePut(GE_STATE_SCANNING_AET);
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GW_COUNT_MERGE_FILL, 1);
            incrementStatby(GW_TIME_MERGE_FILL, ioMicroMSecs() - geProfileTime);
        }
    }

    /* BalloonEngineBase>>#primitiveNeedsFlush */
    public boolean primitiveNeedsFlush(final PointersObject receiver) {
        final boolean needFlush;

        final int failureCode = quickLoadEngineFrom(receiver);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        needFlush = needsFlush();
        storeEngineStateInto(engine);
        return BooleanObject.wrap(needFlush);
    }

    /* BalloonEngineBase>>#primitiveNeedsFlushPut */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveNeedsFlushPut(final PointersObject receiver, final boolean needFlush) {
        final int failureCode = quickLoadEngineFrom(receiver);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        if (needFlush) {
            needsFlushPut(1);
        } else {
            needsFlushPut(0);
        }
        storeEngineStateInto(engine);
    }

    /* Note: No need to load either bitBlt or spanBuffer */

    /* BalloonEngineBase>>#primitiveNextActiveEdgeEntry */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public boolean primitiveNextActiveEdgeEntry(final PointersObject receiver, final PointersObject edgeEntry) {
        final int edge;
        boolean hasEdge;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        final int failureCode = quickLoadEngineFromrequiredStateor(receiver, GE_STATE_UPDATE_EDGES, GE_STATE_COMPLETED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        hasEdge = false;
        if (stateGet() != GE_STATE_COMPLETED) {
            hasEdge = findNextExternalUpdateFromAET();
            if (hasEdge) {
                edge = aetBuffer(aetStartGet());
                storeEdgeStateFrominto(edge, edgeEntry);
                statePut(GE_STATE_WAITING_CHANGE);
            } else {
                statePut(GE_STATE_ADDING_FROM_GET);
            }
        }
        assert !failed();
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GW_COUNT_NEXT_AET_ENTRY, 1);
            incrementStatby(GW_TIME_NEXT_AET_ENTRY, ioMicroMSecs() - geProfileTime);
        }
        return BooleanObject.wrap(!hasEdge);
    }

    /* Note: No need to load bitBlt but must load spanBuffer */

    /* BalloonEngineBase>>#primitiveNextFillEntry */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public boolean primitiveNextFillEntry(final PointersObject receiver, final PointersObject fillOop) {
        final boolean hasFill;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        final int failureCode1 = quickLoadEngineFromrequiredState(receiver, GE_STATE_SCANNING_AET);
        if (failureCode1 != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode1);
        }
        final int failureCode2 = loadSpanBufferFrom(fetchNativeofObject(BE_SPAN_INDEX, engine));
        if (failureCode2 != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode2);
        }
        if (!loadFormsFrom(fetchArrayofObject(BE_FORMS_INDEX, engine))) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_FORM_LOAD_FAILED);
        }
        if (clearSpanBufferGet() != 0) {
            if ((currentYGet() & aaScanMaskGet()) == 0) {
                clearSpanBuffer();
            }
            clearSpanBufferPut(0);
        }
        hasFill = findNextExternalFillFromAET();
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if (hasFill) {
            storeFillStateInto(fillOop);
        }
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WRONG_FILL);
        }
        if (hasFill) {
            statePut(GE_STATE_WAITING_FOR_FILL);
        } else {
            wbStackClear();
            spanEndAAPut(0);
            statePut(GE_STATE_BLIT_BUFFER);
        }
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GW_COUNT_NEXT_FILL_ENTRY, 1);
            incrementStatby(GW_TIME_NEXT_FILL_ENTRY, ioMicroMSecs() - geProfileTime);
        }
        return BooleanObject.wrap(!hasFill);
    }

    /* Note: No need to load either bitBlt or spanBuffer */

    /* BalloonEngineBase>>#primitiveNextGlobalEdgeEntry */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public boolean primitiveNextGlobalEdgeEntry(final PointersObject receiver, final PointersObject edgeEntry) {
        final int edge;
        final boolean hasEdge;

        if (doProfileStats) {
            geProfileTime = ioMicroMSecs();
        }
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_ADDING_FROM_GET);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        hasEdge = findNextExternalEntryFromGET();
        if (hasEdge) {
            edge = getBuffer(getStartGet());
            storeEdgeStateFrominto(edge, edgeEntry);
            getStartPut(getStartGet() + 1);
        }
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WRONG_EDGE);
        }
        if (hasEdge) {
            statePut(GE_STATE_WAITING_FOR_EDGE);
        } else {
            /* Start scanning the AET */
            statePut(GE_STATE_SCANNING_AET);
            clearSpanBufferPut(1);
            aetStartPut(0);
            wbStackClear();
        }
        storeEngineStateInto(engine);
        if (doProfileStats) {
            incrementStatby(GW_COUNT_NEXT_GET_ENTRY, 1);
            incrementStatby(GW_TIME_NEXT_GET_ENTRY, ioMicroMSecs() - geProfileTime);
        }
        return BooleanObject.wrap(!hasEdge);
    }

    /* BalloonEngineBase>>#primitiveRegisterExternalEdge */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveRegisterExternalEdge(final PointersObject receiver, final int index, final int initialX, final int initialY, final int initialZ, final int leftFillIndex,
                    final int rightFillIndex) {
        final int edge;

        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        if (!allocateObjEntry(GE_BASE_EDGE_SIZE)) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WORK_TOO_BIG);
        }
        if (!(isFillOkay(leftFillIndex) && isFillOkay(rightFillIndex))) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_WRONG_FILL);
        }
        edge = objUsed;
        /* Install type and length */
        objUsed = edge + GE_BASE_EDGE_SIZE;
        objectTypeOfput(edge, GE_PRIMITIVE_EDGE);
        objectLengthOfput(edge, GE_BASE_EDGE_SIZE);
        objectIndexOfput(edge, index);
        edgeXValueOfput(edge, initialX);
        edgeYValueOfput(edge, initialY);
        edgeZValueOfput(edge, initialZ);
        edgeLeftFillOfput(edge, transformColor(leftFillIndex));
        edgeRightFillOfput(edge, transformColor(rightFillIndex));
        if (engineStopped) {
            throw PrimitiveFailed.andTransferToInterpreter(GEF_ENGINE_STOPPED);
        }
        if (!failed()) {
            storeEngineStateInto(engine);
        }
    }

    /* BalloonEngineBase>>#primitiveRegisterExternalFill */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public int primitiveRegisterExternalFill(final PointersObject receiver, final int index) {
        int fill;

        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        fill = 0;
        while (fill == 0) {
            if (!allocateObjEntry(GE_BASE_EDGE_SIZE)) {
                throw PrimitiveFailed.andTransferToInterpreter(GEF_WORK_TOO_BIG);
            }
            fill = objUsed;
            /* Install type and length */
            objUsed = fill + GE_BASE_FILL_SIZE;
            objectTypeOfput(fill, GE_PRIMITIVE_FILL);
            objectLengthOfput(fill, GE_BASE_FILL_SIZE);
            objectIndexOfput(fill, index);
        }
        storeEngineStateInto(engine);
        return fill;
    }

    /* Start/Proceed rendering the entire image */

    /* BalloonEngineBase>>#primitiveRenderImage */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public long primitiveRenderImage(final PointersObject receiver, final PointersObject edge, final PointersObject fill) {
        final int failCode = loadRenderingState(receiver, edge, fill);
        if (failCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failCode);
        }
        proceedRenderingScanline();
        if (engineStopped) {
            return storeRenderingState(edge, fill);
        }
        proceedRenderingImage();
        return storeRenderingState(edge, fill);
    }

    /* Start rendering the entire image */

    /* BalloonEngineBase>>#primitiveRenderScanline */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public long primitiveRenderScanline(final PointersObject receiver, final PointersObject edge, final PointersObject fill) {
        final int failCode = loadRenderingState(receiver, edge, fill);
        if (failCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failCode);
        }
        proceedRenderingScanline();
        return storeRenderingState(edge, fill);
    }

    /* BalloonEngineBase>>#primitiveSetAALevel */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveSetAALevel(final PointersObject receiver, final int level) {
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        setAALevel(level);
        storeEngineStateInto(engine);
    }

    /* Primitive. Set the BitBlt plugin to use. */

    /* BalloonEngineBase>>#primitiveSetBitBltPlugin */
    public static ClassObject primitiveSetBitBltPlugin(final ClassObject receiver, final NativeObject pluginName) {
        /* Must be string to work */
        assert pluginName.isTruffleStringType();
        final int length = pluginName.getTruffleStringByteLength();
        if (length >= 256) {
            throw PrimitiveFailed.andTransferToInterpreter();
        }
        // Implemented as NOOP.
        return receiver;
    }

    /* BalloonEngineBase>>#primitiveSetClipRect */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveSetClipRect(final PointersObject receiver, final PointersObject rectOop) {
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        loadPointfrom(GW_POINT_1, fetchPointerofObject(0, rectOop));
        loadPointfrom(GW_POINT_2, fetchPointerofObject(1, rectOop));
        if (failed()) {
            throw PrimitiveFailed.andTransferToInterpreter(ERROR_TABLE.BAD_ARGUMENT.ordinal());
        }
        clipMinXPut(point1GetX());
        clipMinYPut(point1GetY());
        clipMaxXPut(point2GetX());
        clipMaxYPut(point2GetY());
        storeEngineStateInto(engine);
    }

    /* BalloonEngineBase>>#primitiveSetColorTransform */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveSetColorTransform(final PointersObject receiver, final AbstractSqueakObject transformOop) {
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        loadColorTransformFrom(transformOop);
        storeEngineStateInto(engine);
    }

    /* BalloonEngineBase>>#primitiveSetDepth */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveSetDepth(final PointersObject receiver, final int depth) {
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        currentZPut(depth);
        storeEngineStateInto(engine);
    }

    /* BalloonEngineBase>>#primitiveSetEdgeTransform */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveSetEdgeTransform(final PointersObject receiver, final AbstractSqueakObject transformOop) {
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        loadEdgeTransformFrom(transformOop);
        storeEngineStateInto(engine);
    }

    /* BalloonEngineBase>>#primitiveSetOffset */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveSetOffset(final PointersObject receiver, final PointersObject pointOop) {
        final int failureCode = quickLoadEngineFromrequiredState(receiver, GE_STATE_UNLOCKED);
        if (failureCode != 0) {
            throw PrimitiveFailed.andTransferToInterpreter(failureCode);
        }
        loadPointfrom(GW_POINT_1, pointOop);
        destOffsetXPut(point1GetX());
        destOffsetYPut(point1GetY());
        storeEngineStateInto(engine);
    }

    /* This is the main rendering entry */

    /* BalloonEngineBase>>#proceedRenderingImage */
    private void proceedRenderingImage() {
        boolean external;

        while (!finishedProcessing()) {
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            external = findNextExternalEntryFromGET();
            if (doProfileStats) {
                incrementStatby(GW_COUNT_NEXT_GET_ENTRY, 1);
                incrementStatby(GW_TIME_NEXT_GET_ENTRY, ioMicroMSecs() - geProfileTime);
            }
            if (engineStopped) {
                statePut(GE_STATE_ADDING_FROM_GET);
                return;
            }
            if (external) {
                statePut(GE_STATE_WAITING_FOR_EDGE);
                stopBecauseOf(G_ERROR_GET_ENTRY);
                return;
            }
            aetStartPut(0);
            wbStackClear();
            clearSpanBufferPut(1);
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            if (clearSpanBufferGet() != 0 && (currentYGet() & aaScanMaskGet()) == 0) {
                clearSpanBuffer();
            }
            clearSpanBufferPut(0);
            external = findNextExternalFillFromAET();
            if (doProfileStats) {
                incrementStatby(GW_COUNT_NEXT_FILL_ENTRY, 1);
                incrementStatby(GW_TIME_NEXT_FILL_ENTRY, ioMicroMSecs() - geProfileTime);
            }
            if (engineStopped) {
                statePut(GE_STATE_SCANNING_AET);
                return;
            }
            if (external) {
                statePut(GE_STATE_WAITING_FOR_FILL);
                stopBecauseOf(G_ERROR_FILL_ENTRY);
                return;
            }
            wbStackClear();
            spanEndAAPut(0);
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            if ((currentYGet() & aaScanMaskGet()) == aaScanMaskGet()) {
                displaySpanBufferAt(currentYGet());
                postDisplayAction();
            }
            if (doProfileStats) {
                incrementStatby(GW_COUNT_DISPLAY_SPAN, 1);
                incrementStatby(GW_TIME_DISPLAY_SPAN, ioMicroMSecs() - geProfileTime);
            }
            if (engineStopped) {
                statePut(GE_STATE_BLIT_BUFFER);
                return;
            }
            if (finishedProcessing()) {
                return;
            }
            aetStartPut(0);
            currentYPut(currentYGet() + 1);
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            external = findNextExternalUpdateFromAET();
            if (doProfileStats) {
                incrementStatby(GW_COUNT_NEXT_AET_ENTRY, 1);
                incrementStatby(GW_TIME_NEXT_AET_ENTRY, ioMicroMSecs() - geProfileTime);
            }
            if (engineStopped) {
                statePut(GE_STATE_UPDATE_EDGES);
                return;
            }
            if (external) {
                statePut(GE_STATE_WAITING_CHANGE);
                stopBecauseOf(G_ERROR_AET_ENTRY);
                return;
            }
        }
    }

    /*
     * Proceed rendering the current scan line. This method may be called after some Smalltalk code
     * has been executed inbetween.
     */
    /* This is the main rendering entry */

    /* BalloonEngineBase>>#proceedRenderingScanline */
    private void proceedRenderingScanline() {
        int state = stateGet();
        if (state == GE_STATE_UNLOCKED) {
            initializeGETProcessing();
            if (engineStopped) {
                return;
            }
            state = GE_STATE_ADDING_FROM_GET;
        }
        if (state == GE_STATE_ADDING_FROM_GET) {
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            final boolean external = findNextExternalEntryFromGET();
            if (doProfileStats) {
                incrementStatby(GW_COUNT_NEXT_GET_ENTRY, 1);
                incrementStatby(GW_TIME_NEXT_GET_ENTRY, ioMicroMSecs() - geProfileTime);
            }
            if (engineStopped) {
                statePut(GE_STATE_ADDING_FROM_GET);
                return;
            }
            if (external) {
                statePut(GE_STATE_WAITING_FOR_EDGE);
                stopBecauseOf(G_ERROR_GET_ENTRY);
                return;
            }
            aetStartPut(0);
            wbStackClear();
            clearSpanBufferPut(1);
            state = GE_STATE_SCANNING_AET;
        }
        if (state == GE_STATE_SCANNING_AET) {
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            if (clearSpanBufferGet() != 0 && (currentYGet() & aaScanMaskGet()) == 0) {
                clearSpanBuffer();
            }
            clearSpanBufferPut(0);
            final boolean external = findNextExternalFillFromAET();
            if (doProfileStats) {
                incrementStatby(GW_COUNT_NEXT_FILL_ENTRY, 1);
                incrementStatby(GW_TIME_NEXT_FILL_ENTRY, ioMicroMSecs() - geProfileTime);
            }
            if (engineStopped) {
                statePut(GE_STATE_SCANNING_AET);
                return;
            }
            if (external) {
                statePut(GE_STATE_WAITING_FOR_FILL);
                stopBecauseOf(G_ERROR_FILL_ENTRY);
                return;
            }
            state = GE_STATE_BLIT_BUFFER;
            wbStackClear();
            spanEndAAPut(0);
        }
        if (state == GE_STATE_BLIT_BUFFER) {
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            if ((currentYGet() & aaScanMaskGet()) == aaScanMaskGet()) {
                displaySpanBufferAt(currentYGet());
                postDisplayAction();
            }
            if (doProfileStats) {
                incrementStatby(GW_COUNT_DISPLAY_SPAN, 1);
                incrementStatby(GW_TIME_DISPLAY_SPAN, ioMicroMSecs() - geProfileTime);
            }
            if (engineStopped) {
                statePut(GE_STATE_BLIT_BUFFER);
                return;
            }
            if (finishedProcessing()) {
                return;
            }
            state = GE_STATE_UPDATE_EDGES;
            aetStartPut(0);
            currentYPut(currentYGet() + 1);
        }
        if (state == GE_STATE_UPDATE_EDGES) {
            if (doProfileStats) {
                geProfileTime = ioMicroMSecs();
            }
            final boolean external = findNextExternalUpdateFromAET();
            if (doProfileStats) {
                incrementStatby(GW_COUNT_NEXT_AET_ENTRY, 1);
                incrementStatby(GW_TIME_NEXT_AET_ENTRY, ioMicroMSecs() - geProfileTime);
            }
            if (engineStopped) {
                statePut(GE_STATE_UPDATE_EDGES);
                return;
            }
            if (external) {
                statePut(GE_STATE_WAITING_CHANGE);
                stopBecauseOf(G_ERROR_AET_ENTRY);
                return;
            }
            statePut(GE_STATE_ADDING_FROM_GET);
        }
    }

    /*
     * Load the minimal required state from the engineOop, e.g., just the work buffer. Answer 0 on
     * success or non-zero a failure code on failure
     */

    /* BalloonEngineBase>>#quickLoadEngineFrom: */
    @TruffleBoundary(transferToInterpreterOnException = false)
    private int quickLoadEngineFrom(final PointersObject engineOop) {
        if (failed()) {
            return GEF_ALREADY_FAILED;
        }
        if (slotSizeOf(engineOop) < BE_BALLOON_ENGINE_SIZE) {
            return GEF_ENGINE_TOO_SMALL;
        }
        engine = engineOop;
        final int failCode;
        if ((failCode = loadWorkBufferFrom(fetchNativeofObject(BE_WORKBUFFER_INDEX, engineOop))) != 0) {
            return failCode;
        }
        stopReasonPut(0);
        objUsed = objUsedGet();
        engineStopped = false;
        return 0;
    }

    /* BalloonEngineBase>>#quickLoadEngineFrom:requiredState: */
    private int quickLoadEngineFromrequiredState(final PointersObject oop, final int requiredState) {
        final int failureCode = quickLoadEngineFrom(oop);
        if (failureCode != 0) {
            return failureCode;
        }
        if (stateGet() == requiredState) {
            return 0;
        }
        stopReasonPut(G_ERROR_BAD_STATE);
        return GEF_WRONG_STATE;
    }

    /* BalloonEngineBase>>#quickLoadEngineFrom:requiredState:or: */
    private int quickLoadEngineFromrequiredStateor(final PointersObject oop, final int requiredState, final int alternativeState) {
        final int failureCode = quickLoadEngineFrom(oop);
        if (failureCode != 0) {
            return failureCode;
        }
        if (stateGet() == requiredState) {
            return 0;
        }
        if (stateGet() == alternativeState) {
            return 0;
        }
        stopReasonPut(G_ERROR_BAD_STATE);
        return GEF_WRONG_STATE;
    }

    /* Remove any top fills if they have become invalid. */

    /* BalloonEngineBase>>#quickRemoveInvalidFillsAt: */
    private void quickRemoveInvalidFillsAt(final int leftX) {
        if (stackFillSize() == 0) {
            return;
        }
        while (topRightX() <= leftX) {
            hideFilldepth(topFill(), topDepth());
            if (stackFillSize() == 0) {
                return;
            }
        }
    }

    /*
     * Sort elements i through j of self to be nondescending according to sortBlock.
     */
    /* Note: The original loop has been heavily re-written for C translation */

    /* BalloonEngineBase>>#quickSortGlobalEdgeTable:from:to: */
    @TruffleBoundary // Recursive function
    private void quickSortGlobalEdgeTablefromto(final int[] array, final int i, final int j) {
        final int n = j + 1 - i;
        /* The prefix d means the data at that index. */
        if (n <= 1) {
            return;
        }
        int di = array[i];
        int dj = array[j];
        /* i.e., should di precede dj? */
        boolean before = getSortsbefore(di, dj);
        if (!before) {
            final int tmp = array[i];
            array[i] = array[j];
            array[j] = tmp;
            final int tt = di;
            di = dj;
            dj = tt;
        }
        if (n == 2) {
            return;
        }
        /* ij is the midpoint of i and j. */
        final int ij = (i + j) / 2;
        /* Sort di,dij,dj. Make dij be their median. */
        int dij = array[ij];
        /* i.e. should di precede dij? */
        before = getSortsbefore(di, dij);
        if (before) {
            /* i.e., should dij precede dj? */
            before = getSortsbefore(dij, dj);
            if (!before) {
                /* i.e., should dij precede dj? */
                final int tmp = array[j];
                array[j] = array[ij];
                array[ij] = tmp;
                dij = dj;
            }
        } else {
            /* i.e. di should come after dij */
            final int tmp = array[i];
            array[i] = array[ij];
            array[ij] = tmp;
            dij = di;
        }
        if (n == 3) {
            return;
        }
        int k = i;
        int l = j;
        boolean again = true;
        while (again) {
            before = true;
            while (before) {
                if (k <= --l) {
                    before = getSortsbefore(dij, array[l]);
                } else {
                    before = false;
                }
            }
            before = true;
            while (before) {
                if (++k <= l) {
                    before = getSortsbefore(array[k], dij);
                } else {
                    before = false;
                }
            }
            again = k <= l;
            if (again) {
                final int tmp = array[k];
                array[k] = array[l];
                array[l] = tmp;
            }
        }
        quickSortGlobalEdgeTablefromto(array, i, l);
        quickSortGlobalEdgeTablefromto(array, k, j);
    }

    /* BalloonEngineBase>>#removeFirstAETEntry */
    private void removeFirstAETEntry() {
        int index = aetStartGet();
        aetUsedPut(aetUsedGet() - 1);
        while (index < aetUsedGet()) {
            aetBuffer(index, aetBuffer(index + 1));
            index++;
        }
    }

    /* BalloonEnginePlugin>>#repeatValue:max: */
    private static int repeatValuemax(final int delta, final int maxValue) {
        int newDelta = delta;
        while (newDelta < 0) {
            newDelta += maxValue;
        }
        while (newDelta >= maxValue) {
            newDelta -= maxValue;
        }
        return newDelta;
    }

    /* BalloonEngineBase>>#resetGraphicsEngineStats */
    private void resetGraphicsEngineStats() {
        workBuffer[GW_TIME_INITIALIZING] = 0;
        workBuffer[GW_TIME_FINISH_TEST] = 0;
        workBuffer[GW_TIME_NEXT_GET_ENTRY] = 0;
        workBuffer[GW_TIME_ADD_AET_ENTRY] = 0;
        workBuffer[GW_TIME_NEXT_FILL_ENTRY] = 0;
        workBuffer[GW_TIME_MERGE_FILL] = 0;
        workBuffer[GW_TIME_DISPLAY_SPAN] = 0;
        workBuffer[GW_TIME_NEXT_AET_ENTRY] = 0;
        workBuffer[GW_TIME_CHANGE_AET_ENTRY] = 0;
        workBuffer[GW_COUNT_INITIALIZING] = 0;
        workBuffer[GW_COUNT_FINISH_TEST] = 0;
        workBuffer[GW_COUNT_NEXT_GET_ENTRY] = 0;
        workBuffer[GW_COUNT_ADD_AET_ENTRY] = 0;
        workBuffer[GW_COUNT_NEXT_FILL_ENTRY] = 0;
        workBuffer[GW_COUNT_MERGE_FILL] = 0;
        workBuffer[GW_COUNT_DISPLAY_SPAN] = 0;
        workBuffer[GW_COUNT_NEXT_AET_ENTRY] = 0;
        workBuffer[GW_COUNT_CHANGE_AET_ENTRY] = 0;
        workBuffer[GW_BEZIER_MONOTON_SUBDIVISIONS] = 0;
        workBuffer[GW_BEZIER_HEIGHT_SUBDIVISIONS] = 0;
        workBuffer[GW_BEZIER_OVERFLOW_SUBDIVISIONS] = 0;
        workBuffer[GW_BEZIER_LINE_CONVERSIONS] = 0;
    }

    /* BalloonEngineBase>>#resortFirstAETEntry */
    private void resortFirstAETEntry() {
        if (aetStartGet() == 0) {
            return;
        }
        final int edge = aetBuffer(aetStartGet());
        final int xValue = edgeXValueOf(edge);
        final int leftEdge = aetBuffer(aetStartGet() - 1);
        if (edgeXValueOf(leftEdge) <= xValue) {
            return;
        }
        moveAETEntryFromedgex(aetStartGet(), edge, xValue);
    }

    /* BalloonEnginePlugin>>#returnWideBezierFill */
    private int returnWideBezierFill(final int edge) {
        return wideBezierFillOf(edge);
    }

    /* BalloonEnginePlugin>>#returnWideBezierWidth */
    private int returnWideBezierWidth(final int edge) {
        return wideBezierWidthOf(edge);
    }

    /* Return the fill of the (wide) line - this method is called from a case. */

    /* BalloonEnginePlugin>>#returnWideLineFill */
    private int returnWideLineFill(final int edge) {
        return wideLineFillOf(edge);
    }

    /* Return the width of the (wide) line - this method is called from a case. */

    /* BalloonEnginePlugin>>#returnWideLineWidth */
    private int returnWideLineWidth(final int edge) {
        return wideLineWidthOf(edge);
    }

    /*
     * Set the anti-aliasing level. Three levels are supported: 1 - No antialiasing 2 - 2x2
     * unweighted anti-aliasing 4 - 4x4 unweighted anti-aliasing.
     */

    /* BalloonEngineBase>>#setAALevel: */
    private void setAALevel(final int level) {
        int aaLevel = 0;
        if (level >= 4) {
            aaLevel = 4;
        }
        if (level >= 2 && level < 4) {
            aaLevel = 2;
        }
        if (level < 2) {
            aaLevel = 1;
        }
        aaLevelPut(aaLevel);
        if (aaLevel == 1) {
            aaShiftPut(0);
            aaColorMaskPut(0xFFFFFFFF);
            aaScanMaskPut(0);
        }
        if (aaLevel == 2) {
            aaShiftPut(1);
            aaColorMaskPut(0xFCFCFCFC);
            aaScanMaskPut(1);
        }
        if (aaLevel == 4) {
            aaShiftPut(2);
            aaColorMaskPut(0xF0F0F0F0);
            aaScanMaskPut(3);
        }
        aaColorShiftPut(aaShiftGet() * 2);
        aaHalfPixelPut(aaShiftGet());
    }

    /* Return the run-length value from the given ShortRunArray. */

    /* BalloonEnginePlugin>>#shortRunLengthAt:from: */
    private static int shortRunLengthAtfrom(final int i, final int[] runArray) {
        return runArray[i] >>> 16;
    }

    /*
     * Return the run-length value from the given ShortRunArray. Note: We don't need any coercion to
     * short/int here, since we deal basically only with unsigned values.
     */

    /* BalloonEnginePlugin>>#shortRunValueAt:from: */
    private static int shortRunValueAtfrom(final int i, final int[] runArray) {
        return runArray[i] & 0xFFFF;
    }

    /* BalloonEngineBase>>#showFill:depth:rightX: */
    private void showFilldepthrightX(final int fillIndex, final int depth, final int rightX) {
        if (!allocateStackFillEntry()) {
            return;
        }
        stackFillValueput(0, fillIndex);
        stackFillDepthput(0, depth);
        stackFillRightXput(0, rightX);
        if (stackFillSize() == stackFillEntryLength()) {
            return;
        }
        if (fillSortsbefore(0, stackFillSize() - stackFillEntryLength())) {
            /* New top fill */
            stackFillValueput(0, topFillValue());
            stackFillDepthput(0, topFillDepth());
            stackFillRightXput(0, topFillRightX());
            topFillValuePut(fillIndex);
            topFillDepthPut(depth);
            topFillRightXPut(rightX);
        }
    }

    /* Sort the entire global edge table */

    /* BalloonEngineBase>>#sortGlobalEdgeTable */
    private void sortGlobalEdgeTable() {
        quickSortGlobalEdgeTablefromto(workBuffer, getBufferIndex, getBufferIndex + getUsedGet() - 1);
    }

    /* BalloonEngineBase>>#spanEndAAGet */
    private int spanEndAAGet() {
        return workBuffer[GW_SPAN_END_AA];
    }

    /* BalloonEngineBase>>#spanEndAAPut: */
    private void spanEndAAPut(final int value) {
        workBuffer[GW_SPAN_END_AA] = value;
    }

    /* BalloonEngineBase>>#spanEndGet */
    private int spanEndGet() {
        return workBuffer[GW_SPAN_END];
    }

    /* BalloonEngineBase>>#spanEndPut: */
    private void spanEndPut(final int value) {
        workBuffer[GW_SPAN_END] = value;
    }

    /* BalloonEngineBase>>#spanSizeGet */
    private int spanSizeGet() {
        return workBuffer[GW_SPAN_SIZE];
    }

    /* BalloonEngineBase>>#spanSizePut: */
    private void spanSizePut(final int value) {
        workBuffer[GW_SPAN_SIZE] = value;
    }

    /* BalloonEngineBase>>#spanStartGet */
    private int spanStartGet() {
        return workBuffer[GW_SPAN_START];
    }

    /* BalloonEngineBase>>#spanStartPut: */
    private void spanStartPut(final int value) {
        workBuffer[GW_SPAN_START] = value;
    }

    /* BalloonEngineBase>>#squaredLengthOf:with: */
    private static int squaredLengthOfwith(final int deltaX, final int deltaY) {
        return deltaX * deltaX + deltaY * deltaY;
    }

    /* BalloonEngineBase>>#stackFillDepth: */
    private int stackFillDepth(final int index) {
        return wbStackValue(index + 1);
    }

    /* BalloonEngineBase>>#stackFillDepth:put: */
    private void stackFillDepthput(final int index, final int value) {
        wbStackValueput(index + 1, value);
    }

    /* BalloonEngineBase>>#stackFillEntryLength */
    private static int stackFillEntryLength() {
        return 3;
    }

    /* BalloonEngineBase>>#stackFillRightX: */
    private int stackFillRightX(final int index) {
        return wbStackValue(index + 2);
    }

    /* BalloonEngineBase>>#stackFillRightX:put: */
    private void stackFillRightXput(final int index, final int value) {
        wbStackValueput(index + 2, value);
    }

    /* BalloonEngineBase>>#stackFillSize */
    private int stackFillSize() {
        return wbStackSize();
    }

    /* BalloonEngineBase>>#stackFillValue: */
    private int stackFillValue(final int index) {
        return wbStackValue(index);
    }

    /* BalloonEngineBase>>#stackFillValue:put: */
    private void stackFillValueput(final int index, final int value) {
        wbStackValueput(index, value);
    }

    /* BalloonEngineBase>>#stateGet */
    private int stateGet() {
        return workBuffer[GW_STATE];
    }

    /* BalloonEngineBase>>#statePut: */
    private void statePut(final int value) {
        workBuffer[GW_STATE] = value;
    }

    /*
     * Initialize the current entry in the GET by stepping to the current scan line
     */

    /* BalloonEnginePlugin>>#stepToFirstBezier */
    private void stepToFirstBezier() {
        stepToFirstBezierInat(getBuffer(getStartGet()), currentYGet());
    }

    /*
     * Initialize the bezier at yValue. TODO: Check if reducing maxSteps from 2*deltaY to deltaY
     * brings a *significant* performance improvement. In theory this should make for double step
     * performance but will cost in quality. Might be that the AA stuff will compensate for this -
     * but I'm not really sure.
     */

    /* BalloonEnginePlugin>>#stepToFirstBezierIn:at: */
    private void stepToFirstBezierInat(final int bezier, final int yValue) {
        /* Do a quick check if there is anything at all to do */
        if (!isWide(bezier) && yValue >= bezierEndYOf(bezier)) {
            edgeNumLinesOfput(bezier, 0);
            return;
        }
        final int startX = edgeXValueOf(bezier);
        int startY = edgeYValueOf(bezier);
        final int viaX = bezierViaXOf(bezier);
        final int viaY = bezierViaYOf(bezier);
        final int endX = bezierEndXOf(bezier);
        final int endY = bezierEndYOf(bezier);

        /* Initialize integer forward differencing */
        final int deltaY = endY - startY;
        final int fwX1 = (viaX - startX) * 2;
        final int fwX2 = startX + endX - viaX * 2;
        final int fwY1 = (viaY - startY) * 2;
        final int fwY2 = startY + endY - viaY * 2;
        int maxSteps = deltaY * 2;
        if (maxSteps < 2) {
            maxSteps = 2;
        }
        final int scaledStepSize = div(0x1000000, maxSteps);
        final int squaredStepSize = absoluteSquared8Dot24(scaledStepSize);
        int fwDx = fwX1 * scaledStepSize;
        final int fwDDx = fwX2 * squaredStepSize * 2;
        fwDx += fwDDx / 2;
        int fwDy = fwY1 * scaledStepSize;
        final int fwDDy = fwY2 * squaredStepSize * 2;

        /* Store the values */
        fwDy += fwDDy / 2;
        edgeNumLinesOfput(bezier, deltaY);
        bezierUpdateDataOf(bezier, GB_UPDATE_X, startX << 8);
        bezierUpdateDataOf(bezier, GB_UPDATE_Y, startY << 8);
        bezierUpdateDataOf(bezier, GB_UPDATE_DX, fwDx);
        bezierUpdateDataOf(bezier, GB_UPDATE_DY, fwDy);
        bezierUpdateDataOf(bezier, GB_UPDATE_DDX, fwDDx);
        bezierUpdateDataOf(bezier, GB_UPDATE_DDY, fwDDy);
        if ((startY = edgeYValueOf(bezier)) != yValue) {
            stepToNextBezierInat(bezier, yValue);
            edgeNumLinesOfput(bezier, deltaY - (yValue - startY));
        }
    }

    /*
     * Initialize the current entry in the GET by stepping to the current scan line
     */

    /* BalloonEnginePlugin>>#stepToFirstLine */
    private void stepToFirstLine() {
        stepToFirstLineInat(getBuffer(getStartGet()), currentYGet());
    }

    /* Initialize the line at yValue */

    /* BalloonEnginePlugin>>#stepToFirstLineIn:at: */
    private void stepToFirstLineInat(final int line, final int yValue) {
        /* Do a quick check if there is anything at all to do */
        if (!isWide(line) && yValue >= lineEndYOf(line)) {
            edgeNumLinesOfput(line, 0);
            return;
        }
        final int deltaX = lineEndXOf(line) - edgeXValueOf(line);
        /* Check if edge goes left to right */
        final int deltaY = lineEndYOf(line) - edgeYValueOf(line);
        final int xDir;
        final int widthX;
        int error;
        if (deltaX >= 0) {
            xDir = 1;
            widthX = deltaX;
            error = 0;
        } else {
            xDir = -1;
            widthX = -deltaX;
            error = 1 - deltaY;
        }
        final int xInc;
        final int errorAdjUp;
        if (deltaY == 0) {
            /* No error for horizontal edges */
            error = 0;
            /* Encodes width and direction */
            xInc = deltaX;
            errorAdjUp = 0;
        } else {
            /* Check if edge is y-major */
            if (deltaY > widthX) {
                /* Note: The '>' instead of '>=' could be important here... */
                xInc = 0;
                errorAdjUp = widthX;
            } else {
                xInc = div(widthX, deltaY) * xDir;
                errorAdjUp = mod(widthX, deltaY);
            }
        }
        edgeNumLinesOfput(line, deltaY);
        lineXDirectionOfput(line, xDir);
        lineXIncrementOfput(line, xInc);
        lineErrorOfput(line, error);
        lineErrorAdjUpOfput(line, errorAdjUp);
        lineErrorAdjDownOfput(line, deltaY);
        final int startY;
        if ((startY = edgeYValueOf(line)) != yValue) {
            for (int i = startY; i < yValue; i++) {
                stepToNextLineInat(line, i);
            }
            edgeNumLinesOfput(line, deltaY - (yValue - startY));
        }
    }

    /*
     * Initialize the current entry in the GET by stepping to the current scan line
     */

    /* BalloonEnginePlugin>>#stepToFirstWideBezier */
    private void stepToFirstWideBezier() {
        stepToFirstWideBezierInat(getBuffer(getStartGet()), currentYGet());
    }

    /* Initialize the bezier at yValue */

    /* BalloonEnginePlugin>>#stepToFirstWideBezierIn:at: */
    private void stepToFirstWideBezierInat(final int bezier, final int yValue) {
        final int endX;
        final int lineOffset;
        final int lineWidth;
        final int nLines;
        final int startY;
        int xDir;
        final int yEntry;
        final int yExit;

        /* Get some values */
        lineWidth = wideBezierExtentOf(bezier);
        /* Compute the incremental values of the bezier */
        lineOffset = offsetFromWidth(lineWidth);
        endX = bezierEndXOf(bezier);
        startY = edgeYValueOf(bezier);
        stepToFirstBezierInat(bezier, startY);
        /* Copy the incremental update data */
        nLines = edgeNumLinesOf(bezier);
        for (int i = 0; i <= 5; i++) {
            wideBezierUpdateDataOf(bezier, i, bezierUpdateDataOf(bezier, i));
        }
        xDir = bezierUpdateDataOf(bezier, GB_UPDATE_DX);
        if (xDir == 0) {
            xDir = bezierUpdateDataOf(bezier, GB_UPDATE_DDX);
        }
        if (xDir >= 0) {
            xDir = 1;
        } else {
            xDir = -1;
        }
        if (xDir < 0) {
            adjustWideBezierLeftwidthoffsetendX(bezier, lineWidth, lineOffset, endX);
        } else {
            adjustWideBezierRightwidthoffsetendX(bezier, lineWidth, lineOffset, endX);
        }
        if (nLines == 0) {
            bezierUpdateDataOf(bezier, GB_UPDATE_X, bezierFinalXOf(bezier) << 8);
        }
        edgeNumLinesOfput(bezier, nLines + lineWidth);
        /* turned on at lineOffset */
        yEntry = 0;
        /* turned off at zero */
        yExit = -nLines - lineOffset;
        wideBezierEntryOfput(bezier, yEntry);
        wideBezierExitOfput(bezier, yExit);
        if (yEntry >= lineOffset && yExit < 0) {
            edgeFillsValidate(bezier);
        } else {
            edgeFillsInvalidate(bezier);
        }
        computeFinalWideBezierValueswidth(bezier, lineWidth);
        if (startY != yValue) {
            /* Note: Must single step here so that entry/exit works */
            for (int i = startY; i < yValue; i++) {
                stepToNextWideBezierInat(bezier, i);
            }
            edgeNumLinesOfput(bezier, edgeNumLinesOf(bezier) - (yValue - startY));
        }
    }

    /*
     * Initialize the current entry in the GET by stepping to the current scan line
     */

    /* BalloonEnginePlugin>>#stepToFirstWideLine */
    private void stepToFirstWideLine() {
        stepToFirstWideLineInat(getBuffer(getStartGet()), currentYGet());
    }

    /* Initialize the wide line at yValue. */

    /* BalloonEnginePlugin>>#stepToFirstWideLineIn:at: */
    private void stepToFirstWideLineInat(final int line, final int yValue) {
        /* Get some values */
        final int lineWidth = wideLineExtentOf(line);
        /* Compute the incremental values of the line */
        final int lineOffset = offsetFromWidth(lineWidth);
        final int startX = edgeXValueOf(line);
        final int startY = edgeYValueOf(line);
        stepToFirstLineInat(line, startY);
        final int nLines = edgeNumLinesOf(line);
        /* Adjust the line to start at the correct X position */
        final int xDir = lineXDirectionOf(line);
        edgeXValueOfput(line, startX - lineOffset);
        edgeNumLinesOfput(line, nLines + lineWidth);
        if (xDir > 0) {
            wideLineWidthOfput(line, lineXIncrementOf(line) + lineWidth);
        } else {
            wideLineWidthOfput(line, lineWidth - lineXIncrementOf(line));
            edgeXValueOfput(line, edgeXValueOf(line) + lineXIncrementOf(line));
        }
        /* turned on at lineOffset */
        final int yEntry = 0;
        /* turned off at zero */
        final int yExit = -nLines - lineOffset;
        wideLineEntryOfput(line, yEntry);
        wideLineExitOfput(line, yExit);
        if (yEntry >= lineOffset && yExit < 0) {
            edgeFillsValidate(line);
        } else {
            edgeFillsInvalidate(line);
        }
        if (startY != yValue) {
            for (int i = startY; i < yValue; i++) {
                stepToNextWideLineInat(line, i);
            }
            edgeNumLinesOfput(line, edgeNumLinesOf(line) - (yValue - startY));
        }
    }

    /* Process the current entry in the AET by stepping to the next scan line */

    /* BalloonEnginePlugin>>#stepToNextBezier */
    private void stepToNextBezier() {
        stepToNextBezierInat(aetBuffer(aetStartGet()), currentYGet());
    }

    /*
     * Incrementally step to the next scan line in the given bezier update data. Note: This method
     * has been written so that inlining works, e.g., not declaring updateData as 'int[]' but
     * casting it on every use.
     */

    /* BalloonEnginePlugin>>#stepToNextBezierForward:at: */
    private int stepToNextBezierForwardat(final int bzesierUpdateDataIndex, final int yValue) {
        int fwDx;
        int fwDy;
        int lastX;
        int lastY;
        final int minY;

        lastX = bezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_X);
        lastY = bezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_Y);
        fwDx = bezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_DX);
        fwDy = bezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_DY);

        /*
         * Step as long as we haven't yet reached minY and also as long as fwDy is greater than zero
         * thus stepping down. Note: The test for fwDy should not be necessary in theory but is a
         * good insurance in practice.
         */
        minY = yValue << 8;
        while (minY > lastY && fwDy >= 0) {
            lastX += fwDx + 32768 >> 16;
            lastY += fwDy + 32768 >> 16;
            fwDx += bezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_DDX);
            fwDy += bezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_DDY);
        }
        bezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_X, lastX);
        bezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_Y, lastY);
        bezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_DX, fwDx);
        bezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_DY, fwDy);
        return lastX >> 8;
    }

    /* Copy of BalloonEnginePlugin>>#stepToNextBezierForward:at: for wide beziers */
    private int stepToNextBezierForwardatWide(final int bzesierUpdateDataIndex, final int yValue) {
        int lastX = wideBezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_X);
        int lastY = wideBezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_Y);
        int fwDx = wideBezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_DX);
        int fwDy = wideBezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_DY);

        /*
         * Step as long as we haven't yet reached minY and also as long as fwDy is greater than zero
         * thus stepping down. Note: The test for fwDy should not be necessary in theory but is a
         * good insurance in practice.
         */
        final int minY = yValue << 8;
        while (minY > lastY && fwDy >= 0) {
            lastX += fwDx + 32768 >> 16;
            lastY += fwDy + 32768 >> 16;
            fwDx += wideBezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_DDX);
            fwDy += wideBezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_DDY);
        }
        wideBezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_X, lastX);
        wideBezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_Y, lastY);
        wideBezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_DX, fwDx);
        wideBezierUpdateDataOf(bzesierUpdateDataIndex, GB_UPDATE_DY, fwDy);
        return lastX >> 8;
    }

    /* Incrementally step to the next scan line in the given bezier */

    /* BalloonEnginePlugin>>#stepToNextBezierIn:at: */
    private void stepToNextBezierInat(final int bezier, final int yValue) {
        final int xValue;

        xValue = stepToNextBezierForwardat(bezier, yValue);
        edgeXValueOfput(bezier, xValue);
    }

    /* Process the current entry in the AET by stepping to the next scan line */

    /* BalloonEnginePlugin>>#stepToNextLine */
    private void stepToNextLine() {
        stepToNextLineInat(aetBuffer(aetStartGet()), currentYGet());
    }

    /* Incrementally step to the next scan line in the given line */

    /* BalloonEnginePlugin>>#stepToNextLineIn:at: */
    private void stepToNextLineInat(final int line, @SuppressWarnings("unused") final int yValue) {
        int err;
        int x;

        x = edgeXValueOf(line) + lineXIncrementOf(line);
        err = lineErrorOf(line) + lineErrorAdjUpOf(line);
        if (err > 0) {
            x += lineXDirectionOf(line);
            err -= lineErrorAdjDownOf(line);
        }
        lineErrorOfput(line, err);
        edgeXValueOfput(line, x);
    }

    /*
     * Initialize the current entry in the GET by stepping to the current scan line
     */

    /* BalloonEnginePlugin>>#stepToNextWideBezier */
    private void stepToNextWideBezier() {
        stepToNextWideBezierInat(aetBuffer(aetStartGet()), currentYGet());
    }

    /* Incrementally step to the next scan line in the given wide bezier */

    /* BalloonEnginePlugin>>#stepToNextWideBezierIn:at: */
    private void stepToNextWideBezierInat(final int bezier, final int yValue) {
        final int lineWidth = wideBezierExtentOf(bezier);
        final int lineOffset = offsetFromWidth(lineWidth);
        final int yEntry = wideBezierEntryOf(bezier) + 1;
        final int yExit = wideBezierExitOf(bezier) + 1;
        wideBezierEntryOfput(bezier, yEntry);
        wideBezierExitOfput(bezier, yExit);
        if (yEntry >= lineOffset) {
            edgeFillsValidate(bezier);
        }
        if (yExit >= 0) {
            edgeFillsInvalidate(bezier);
        }
        if (yExit + lineOffset < 0) {
            stepToNextBezierForwardat(bezier, yValue);
        } else {
            /* Adjust the last x value to the final x recorded previously */
            bezierUpdateDataOf(bezier, GB_UPDATE_X, bezierFinalXOf(bezier) << 8);
        }
        stepToNextBezierForwardatWide(bezier, yValue);
        computeFinalWideBezierValueswidth(bezier, lineWidth);
    }

    /* Process the current entry in the AET by stepping to the next scan line */

    /* BalloonEnginePlugin>>#stepToNextWideLine */
    private void stepToNextWideLine() {
        stepToNextWideLineInat(aetBuffer(aetStartGet()), currentYGet());
    }

    /* Incrementally step to the next scan line in the given wide line */

    /* BalloonEnginePlugin>>#stepToNextWideLineIn:at: */
    private void stepToNextWideLineInat(final int line, final int yValue) {
        /* Adjust entry/exit values */
        final int yEntry = wideLineEntryOf(line) + 1;
        final int yExit = wideLineExitOf(line) + 1;
        wideLineEntryOfput(line, yEntry);
        wideLineExitOfput(line, yExit);
        final int lineWidth = wideLineExtentOf(line);
        final int lineOffset = offsetFromWidth(lineWidth);
        if (yEntry >= lineOffset) {
            edgeFillsValidate(line);
        }
        if (yExit >= 0) {
            edgeFillsInvalidate(line);
        }
        final int lastX = edgeXValueOf(line);
        stepToNextLineInat(line, yValue);
        /* Check for special start/end adjustments */
        final int nextX = edgeXValueOf(line);
        if (yEntry <= lineWidth || yExit + lineOffset >= 0) {
            /* Yes, need an update */
            adjustWideLineafterSteppingFromto(line, lastX, nextX);
        }
    }

    /* BalloonEngineBase>>#stopBecauseOf: */
    private void stopBecauseOf(final int stopReason) {
        stopReasonPut(stopReason);
        engineStopped = true;
    }

    /* BalloonEngineBase>>#stopReasonGet */
    private int stopReasonGet() {
        return workBuffer[GW_STOP_REASON];
    }

    /* BalloonEngineBase>>#stopReasonPut: */
    private void stopReasonPut(final int value) {
        workBuffer[GW_STOP_REASON] = value;
    }

    /* BalloonEngineBase>>#storeEdgeStateFrom:into: */
    private void storeEdgeStateFrominto(final int edge, final PointersObject edgeOop) {
        if (slotSizeOf(edgeOop) < ET_BALLOON_EDGE_DATA_SIZE) {
            throw PrimitiveFailed.andTransferToInterpreter();
        }
        storeValue(ET_INDEX_INDEX, edgeOop, objectIndexOf(edge));
        storeValue(ET_X_VALUE_INDEX, edgeOop, edgeXValueOf(edge));
        storeValue(ET_Y_VALUE_INDEX, edgeOop, currentYGet());
        storeValue(ET_Z_VALUE_INDEX, edgeOop, edgeZValueOf(edge));
        storeValue(ET_LINES_INDEX, edgeOop, edgeNumLinesOf(edge));
        lastExportedEdgePut(edge);
    }

    /* BalloonEngineBase>>#storeEngineStateInto: */
    private void storeEngineStateInto(@SuppressWarnings("unused") final PointersObject oop) {
        objUsedPut(objUsed);
    }

    /* BalloonEngineBase>>#storeFillStateInto: */
    private void storeFillStateInto(final PointersObject fillOop) {
        final int fillIndex;
        final int leftX;
        final int rightX;

        fillIndex = lastExportedFillGet();
        leftX = lastExportedLeftXGet();
        rightX = lastExportedRightXGet();
        if (slotSizeOf(fillOop) < FT_BALLOON_FILL_DATA_SIZE) {
            throw PrimitiveFailed.andTransferToInterpreter();
        }
        storeValue(FT_INDEX_INDEX, fillOop, objectIndexOf(fillIndex));
        storeValue(FT_MIN_X_INDEX, fillOop, leftX);
        storeValue(FT_MAX_X_INDEX, fillOop, rightX);
        storeValue(FT_Y_VALUE_INDEX, fillOop, currentYGet());
    }

    /* BalloonEngineBase>>#storeRenderingState */
    private int storeRenderingState(final PointersObject edgeOop, final PointersObject fillOop) {
        assert !failed();
        if (engineStopped) {
            /* Check the stop reason and store the required information */
            storeStopStateIntoEdgefill(edgeOop, fillOop);
        }
        storeEngineStateInto(engine);
        return stopReasonGet();
    }

    /* BalloonEngineBase>>#storeStopStateIntoEdge:fill: */
    private void storeStopStateIntoEdgefill(final PointersObject edgeOop, final PointersObject fillOop) {
        final int edge;
        final int reason = stopReasonGet();
        if (reason == G_ERROR_GET_ENTRY) {
            edge = getBuffer(getStartGet());
            storeEdgeStateFrominto(edge, edgeOop);
            getStartPut(getStartGet() + 1);
        } else if (reason == G_ERROR_FILL_ENTRY) {
            storeFillStateInto(fillOop);
        } else if (reason == G_ERROR_AET_ENTRY) {
            edge = aetBuffer(aetStartGet());
            storeEdgeStateFrominto(edge, edgeOop);
        }
    }

    /* Recursively subdivide the curve on the bezier stack. */

    /* BalloonEnginePlugin>>#subdivideBezierFrom: */
    @TruffleBoundary // Highly recursive.
    private int subdivideBezierFrom(final int index) {
        final int otherIndex = subdivideBezier(index);
        if (otherIndex != index) {
            final int index1 = subdivideBezierFrom(index);
            if (engineStopped) {
                return 0;
            }
            final int index2 = subdivideBezierFrom(otherIndex);
            if (engineStopped) {
                return 0;
            }
            return Math.max(index1, index2);
        }
        return index;
    }

    /* Subdivide the given bezier curve if necessary */

    /* BalloonEnginePlugin>>#subdivideBezier: */
    private int subdivideBezier(final int index) {
        final int startY = bzStartY(index);
        /* If the receiver is horizontal, don't do anything */
        final int endY = bzEndY(index);
        if (endY == startY) {
            return index;
        }
        int deltaY = endY - startY;
        if (deltaY < 0) {
            deltaY = -deltaY;
        }
        if (deltaY > 0xFF) {
            incrementStatby(GW_BEZIER_HEIGHT_SUBDIVISIONS, 1);
            return computeBezierSplitAtHalf(index);
        }
        final int startX = bzStartX(index);
        final int endX = bzEndX(index);
        int deltaX = endX - startX;
        if (deltaX < 0) {
            deltaX = -deltaX;
        }
        if (deltaY * 32 < deltaX) {
            incrementStatby(GW_BEZIER_OVERFLOW_SUBDIVISIONS, 1);
            return computeBezierSplitAtHalf(index);
        }
        return index;
    }

    /* Check if the given bezier curve is monoton in X. If not, subdivide it */

    /* BalloonEnginePlugin>>#subdivideToBeMonotonInX: */
    private int subdivideToBeMonotonInX(final int index) {
        final int startX = bzStartX(index);
        final int viaX = bzViaX(index);
        final int endX = bzEndX(index);
        final int dx1 = viaX - startX;
        final int dx2 = endX - viaX;
        if (dx1 * dx2 >= 0) {
            return index;
        }
        incrementStatby(GW_BEZIER_MONOTON_SUBDIVISIONS, 1);
        int denom = dx2 - dx1;
        int num = dx1;
        if (num < 0) {
            num = -num;
        }
        if (denom < 0) {
            denom = -denom;
        }
        return computeBeziersplitAt(index, (double) num / (double) denom);
    }

    /* Check if the given bezier curve is monoton in Y. If not, subdivide it */

    /* BalloonEnginePlugin>>#subdivideToBeMonotonInY: */
    private int subdivideToBeMonotonInY(final int index) {
        final int startY = bzStartY(index);
        final int viaY = bzViaY(index);
        final int endY = bzEndY(index);
        final int dy1 = viaY - startY;
        final int dy2 = endY - viaY;
        if (dy1 * dy2 >= 0) {
            return index;
        }
        incrementStatby(GW_BEZIER_MONOTON_SUBDIVISIONS, 1);
        int denom = dy2 - dy1;
        int num = dy1;
        if (num < 0) {
            num = -num;
        }
        if (denom < 0) {
            denom = -denom;
        }
        return computeBeziersplitAt(index, (float) num / (float) denom);
    }

    /*
     * Check if the given bezier curve is monoton in Y, and, if desired in X. If not, subdivide it
     */

    /* BalloonEnginePlugin>>#subdivideToBeMonoton:inX: */
    private int subdivideToBeMonotoninX(final int base, final boolean doTestX) {
        final int base2 = subdivideToBeMonotonInY(base);
        int index1 = base2;
        int index2 = base2;
        if (doTestX) {
            index1 = subdivideToBeMonotonInX(base);
        }
        if (index1 > index2) {
            index2 = index1;
        }
        if (base != base2 && doTestX) {
            index1 = subdivideToBeMonotonInX(base2);
        }
        if (index1 > index2) {
            index2 = index1;
        }
        return index2;
    }

    /* BalloonEngineBase>>#toggleFillsOf: */
    private void toggleFillsOf(final int edge) {
        if (!needAvailableSpace(stackFillEntryLength() * 2)) {
            return;
        }
        final int depth = edgeZValueOf(edge) << 1;
        int fillIndex = edgeLeftFillOf(edge);
        if (fillIndex != 0) {
            toggleFilldepthrightX(fillIndex, depth, 999999999);
        }
        fillIndex = edgeRightFillOf(edge);
        if (fillIndex != 0) {
            toggleFilldepthrightX(fillIndex, depth, 999999999);
        }
        quickRemoveInvalidFillsAt(edgeXValueOf(edge));
    }

    /* Make the fill style with the given index either visible or invisible */

    /* BalloonEngineBase>>#toggleFill:depth:rightX: */
    private void toggleFilldepthrightX(final int fillIndex, final int depth, final int rightX) {
        if (stackFillSize() == 0) {
            if (allocateStackFillEntry()) {
                topFillValuePut(fillIndex);
                topFillDepthPut(depth);
                topFillRightXPut(rightX);
            }
        } else {
            final boolean hidden = hideFilldepth(fillIndex, depth);
            if (!hidden) {
                showFilldepthrightX(fillIndex, depth, rightX);
            }
        }
    }

    /* BalloonEngineBase>>#toggleWideFillOf: */
    private void toggleWideFillOf(final int edge) {
        final int type = edgeTypeOf(edge);
        final int lineWidth = switch (type) {
            case 0, 1 -> errorWrongIndex();
            case 2 -> returnWideLineWidth(edge);
            case 3 -> returnWideBezierWidth(edge);
            default -> throw SqueakException.create("Unexpected type:", type);
        };
        final int fill = switch (type) {
            case 0, 1 -> errorWrongIndex();
            case 2 -> returnWideLineFill(edge);
            case 3 -> returnWideBezierFill(edge);
            default -> throw SqueakException.create("Unexpected type:", type);
        };
        if (fill == 0) {
            return;
        }
        if (!needAvailableSpace(stackFillEntryLength())) {
            return;
        }
        /* So lines sort before interior fills */
        final int depth = (edgeZValueOf(edge) << 1) + 1;
        final int rightX = edgeXValueOf(edge) + lineWidth;
        final int index = findStackFilldepth(fill, depth);
        if (index == -1) {
            showFilldepthrightX(fill, depth, rightX);
        } else {
            if (stackFillRightX(index) < rightX) {
                stackFillRightXput(index, rightX);
            }
        }
        quickRemoveInvalidFillsAt(edgeXValueOf(edge));
    }

    /* BalloonEngineBase>>#topDepth */
    private int topDepth() {
        if (stackFillSize() == 0) {
            return -1;
        } else {
            return topFillDepth();
        }
    }

    /* BalloonEngineBase>>#topFill */
    private int topFill() {
        if (stackFillSize() == 0) {
            return 0;
        } else {
            return topFillValue();
        }
    }

    /* BalloonEngineBase>>#topFillDepth */
    private int topFillDepth() {
        return stackFillDepth(stackFillSize() - stackFillEntryLength());
    }

    /* BalloonEngineBase>>#topFillDepthPut: */
    private void topFillDepthPut(final int value) {
        stackFillDepthput(stackFillSize() - stackFillEntryLength(), value);
    }

    /* BalloonEngineBase>>#topFillRightX */
    private int topFillRightX() {
        return stackFillRightX(stackFillSize() - stackFillEntryLength());
    }

    /* BalloonEngineBase>>#topFillRightXPut: */
    private void topFillRightXPut(final int value) {
        stackFillRightXput(stackFillSize() - stackFillEntryLength(), value);
    }

    /* BalloonEngineBase>>#topFillValue */
    private int topFillValue() {
        return stackFillValue(stackFillSize() - stackFillEntryLength());
    }

    /* BalloonEngineBase>>#topFillValuePut: */
    private void topFillValuePut(final int value) {
        stackFillValueput(stackFillSize() - stackFillEntryLength(), value);
    }

    /* BalloonEngineBase>>#topRightX */
    private int topRightX() {
        if (stackFillSize() == 0) {
            return 999999999;
        } else {
            return topFillRightX();
        }
    }

    /* BalloonEngineBase>>#transformColor: */
    private int transformColor(final int fillIndex) {
        if (!(fillIndex == 0 || isFillColor(fillIndex))) {
            return fillIndex;
        }
        int b = fillIndex & 0xFF;
        int g = fillIndex >>> 8 & 0xFF;
        int r = fillIndex >>> 16 & 0xFF;
        int a = fillIndex >>> 24 & 0xFF;
        if (hasColorTransform()) {
            final int alphaScale = (a * colorTransformGet(6) + colorTransformGet(7)) / a;
            r = (r * colorTransformGet(0) + colorTransformGet(1)) * alphaScale;
            g = (g * colorTransformGet(2) + colorTransformGet(3)) * alphaScale;
            b = (b * colorTransformGet(4) + colorTransformGet(5)) * alphaScale;
            a = a * alphaScale; // TODO: check this cast is ok
            r = Math.max(r, 0);
            r = Math.min(r, 0xFF);
            g = Math.max(g, 0);
            g = Math.min(g, 0xFF);
            b = Math.max(b, 0);
            b = Math.min(b, 0xFF);
            a = Math.max(a, 0);
            a = Math.min(a, 0xFF);
        }
        if (a < 1) {
            return 0;
        }
        if (a < 0xFF && needsFlush()) {
            stopBecauseOf(G_ERROR_NEED_FLUSH);
        }
        return b + (g << 8) + (r << 16) + (a << 24);
    }

    /*
     * Transform n (n=1,2,3) points. If haveMatrix is true then the matrix contains the actual
     * transformation.
     */

    /* BalloonEngineBase>>#transformPoints: */
    private void transformPoints(final int n) {
        if (n > 0) {
            transformPoint(GW_POINT_1);
        }
        if (n > 1) {
            transformPoint(GW_POINT_2);
        }
        if (n > 2) {
            transformPoint(GW_POINT_3);
        }
        if (n > 3) {
            transformPoint(GW_POINT_4);
        }
    }

    /* Transform srcPoint into dstPoint by using the currently loaded matrix */
    /*
     * Note: This should be rewritten so that inlining works (e.g., removing the declarations and
     * adding argument coercions at the appropriate points)
     */

    /* BalloonEngineBase>>#transformPointX:y:into: */
    private void transformPointXyinto(final int xValue, final int yValue, final int dstPointIndex) {
        final int x;
        final int y;

        x = (int) ((edgeTransformGet(0) * xValue + edgeTransformGet(1) * yValue + edgeTransformGet(2)) * aaLevelGet());
        y = (int) ((edgeTransformGet(3) * xValue + edgeTransformGet(4) * yValue + edgeTransformGet(5)) * aaLevelGet());
        pointSetX(dstPointIndex, x);
        pointSetY(dstPointIndex, y);
    }

    /*
     * Transform the given point. If haveMatrix is true then use the current transformation.
     */

    /* BalloonEngineBase>>#transformPoint: */
    private void transformPoint(final int pointIndex) {
        if (hasEdgeTransform()) {
            /* Note: AA adjustment is done in #transformPoint: for higher accuracy */
            transformPointinto(pointIndex, pointIndex);
        } else {
            /* Multiply each component by aaLevel and add a half pixel */
            pointSetX(pointIndex, (pointGetX(pointIndex) + destOffsetXGet()) * aaLevelGet());
            pointSetY(pointIndex, (pointGetY(pointIndex) + destOffsetYGet()) * aaLevelGet());
        }
    }

    /* Transform srcPoint into dstPoint by using the currently loaded matrix */
    /*
     * Note: This method has been rewritten so that inlining works (e.g., removing the declarations
     * and adding argument coercions at the appropriate points)
     */

    /* BalloonEngineBase>>#transformPoint:into: */
    private void transformPointinto(final int srcPointIndex, final int dstPointIndex) {
        transformPointXyinto(pointGetX(srcPointIndex), pointGetY(srcPointIndex), dstPointIndex);
    }

    /* Transform the given width */

    /* BalloonEngineBase>>#transformWidth: */
    private int transformWidth(final int w) {
        if (w == 0) {
            return 0;
        }
        point1SetX(0);
        point1SetY(0);
        point2SetX(w << 8);
        point2SetY(0);
        point3SetX(0);
        point3SetY(w << 8);
        transformPoints(3);
        int deltaX = point2GetX() - point1GetX();
        int deltaY = point2GetY() - point1GetY();
        int dstWidth = ((int) Math.sqrt(deltaX * deltaX + deltaY * deltaY) + 128) / 256;
        deltaX = point3GetX() - point1GetX();
        deltaY = point3GetY() - point1GetY();
        final int dstWidth2 = ((int) Math.sqrt(deltaX * deltaX + deltaY * deltaY) + 128) / 256;
        if (dstWidth2 < dstWidth) {
            dstWidth = dstWidth2;
        }
        if (dstWidth == 0) {
            return 1;
        } else {
            return dstWidth;
        }
    }

    /* BalloonEngineBase>>#uncheckedTransformColor: */
    private int uncheckedTransformColor(final int fillIndex) {
        if (!hasColorTransform()) {
            return fillIndex;
        }
        int b = fillIndex & 0xFF;
        int g = fillIndex >>> 8 & 0xFF;
        int r = fillIndex >>> 16 & 0xFF;
        int a = fillIndex >>> 24 & 0xFF;
        r = r * colorTransformGet(0) + colorTransformGet(1);
        g = g * colorTransformGet(2) + colorTransformGet(3);
        b = b * colorTransformGet(4) + colorTransformGet(5);
        a = a * colorTransformGet(6) + colorTransformGet(7);
        r = Math.max(r, 0);
        r = Math.min(r, 0xFF);
        g = Math.max(g, 0);
        g = Math.min(g, 0xFF);
        b = Math.max(b, 0);
        b = Math.min(b, 0xFF);
        a = Math.max(a, 0);
        a = Math.min(a, 0xFF);
        if (a < 16) {
            return 0;
        }
        return b + (g << 8) + (r << 16) + (a << 24);
    }

    /* BalloonEngineBase>>#wbSizeGet */
    private int wbSizeGet() {
        return workBuffer[GW_SIZE];
    }

    /* BalloonEngineBase>>#wbSizePut: */
    private void wbSizePut(final int value) {
        workBuffer[GW_SIZE] = value;
    }

    /* BalloonEngineBase>>#wbStackClear */
    private void wbStackClear() {
        wbTopPut(wbSizeGet());
    }

    /* BalloonEngineBase>>#wbStackPop: */
    private void wbStackPop(final int nItems) {
        wbTopPut(wbTopGet() + nItems);
    }

    /* BalloonEngineBase>>#wbStackPush: */
    private boolean wbStackPush(final int nItems) {
        if (!allocateStackEntry(nItems)) {
            return false;
        }
        wbTopPut(wbTopGet() - nItems);
        return true;
    }

    /* BalloonEngineBase>>#wbStackSize */
    private int wbStackSize() {
        return wbSizeGet() - wbTopGet();
    }

    /* BalloonEngineBase>>#wbStackValue: */
    private int wbStackValue(final int index) {
        return workBuffer[wbTopGet() + index];
    }

    /* BalloonEngineBase>>#wbStackValue:put: */
    private void wbStackValueput(final int index, final int value) {
        workBuffer[wbTopGet() + index] = value;
    }

    /* BalloonEngineBase>>#wbTopGet */
    private int wbTopGet() {
        return workBuffer[GW_BUFFER_TOP];
    }

    /* BalloonEngineBase>>#wbTopPut: */
    private void wbTopPut(final int value) {
        workBuffer[GW_BUFFER_TOP] = value;
    }

    /* BalloonEnginePlugin>>#wideBezierEntryOf: */
    private int wideBezierEntryOf(final int line) {
        return objat(line, GB_WIDE_ENTRY);
    }

    /* BalloonEnginePlugin>>#wideBezierEntryOf:put: */
    private void wideBezierEntryOfput(final int line, final int value) {
        objatput(line, GB_WIDE_ENTRY, value);
    }

    /* BalloonEnginePlugin>>#wideBezierExitOf: */
    private int wideBezierExitOf(final int line) {
        return objat(line, GB_WIDE_EXIT);
    }

    /* BalloonEnginePlugin>>#wideBezierExitOf:put: */
    private void wideBezierExitOfput(final int line, final int value) {
        objatput(line, GB_WIDE_EXIT, value);
    }

    /* BalloonEnginePlugin>>#wideBezierExtentOf: */
    private int wideBezierExtentOf(final int bezier) {
        return objat(bezier, GB_WIDE_EXTENT);
    }

    /* BalloonEnginePlugin>>#wideBezierExtentOf:put: */
    private void wideBezierExtentOfput(final int bezier, final int value) {
        objatput(bezier, GB_WIDE_EXTENT, value);
    }

    /* BalloonEnginePlugin>>#wideBezierFillOf: */
    private int wideBezierFillOf(final int bezier) {
        return objat(bezier, GB_WIDE_FILL);
    }

    /* BalloonEnginePlugin>>#wideBezierFillOf:put: */
    private void wideBezierFillOfput(final int bezier, final int value) {
        objatput(bezier, GB_WIDE_FILL, value);
    }

    /* BalloonEnginePlugin>>#wideBezierUpdateDataOf: */
    private int wideBezierUpdateDataOf(final int bezier, final int index) {
        return workBuffer[wideBezierUpdateDataIndexOf(bezier) + index];
    }

    private void wideBezierUpdateDataOf(final int bezier, final int index, final int value) {
        workBuffer[wideBezierUpdateDataIndexOf(bezier) + index] = value;
    }

    private int wideBezierUpdateDataIndexOf(final int bezier) {
        return objBufferIndex + bezier + GB_WIDE_UPDATE_DATA;
    }

    /* BalloonEnginePlugin>>#wideBezierWidthOf: */
    private int wideBezierWidthOf(final int line) {
        return objat(line, GB_WIDE_WIDTH);
    }

    /* BalloonEnginePlugin>>#wideBezierWidthOf:put: */
    private void wideBezierWidthOfput(final int line, final int value) {
        objatput(line, GB_WIDE_WIDTH, value);
    }

    /* BalloonEnginePlugin>>#wideLineEntryOf: */
    private int wideLineEntryOf(final int line) {
        return objat(line, GL_WIDE_ENTRY);
    }

    /* BalloonEnginePlugin>>#wideLineEntryOf:put: */
    private void wideLineEntryOfput(final int line, final int value) {
        objatput(line, GL_WIDE_ENTRY, value);
    }

    /* BalloonEnginePlugin>>#wideLineExitOf: */
    private int wideLineExitOf(final int line) {
        return objat(line, GL_WIDE_EXIT);
    }

    /* BalloonEnginePlugin>>#wideLineExitOf:put: */
    private void wideLineExitOfput(final int line, final int value) {
        objatput(line, GL_WIDE_EXIT, value);
    }

    /* BalloonEnginePlugin>>#wideLineExtentOf: */
    private int wideLineExtentOf(final int line) {
        return objat(line, GL_WIDE_EXTENT);
    }

    /* BalloonEnginePlugin>>#wideLineExtentOf:put: */
    private void wideLineExtentOfput(final int line, final int value) {
        objatput(line, GL_WIDE_EXTENT, value);
    }

    /* BalloonEnginePlugin>>#wideLineFillOf: */
    private int wideLineFillOf(final int line) {
        return objat(line, GL_WIDE_FILL);
    }

    /* BalloonEnginePlugin>>#wideLineFillOf:put: */
    private void wideLineFillOfput(final int line, final int value) {
        objatput(line, GL_WIDE_FILL, value);
    }

    /* BalloonEnginePlugin>>#wideLineWidthOf: */
    private int wideLineWidthOf(final int line) {
        return objat(line, GL_WIDE_WIDTH);
    }

    /* BalloonEnginePlugin>>#wideLineWidthOf:put: */
    private void wideLineWidthOfput(final int line, final int value) {
        objatput(line, GL_WIDE_WIDTH, value);
    }

    /* BalloonEngineBase>>#workBufferPut: */
    private void workBufferPut(final NativeObject wbOop) {
        workBuffer = wbOop.getIntStorage();
    }

    /*
     * POLYFILLS
     */

    private static boolean failed() {
        return false;
    }

    private static int slotSizeOf(final PointersObject object) {
        return object.size();
    }

    private static long ioMicroMSecs() {
        return System.currentTimeMillis();
    }

    @TruffleBoundary(transferToInterpreterOnException = false)
    private static void storeValue(final int i, final PointersObject object, final Object value) {
        // TODO: avoid slow operation
        object.instVarAtPut0Slow(i, value);
    }

    private static boolean isPointers(final AbstractSqueakObject object) {
        return SqueakGuards.isPointersObject(object);
    }

    private static boolean isWords(final NativeObject object) {
        return object.isIntType();
    }

    private static int slotSizeOf(final NativeObject words) {
        return words.getIntLength();
    }

    private static ClassObject fetchClassOf(final NativeObject object) {
        return object.getSqueakClass();
    }

    private static ArrayObject fetchArrayofObject(final int index, final PointersObject object) {
        return (ArrayObject) object.instVarAt0Slow(index);
    }

    private static Object fetchObjectofObject(final int index, final PointersObject object) {
        return object.instVarAt0Slow(index);
    }

    private static PointersObject fetchPointerofObject(final int index, final PointersObject object) {
        return (PointersObject) object.instVarAt0Slow(index);
    }

    private static NativeObject fetchNativeofObject(final int index, final PointersObject object) {
        return (NativeObject) object.instVarAt0Slow(index);
    }

    private static int fetchIntegerofObject(final int index, final PointersObject object) {
        return (int) (long) object.instVarAt0Slow(index);
    }

    private void workbufferAtput(final int index, final int value) {
        workBuffer[index] = value;
    }

    private static PointersObject fetchPointerofObject(final int index, final ArrayObject object) {
        return (PointersObject) object.getObjectStorage()[index];
    }

    private static int slotSizeOf(final ArrayObject object) {
        if (object.isEmptyType()) {
            return object.getEmptyLength();
        } else {
            return object.getObjectLength();
        }
    }

    private static boolean isWords(final AbstractSqueakObject object) {
        return object instanceof final NativeObject o && o.isIntType();
    }

    private static boolean isArray(final AbstractSqueakObject object) {
        return SqueakGuards.isArrayObject(object);
    }

    private static boolean isBitmap(final AbstractSqueakObjectWithClassAndHash object) {
        final ClassObject squeakClass = object.getSqueakClass();
        return squeakClass.getImage().isBitmapClass(squeakClass);
    }

    private int aetBuffer(final int index) {
        return workBuffer[aetBufferIndex + index];
    }

    private void aetBuffer(final int index, final int value) {
        workBuffer[aetBufferIndex + index] = value;
    }

    private int getBuffer(final int index) {
        return workBuffer[getBufferIndex + index];
    }

    private void getBuffer(final int index, final int value) {
        workBuffer[getBufferIndex + index] = value;
    }

    private int unsignedAt(final int index) {
        return workBuffer[index];
    }

    private static int div(final int a, final int b) {
        return Math.floorDiv(a, b);
    }

    private static int mod(final int a, final int b) {
        return a - div(a, b) * b;
    }

    private static int shl(final int a, final int b) {
        return b > 31 ? 0 : a << b;
    }

    private static int shr(final int a, final int b) {
        return b > 31 ? 0 : a >>> b;
    }

    private static int toInt(final Object value) {
        if (value instanceof final Long longValue) {
            return longValue.intValue();
        } else if (value instanceof final Double doubleValue) {
            return doubleValue.intValue();
        } else if (value instanceof final FloatObject floatValue) {
            return (int) floatValue.getValue();
        } else {
            throw PrimitiveFailed.andTransferToInterpreter();
        }
    }
}
