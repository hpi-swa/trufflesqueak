/*
 * Copyright (c) 2017-2025 Software Architecture Group, Hasso Plattner Institute
 * Copyright (c) 2021-2025 Oracle and/or its affiliates
 *
 * Licensed under the MIT License.
 */
package de.hpi.swa.trufflesqueak.nodes.plugins;

import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.CompilerDirectives.CompilationFinal;
import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;

import de.hpi.swa.trufflesqueak.exceptions.PrimitiveFailed;
import de.hpi.swa.trufflesqueak.model.AbstractSqueakObjectWithClassAndHash;
import de.hpi.swa.trufflesqueak.model.BooleanObject;
import de.hpi.swa.trufflesqueak.model.ClassObject;
import de.hpi.swa.trufflesqueak.model.NativeObject;
import de.hpi.swa.trufflesqueak.model.PointersObject;
import de.hpi.swa.trufflesqueak.nodes.SqueakGuards;
import de.hpi.swa.trufflesqueak.util.MiscUtils;

/* Automatically generated by
    VMPluginCodeGenerator * VMMaker.oscog-eem.2518 uuid: 33deb326-de86-45aa-be20-d64c10de4e70 from
    DeflatePlugin * VMMaker.oscog-eem.2518 uuid: 33deb326-de86-45aa-be20-d64c10de4e70
 */

public final class Zip {
    /* Constants */
    private static final int DeflateHashMask = 0x7FFF;
    private static final int DeflateHashShift = 5;
    private static final int DeflateHashTableSize = 32768;
    private static final int DeflateMaxDistance = 0x8000;
    private static final int DeflateMaxDistanceCodes = 30;
    private static final int DeflateMaxLiteralCodes = 0x11E;
    private static final int DeflateMaxMatch = 258;
    private static final int DeflateMinMatch = 3;
    private static final int DeflateWindowMask = 0x7FFF;
    private static final int DeflateWindowSize = 32768;
    private static final int MaxBits = 16;
    private static final int StateNoMoreData = 1;

    @CompilationFinal private int readStreamInstSize;
    @CompilationFinal private int writeStreamInstSize;
    @CompilationFinal(dimensions = 1) private static final int[] zipBaseDistance = {
                    /* 0 */ 0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768,
                    /* 20 */ 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576
    };
    @CompilationFinal(dimensions = 1) private static final byte[] zipBaseLength = {
                    /* 0 */ 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
                    /* 20 */ 64, 80, 96, 112, (byte) 128, (byte) 160, (byte) 192, (byte) 224, 0
    };
    private int zipBitBuf;
    private int zipBitPos;
    private int zipBlockPos;
    // private int zipBlockStart;
    private byte[] zipCollection;
    private int zipCollectionSize;
    @CompilationFinal(dimensions = 1) private static final long[] zipCrcTable = {
                    /* 0 */ 0, 1996959894, 3993919788L, 2567524794L, 124634137, 1886057615, 3915621685L,
                    /* 7 */ 2657392035L, 249268274, 2044508324, 3772115230L, 2547177864L, 162941995, 2125561021,
                    /* 14 */ 3887607047L, 2428444049L, 498536548, 1789927666, 4089016648L, 2227061214L,
                    /* 20 */ 450548861, 1843258603, 4107580753L, 2211677639L, 325883990, 1684777152, 4251122042L,
                    /* 27 */ 2321926636L, 335633487, 1661365465, 4195302755L, 2366115317L, 997073096, 1281953886,
                    /* 34 */ 3579855332L, 2724688242L, 1006888145, 1258607687, 3524101629L, 2768942443L,
                    /* 40 */ 901097722, 1119000684, 3686517206L, 2898065728L, 853044451, 1172266101, 3705015759L,
                    /* 47 */ 2882616665L, 651767980, 1373503546, 3369554304L, 3218104598L, 565507253, 1454621731,
                    /* 54 */ 3485111705L, 3099436303L, 671266974, 1594198024, 3322730930L, 2970347812L,
                    /* 60 */ 795835527, 1483230225, 3244367275L, 3060149565L, 1994146192, 31158534, 2563907772L,
                    /* 67 */ 4023717930L, 1907459465, 112637215, 2680153253L, 3904427059L, 2013776290, 251722036,
                    /* 74 */ 2517215374L, 3775830040L, 2137656763, 141376813, 2439277719L, 3865271297L,
                    /* 80 */ 1802195444, 476864866, 2238001368L, 4066508878L, 1812370925, 453092731, 2181625025L,
                    /* 87 */ 4111451223L, 1706088902, 314042704, 2344532202L, 4240017532L, 1658658271, 366619977,
                    /* 94 */ 2362670323L, 4224994405L, 1303535960, 984961486, 2747007092L, 3569037538L,
                    /* 100 */ 1256170817, 1037604311, 2765210733L, 3554079995L, 1131014506, 879679996, 2909243462L,
                    /* 107 */ 3663771856L, 1141124467, 855842277, 2852801631L, 3708648649L, 1342533948, 654459306,
                    /* 114 */ 3188396048L, 3373015174L, 1466479909, 544179635, 3110523913L, 3462522015L,
                    /* 120 */ 1591671054, 702138776, 2966460450L, 3352799412L, 1504918807, 783551873, 3082640443L,
                    /* 127 */ 3233442989L, 3988292384L, 2596254646L, 62317068, 1957810842, 3939845945L, 2647816111L,
                    /* 134 */ 81470997, 1943803523, 3814918930L, 2489596804L, 225274430, 2053790376,
                    /* 140 */ 3826175755L, 2466906013L, 167816743, 2097651377, 4027552580L, 2265490386L, 503444072,
                    /* 147 */ 1762050814, 4150417245L, 2154129355L, 426522225, 1852507879, 4275313526L, 2312317920L,
                    /* 154 */ 282753626, 1742555852, 4189708143L, 2394877945L, 397917763, 1622183637,
                    /* 160 */ 3604390888L, 2714866558L, 953729732, 1340076626, 3518719985L, 2797360999L, 1068828381,
                    /* 167 */ 1219638859, 3624741850L, 2936675148L, 906185462, 1090812512, 3747672003L, 2825379669L,
                    /* 174 */ 829329135, 1181335161, 3412177804L, 3160834842L, 628085408, 1382605366,
                    /* 180 */ 3423369109L, 3138078467L, 570562233, 1426400815, 3317316542L, 2998733608L, 733239954,
                    /* 187 */ 1555261956, 3268935591L, 3050360625L, 752459403, 1541320221, 2607071920L, 3965973030L,
                    /* 194 */ 1969922972, 40735498, 2617837225L, 3943577151L, 1913087877, 83908371,
                    /* 200 */ 2512341634L, 3803740692L, 2075208622, 213261112, 2463272603L, 3855990285L, 2094854071,
                    /* 207 */ 198958881, 2262029012L, 4057260610L, 1759359992, 534414190, 2176718541L, 4139329115L,
                    /* 214 */ 1873836001, 414664567, 2282248934L, 4279200368L, 1711684554, 285281116,
                    /* 220 */ 2405801727L, 4167216745L, 1634467795, 376229701, 2685067896L, 3608007406L, 1308918612,
                    /* 227 */ 956543938, 2808555105L, 3495958263L, 1231636301, 1047427035, 2932959818L, 3654703836L,
                    /* 234 */ 1088359270, 936918000, 2847714899L, 3736837829L, 1202900863, 817233897,
                    /* 240 */ 3183342108L, 3401237130L, 1404277552, 615818150, 3134207493L, 3453421203L, 1423857449,
                    /* 247 */ 601450431, 3009837614L, 3294710456L, 1567103746, 711928724, 3020668471L, 3272380065L,
                    /* 254 */ 1510334235, 755167117
    };
    @CompilationFinal(dimensions = 1) private static final int[] zipDistanceCodes = {
                    /* 0 */ 0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8,
                    /* 20 */ 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10,
                    /* 40 */ 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
                    /* 60 */ 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
                    /* 80 */ 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
                    /* 100 */ 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
                    /* 120 */ 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
                    /* 140 */ 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
                    /* 160 */ 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
                    /* 180 */ 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
                    /* 200 */ 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
                    /* 220 */ 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
                    /* 240 */ 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17,
                    /* 260 */ 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
                    /* 280 */ 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
                    /* 300 */ 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
                    /* 320 */ 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
                    /* 340 */ 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
                    /* 360 */ 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
                    /* 380 */ 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
                    /* 400 */ 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
                    /* 420 */ 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
                    /* 440 */ 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
                    /* 460 */ 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
                    /* 480 */ 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
                    /* 500 */ 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
    };
    private int[] zipDistanceFreq;
    private int[] zipDistances;
    private int[] zipDistTable;
    private int zipDistTableSize;
    @CompilationFinal(dimensions = 1) private static final int[] zipExtraDistanceBits = {
                    /* 0 */ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
                    /* 20 */ 9, 9, 10, 10, 11, 11, 12, 12, 13, 13
    };
    @CompilationFinal(dimensions = 1) private static final int[] zipExtraLengthBits = {
                    /* 0 */ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3,
                    /* 20 */ 4, 4, 4, 4, 5, 5, 5, 5, 0
    };
    private int[] zipHashHead;
    private int[] zipHashTail;
    private int zipHashValue;
    private int zipLiteralCount;
    private int[] zipLiteralFreq;
    private int zipLiteralSize;
    private byte[] zipLiterals;
    private int[] zipLitTable;
    private int zipLitTableSize;
    private int zipMatchCount;
    @CompilationFinal(dimensions = 1) private static final int[] zipMatchLengthCodes = {
                    /* 0 */ 257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268,
                    /* 16 */ 269, 269, 269, 269,
                    /* 20 */ 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272, 273, 273, 273, 273,
                    /* 36 */ 273, 273, 273, 273,
                    /* 40 */ 274, 274, 274, 274, 274, 274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275,
                    /* 56 */ 276, 276, 276, 276,
                    /* 60 */ 276, 276, 276, 276, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,
                    /* 76 */ 277, 277, 277, 277,
                    /* 80 */ 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
                    /* 96 */ 279, 279, 279, 279,
                    /* 100 */ 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280,
                    /* 116 */ 280, 280, 280, 280,
                    /* 120 */ 280, 280, 280, 280, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281, 281,
                    /* 136 */ 281, 281, 281, 281,
                    /* 140 */ 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
                    /* 156 */ 281, 281, 281, 281,
                    /* 160 */ 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
                    /* 176 */ 282, 282, 282, 282,
                    /* 180 */ 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 283, 283, 283, 283,
                    /* 196 */ 283, 283, 283, 283,
                    /* 200 */ 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
                    /* 216 */ 283, 283, 283, 283,
                    /* 220 */ 283, 283, 283, 283, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,
                    /* 236 */ 284, 284, 284, 284,
                    /* 240 */ 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284
    };
    private int zipPosition;
    private int zipReadLimit;
    private byte[] zipSource;
    private int zipSourceLimit;
    private int zipSourcePos;
    private int zipState;

    /*
     * Compare the two strings and return the length of matching characters. minLength is a lower
     * bound for match lengths that will be accepted. Note: here and matchPos are zero based.
     */

    /* DeflatePlugin>>#compare:with:min: */
    private int comparewithmin(final int here, final int matchPos, final int minLength) {
        /* First test if we can actually get longer than minLength */
        if (zipCollection[here + minLength] != zipCollection[matchPos + minLength]) {
            return 0;
        }
        if (zipCollection[here + minLength - 1] != zipCollection[matchPos + minLength - 1]) {
            return 0;
        }
        if (zipCollection[here] != zipCollection[matchPos]) {
            return 0;
        }
        if (zipCollection[here + 1] != zipCollection[matchPos + 1]) {
            return 1;
        }
        int length = 2;
        while (length < DeflateMaxMatch && zipCollection[here + length] == zipCollection[matchPos + length]) {
            length++;
        }
        return length;
    }

    /*
     * Continue deflating the receiver's collection from blockPosition to lastIndex. Note that
     * lastIndex must be at least MaxMatch away from the end of collection
     */

    /* DeflatePlugin>>#deflateBlock:chainLength:goodMatch: */
    private boolean deflateBlockchainLengthgoodMatch(final int lastIndex, final int chainLength, final int goodMatch) {
        if (zipBlockPos > lastIndex) {
            return false;
        }
        if (zipLiteralCount >= zipLiteralSize) {
            return true;
        }
        int hereLength = 0;
        int hereMatch = 0;
        int hasMatch = 0;
        int here = zipBlockPos;
        while (here <= lastIndex) {
            if (hasMatch == 0) {
                /* Find the first match */
                final int matchResult = findMatchlastLengthlastMatchchainLengthgoodMatch(here, DeflateMinMatch - 1, here, chainLength, goodMatch);
                insertStringAt(here);
                hereMatch = matchResult & 0xFFFF;
                hereLength = matchResult >> 16;
            }
            final int matchResult = findMatchlastLengthlastMatchchainLengthgoodMatch(here + 1, hereLength, hereMatch, chainLength, goodMatch);
            final int newMatch = matchResult & 0xFFFF;
            /*
             * Now check if the next match is better than the current one. If not, output the
             * current match (provided that the current match is at least MinMatch long)
             */
            final int newLength = matchResult >> 16;
            final boolean flushNeeded;
            if (hereLength >= newLength && hereLength >= DeflateMinMatch) {
                /* Encode the current match */
                flushNeeded = encodeMatchdistance(hereLength, here - hereMatch);
                for (int i = 1; i < hereLength; i++) {
                    insertStringAt(++here);
                }
                hasMatch = 0;
                here++;
            } else {
                /*
                 * Either the next match is better than the current one or we didn't have a good
                 * match after all (e.g., current match length < MinMatch). Output a single literal.
                 */
                flushNeeded = encodeLiteral(Byte.toUnsignedInt(zipCollection[here]));
                here++;
                if (here <= lastIndex && !flushNeeded) {
                    /* Cache the results for the next round */
                    insertStringAt(here);
                    hasMatch = 1;
                    hereMatch = newMatch;
                    hereLength = newLength;
                }
            }
            if (flushNeeded) {
                zipBlockPos = here;
                return true;
            }
        }
        zipBlockPos = here;
        return false;
    }

    /*
     * Determine the inst size of the class above DeflateStream by looking for the first class whose
     * inst size is less than 13.
     */

    /* InflatePlugin>>#determineSizeOfReadStream: */
    private boolean determineSizeOfReadStream(final AbstractSqueakObjectWithClassAndHash rcvr) {
        ClassObject squeakClass = rcvr.getSqueakClass();
        while (squeakClass != null && squeakClass.getBasicInstanceSize() >= 13) {
            squeakClass = squeakClass.getSuperclassOrNull();
        }
        if (squeakClass == null) {
            return false;
        }
        CompilerDirectives.transferToInterpreterAndInvalidate();
        readStreamInstSize = squeakClass.getBasicInstanceSize();
        return true;
    }

    /*
     * Determine the inst size of the class above DeflateStream or ZipEncoder by looking for the
     * first class whose inst size is less than 7.
     */

    /* DeflatePlugin>>#determineSizeOfWriteStream: */
    private boolean determineSizeOfWriteStream(final AbstractSqueakObjectWithClassAndHash rcvr) {
        ClassObject squeakClass = rcvr.getSqueakClass();
        while (squeakClass != null && squeakClass.getBasicInstanceSize() >= 7) {
            squeakClass = squeakClass.getSuperclassOrNull();
        }
        if (squeakClass == null) {
            return false;
        }
        CompilerDirectives.transferToInterpreterAndInvalidate();
        writeStreamInstSize = squeakClass.getBasicInstanceSize();
        return true;
    }

    /* Encode the given literal */

    /* DeflatePlugin>>#encodeLiteral: */
    private boolean encodeLiteral(final int lit) {
        zipLiterals[zipLiteralCount] = (byte) lit;
        zipDistances[zipLiteralCount] = 0;
        zipLiteralFreq[lit] = zipLiteralFreq[lit] + 1;
        zipLiteralCount++;
        return zipLiteralCount == zipLiteralSize || (zipLiteralCount & 0xFFF) == 0 && shouldFlush();
    }

    /* Encode the given match of length length starting at dist bytes ahead */

    /* DeflatePlugin>>#encodeMatch:distance: */
    private boolean encodeMatchdistance(final int length, final int dist) {
        final int distance;
        final int literal;

        zipLiterals[zipLiteralCount] = (byte) (length - DeflateMinMatch);
        zipDistances[zipLiteralCount] = dist;
        literal = zipMatchLengthCodes[length - DeflateMinMatch];
        zipLiteralFreq[literal] = zipLiteralFreq[literal] + 1;
        if (dist < 257) {
            distance = zipDistanceCodes[dist - 1];
        } else {
            distance = zipDistanceCodes[256 + (dist - 1 >> 7)];
        }
        zipDistanceFreq[distance] = zipDistanceFreq[distance] + 1;
        zipLiteralCount++;
        zipMatchCount++;
        return zipLiteralCount == zipLiteralSize || (zipLiteralCount & 0xFFF) == 0 && shouldFlush();
    }

    /*
     * Find the longest match for the string starting at here. If there is no match longer than
     * lastLength return lastMatch/lastLength. Traverse at most maxChainLength entries in the hash
     * table. Stop if a match of at least goodMatch size has been found.
     */

    /* DeflatePlugin>>#findMatch:lastLength:lastMatch:chainLength:goodMatch: */
    private int findMatchlastLengthlastMatchchainLengthgoodMatch(final int here, final int lastLength, final int lastMatch, final int maxChainLength, final int goodMatch) {
        /* Compute the default match result */

        /* There is no way to find a better match than MaxMatch */
        int matchResult = lastLength << 16 | lastMatch;
        if (lastLength >= DeflateMaxMatch) {
            return matchResult;
        }
        /* Compute the distance to the (possible) match */
        int matchPos = zipHashHead[updateHashAt(here + DeflateMinMatch - 1)];
        /* Note: It is required that 0 < distance < MaxDistance */
        final int distance = here - matchPos;
        if (!(distance > 0 && distance < DeflateMaxDistance)) {
            return matchResult;
        }
        /* Max. nr of match chain to search */
        int chainLength = maxChainLength;
        final int limit;
        if (here > DeflateMaxDistance) {
            /* Limit for matches that are too old */
            limit = here - DeflateMaxDistance;
        } else {
            limit = 0;
        }
        int bestLength = lastLength;
        while (true) {
            /* Compare the current string with the string at match position */

            /* Truncate accidental matches beyound stream position */
            int length = comparewithmin(here, matchPos, bestLength);
            if (here + length > zipPosition) {
                length = zipPosition - here;
            }
            if (length == DeflateMinMatch && here - matchPos > DeflateMaxDistance / 4) {
                length = DeflateMinMatch - 1;
            }
            if (length > bestLength) {
                /* We have a new (better) match than before */
                /* Compute the new match result */
                matchResult = length << 16 | matchPos;
                /* There is no way to find a better match than MaxMatch */
                bestLength = length;
                if (bestLength >= DeflateMaxMatch) {
                    return matchResult;
                }
                if (bestLength > goodMatch) {
                    return matchResult;
                }
            }
            if (--chainLength <= 0) {
                return matchResult;
            }
            matchPos = zipHashTail[matchPos & DeflateWindowMask];
            if (matchPos <= limit) {
                return matchResult;
            }
        }
    }

    /*
     * Insert the string at the given start position into the hash table. Note: The hash value is
     * updated starting at MinMatch-1 since all strings before have already been inserted into the
     * hash table (and the hash value is updated as well).
     */

    /* DeflatePlugin>>#insertStringAt: */
    private void insertStringAt(final int here) {
        zipHashValue = updateHashAt(here + DeflateMinMatch - 1);
        final int prevEntry = zipHashHead[zipHashValue];
        zipHashHead[zipHashValue] = here;
        zipHashTail[here & DeflateWindowMask] = prevEntry;
    }

    /* DeflatePlugin>>#loadDeflateStreamFrom: */
    private boolean loadDeflateStreamFrom(final PointersObject rcvr) {
        if (writeStreamInstSize == 0) {
            if (!determineSizeOfWriteStream(rcvr)) {
                return false;
            }
            if (rcvr.size() < writeStreamInstSize + 5) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                writeStreamInstSize = 0;
                return false;
            }
        }
        zipCollection = fetchBytePointerOfObject(rcvr, 0);
        zipCollectionSize = zipCollection.length;
        zipPosition = fetchIntegerofObject(1, rcvr);
        /* zipWriteLimit := interpreterProxy fetchInteger: 3 ofObject: rcvr. */
        zipReadLimit = fetchIntegerofObject(2, rcvr);
        zipHashHead = fetchNativePointerOfObjectWithExpectedLength(rcvr, writeStreamInstSize, DeflateHashTableSize);
        zipHashTail = fetchNativePointerOfObjectWithExpectedLength(rcvr, writeStreamInstSize + 1, DeflateWindowSize);
        zipHashValue = fetchIntegerofObject(writeStreamInstSize + 2, rcvr);
        /*
         * zipBlockStart := interpreterProxy fetchInteger: writeStreamInstSize + 4 ofObject: rcvr.
         */
        zipBlockPos = fetchIntegerofObject(writeStreamInstSize + 3, rcvr);
        zipLiterals = fetchBytePointerOfObject(rcvr, writeStreamInstSize + 5);
        zipLiteralSize = zipLiterals.length;
        zipDistances = fetchNativePointerOfObjectWithExpectedLength(rcvr, writeStreamInstSize + 6, zipLiteralSize);
        zipLiteralFreq = fetchNativePointerOfObjectWithExpectedLength(rcvr, writeStreamInstSize + 7, DeflateMaxLiteralCodes);
        zipDistanceFreq = fetchNativePointerOfObjectWithExpectedLength(rcvr, writeStreamInstSize + 8, DeflateMaxDistanceCodes);
        zipLiteralCount = fetchIntegerofObject(writeStreamInstSize + 9, rcvr);
        zipMatchCount = fetchIntegerofObject(writeStreamInstSize + 10, rcvr);
        return true;
    }

    /*
     * Require: zipCollection, zipCollectionSize, zipPosition, zipBitBuf, zipBitPos.
     */

    /* DeflatePlugin>>#nextZipBits:put: */
    private void nextZipBitsput(final int nBits, final int value) {
        if (!(value >= 0 && 1L << nBits > value)) {
            throw PrimitiveFailed.GENERIC_ERROR;
        }
        zipBitBuf = zipBitBuf | shl(value, zipBitPos);
        zipBitPos += nBits;
        while (zipBitPos >= 8 && zipPosition < zipCollectionSize) {
            zipCollection[zipPosition] = (byte) zipBitBuf;
            zipPosition++;
            zipBitBuf = zipBitBuf >> 8;
            zipBitPos -= 8;
        }
    }

    /* Primitive. Deflate the current contents of the receiver. */

    /* DeflatePlugin>>#primitiveDeflateBlock */
    public boolean primitiveDeflateBlock(final PointersObject rcvr, final int lastIndex, final int chainLength, final int goodMatch) {
        if (!loadDeflateStreamFrom(rcvr)) {
            throw PrimitiveFailed.GENERIC_ERROR;
        }
        final boolean result = deflateBlockchainLengthgoodMatch(lastIndex, chainLength, goodMatch);
        /* Store back modified values */
        storeIntegerofObjectwithValue(writeStreamInstSize + 2, rcvr, zipHashValue);
        storeIntegerofObjectwithValue(writeStreamInstSize + 3, rcvr, zipBlockPos);
        storeIntegerofObjectwithValue(writeStreamInstSize + 9, rcvr, zipLiteralCount);
        storeIntegerofObjectwithValue(writeStreamInstSize + 10, rcvr, zipMatchCount);
        return BooleanObject.wrap(result);
    }

    /* Primitive. Update the hash tables after data has been moved by delta. */

    /* DeflatePlugin>>#primitiveDeflateUpdateHashTable */
    public static void primitiveDeflateUpdateHashTable(final NativeObject table, final int delta) {
        final int[] tableInts = table.getIntStorage();
        final int tableSize = tableInts.length;
        for (int i = 0; i < tableSize; i++) {
            final int entry = tableInts[i];
            if (entry >= delta) {
                tableInts[i] = entry - delta;
            } else {
                tableInts[i] = 0;
            }
        }
    }

    /* Primitive. Inflate a single block. */

    /* InflatePlugin>>#primitiveInflateDecompressBlock */
    @TruffleBoundary(transferToInterpreterOnException = false)
    public void primitiveInflateDecompressBlock(final PointersObject rcvr, final NativeObject llTable, final NativeObject dTable) {
        zipDistTable = dTable.getIntStorage();
        /* literal table */
        zipDistTableSize = zipDistTable.length;
        zipLitTable = llTable.getIntStorage();
        /* Receiver (InflateStream) */
        zipLitTableSize = zipLitTable.length;
        zipReadLimit = fetchIntegerofObject(2, rcvr);
        zipState = fetchIntegerofObject(readStreamInstSize, rcvr);
        zipBitBuf = fetchIntegerofObject(readStreamInstSize + 1, rcvr);
        zipBitPos = fetchIntegerofObject(readStreamInstSize + 2, rcvr);
        zipSourcePos = fetchIntegerofObject(readStreamInstSize + 4, rcvr);
        zipSourceLimit = fetchIntegerofObject(readStreamInstSize + 5, rcvr);
        zipReadLimit--;
        zipSourcePos--;
        /* collection */
        zipSourceLimit--;
        zipCollection = fetchBytePointerOfObject(rcvr, 0);
        /* source */
        zipCollectionSize = zipCollection.length;
        /* do the primitive */
        zipSource = fetchBytePointerOfObject(rcvr, readStreamInstSize + 3);
        zipDecompressBlock();
        /* store modified values back */
        storeIntegerofObjectwithValue(2, rcvr, zipReadLimit + 1);
        storeIntegerofObjectwithValue(readStreamInstSize, rcvr, zipState);
        storeIntegerofObjectwithValue(readStreamInstSize + 1, rcvr, zipBitBuf);
        storeIntegerofObjectwithValue(readStreamInstSize + 2, rcvr, zipBitPos);
        storeIntegerofObjectwithValue(readStreamInstSize + 4, rcvr, zipSourcePos + 1);
    }

    /* Primitive. Update a 32bit CRC value. */

    /* DeflatePlugin>>#primitiveUpdateAdler32 */
    public static long primitiveUpdateAdler32(final long adler32, final int startIndex, final int stopIndex, final NativeObject collection) {
        final byte[] bytes = collection.getByteStorage();
        int s1 = (int) (adler32 & 0xFFFF);
        int s2 = (int) (adler32 >> 16 & 0xFFFF);
        for (int i = startIndex - 1; i <= stopIndex - 1; i++) {
            final int b = Byte.toUnsignedInt(bytes[i]);
            s1 = mod(s1 + b, 65521);
            s2 = mod(s2 + s1, 65521);
        }
        return Integer.toUnsignedLong((s2 << 16) + s1);
    }

    /* Primitive. Update a 32bit CRC value. */

    /* DeflatePlugin>>#primitiveUpdateGZipCrc32 */
    public static long primitiveUpdateGZipCrc32(final NativeObject collection, final int startIndex, final int stopIndex, final long crc) {
        long result = crc;
        final byte[] bytes = collection.getByteStorage();
        for (int i = startIndex - 1; i <= stopIndex - 1; i++) {
            result = zipCrcTable[(int) ((result ^ Byte.toUnsignedInt(bytes[i])) & 0xFF)] ^ result >> 8;
        }
        return result;
    }

    /* DeflatePlugin>>#primitiveZipSendBlock */
    public long primitiveZipSendBlock(final PointersObject rcvr, final PointersObject litStream, final PointersObject distStream,
                    final PointersObject litTree, final PointersObject distTree) {
        /* DeflatePlugin>>#loadZipEncoderFrom: */
        zipCollection = fetchBytePointerOfObject(rcvr, 0);
        zipCollectionSize = zipCollection.length;
        zipPosition = fetchIntegerofObject(1, rcvr);
        /* zipWriteLimit := interpreterProxy fetchInteger: 3 ofObject: rcvr. */
        zipReadLimit = fetchIntegerofObject(2, rcvr);
        zipBitBuf = fetchIntegerofObject(writeStreamInstSize + 0, rcvr);
        zipBitPos = fetchIntegerofObject(writeStreamInstSize + 1, rcvr);
        final long result = sendBlockwithwithwith(litStream, distStream, litTree, distTree);
        storeIntegerofObjectwithValue(1, rcvr, zipPosition);
        storeIntegerofObjectwithValue(writeStreamInstSize + 0, rcvr, zipBitBuf);
        storeIntegerofObjectwithValue(writeStreamInstSize + 1, rcvr, zipBitPos);
        return result;
    }

    /*
     * Require: zipCollection, zipCollectionSize, zipPosition, zipBitBuf, zipBitPos.
     */

    /* DeflatePlugin>>#sendBlock:with:with:with: */
    private int sendBlockwithwithwith(final PointersObject literalStream, final PointersObject distanceStream, final PointersObject litTree,
                    final PointersObject distTree) {
        int litPos = fetchIntegerofObject(1, literalStream);
        final int litLimit = fetchIntegerofObject(2, literalStream);
        final byte[] litArray = fetchBytePointerOfObject(literalStream, 0);
        if (!(litPos <= litLimit && litLimit <= litArray.length)) {
            throw PrimitiveFailed.GENERIC_ERROR;
        }
        final int[] distArray = fetchNativePointerOfObject(distanceStream, 0);
        if (!(litLimit <= distArray.length && fetchIntegerofObject(1, distanceStream) == litPos && fetchIntegerofObject(2, distanceStream) == litLimit)) {
            throw PrimitiveFailed.GENERIC_ERROR;
        }
        final int[] llBitLengths = fetchNativePointerOfObject(litTree, 0);
        final int litBlCount = llBitLengths.length;
        final int[] llCodes = fetchNativePointerOfObjectWithExpectedLength(litTree, 1, litBlCount);
        final int[] distBitLengths = fetchNativePointerOfObject(distTree, 0);
        final int distBlCount = distBitLengths.length;
        final int[] distCodes = fetchNativePointerOfObjectWithExpectedLength(distTree, 1, distBlCount);
        nextZipBitsput(0, 0);
        int sum = 0;
        while (litPos < litLimit && zipPosition + 4 < zipCollectionSize) {
            byte lit = litArray[litPos];
            int dist = distArray[litPos];
            litPos++;
            if (dist == 0) {
                /* literal */
                sum++;
                if (lit >= litBlCount) {
                    throw PrimitiveFailed.GENERIC_ERROR;
                }
                nextZipBitsput(llBitLengths[Byte.toUnsignedInt(lit)], llCodes[Byte.toUnsignedInt(lit)]);
            } else {
                /* match */
                sum = sum + Byte.toUnsignedInt(lit) + DeflateMinMatch;
                // if (Byte.toUnsignedInt(lit) >= 256) {
                // throw PrimitiveFailed.GENERIC_ERROR;
                // }
                int code = zipMatchLengthCodes[Byte.toUnsignedInt(lit)];
                if (code >= litBlCount) {
                    throw PrimitiveFailed.GENERIC_ERROR;
                }
                nextZipBitsput(llBitLengths[code], llCodes[code]);
                int extra = zipExtraLengthBits[code - 257];
                if (extra != 0) {
                    lit -= zipBaseLength[code - 257];
                    nextZipBitsput(extra, Byte.toUnsignedInt(lit));
                }
                dist--;
                if (dist >= 32768) {
                    throw PrimitiveFailed.GENERIC_ERROR;
                }
                if (dist < 256) {
                    code = zipDistanceCodes[dist];
                } else {
                    code = zipDistanceCodes[256 + (dist >> 7)];
                }

                if (code >= distBlCount) {
                    throw PrimitiveFailed.GENERIC_ERROR;
                }
                nextZipBitsput(distBitLengths[code], distCodes[code]);
                extra = zipExtraDistanceBits[code];
                if (extra != 0) {
                    dist -= zipBaseDistance[code];
                    nextZipBitsput(extra, dist);
                }
            }
        }
        storeIntegerofObjectwithValue(1, literalStream, litPos);
        storeIntegerofObjectwithValue(1, distanceStream, litPos);
        return sum;
    }

    /*
     * Check if we should flush the current block. Flushing can be useful if the input
     * characteristics change.
     */

    /* DeflatePlugin>>#shouldFlush */
    private boolean shouldFlush() {
        if (zipLiteralCount == zipLiteralSize) {
            return true;
        }
        if ((zipLiteralCount & 0xFFF) != 0) {
            return false;
        }
        if (zipMatchCount * 10 <= zipLiteralCount) {
            /*
             * This is basically random data. There is no need to flush early since the overhead for
             * encoding the trees will add to the overall size
             */
            return false;
        }
        final int nLits = zipLiteralCount - zipMatchCount;
        if (nLits <= zipMatchCount) {
            return false;
        }
        return nLits * 4 <= zipMatchCount;
    }

    /* Update the hash value at position here (one based) */

    /* DeflatePlugin>>#updateHashAt: */
    private int updateHashAt(final int here) {
        return updateHash(zipCollection[here]);
    }

    /*
     * Update the running hash value based on the next input byte. Return the new updated hash
     * value.
     */

    /* DeflatePlugin>>#updateHash: */
    private int updateHash(final int nextValue) {
        return (zipHashValue << DeflateHashShift ^ nextValue) & DeflateHashMask;
    }

    /* Decode the next value in the receiver using the given huffman table. */

    /* InflatePlugin>>#zipDecodeValueFrom:size: */
    private int zipDecodeValueFromsize(final int[] table /* unsigned */, final int tableSize) {
        /* Initial bits needed */
        int bitsNeeded = (int) (Integer.toUnsignedLong(table[0]) >> 24);
        if (bitsNeeded > MaxBits) {
            throw PrimitiveFailed.GENERIC_ERROR;
        }
        /* First real table */
        int tableIndex = 2;
        while (true) {
            /* Get bits */
            final int bits = zipNextBits(bitsNeeded);
            final int index = tableIndex + bits - 1;
            if (index >= tableSize) {
                throw PrimitiveFailed.GENERIC_ERROR;
            }
            /* Lookup entry in table */
            final int value = table[index];
            if ((value & 0x3F000000) == 0) {
                return value;
            }
            /* Table offset in low 16 bit */
            tableIndex = value & 0xFFFF;
            /* Additional bits in high 8 bit */
            bitsNeeded = (int) (Integer.toUnsignedLong(value) >> 24 & 0xFF);
            if (bitsNeeded > MaxBits) {
                throw PrimitiveFailed.GENERIC_ERROR;
            }
        }
    }

    /* InflatePlugin>>#zipDecompressBlock */
    private void zipDecompressBlock() {
        final int max = zipCollectionSize - 1;
        while (zipReadLimit < max && zipSourcePos <= zipSourceLimit) {
            /* Back up stuff if we're running out of space */
            final int oldBits = zipBitBuf;
            final int oldBitPos = zipBitPos;
            final int oldPos = zipSourcePos;
            int value = zipDecodeValueFromsize(zipLitTable, zipLitTableSize);
            if (value < 256) {
                /* A literal */
                zipCollection[++zipReadLimit] = (byte) value;
            } else if (value == 256) { /* length/distance or end of block */
                /* End of block */
                zipState = zipState & StateNoMoreData;
                return;
            } else {
                int extra = (value >> 16) - 1;
                int length = value & 0xFFFF;
                if (extra > 0) {
                    length += zipNextBits(extra);
                }
                value = zipDecodeValueFromsize(zipDistTable, zipDistTableSize);
                extra = value >> 16;
                int distance = value & 0xFFFF;
                if (extra > 0) {
                    distance += zipNextBits(extra);
                }
                if (zipReadLimit + length >= max) {
                    zipBitBuf = oldBits;
                    zipBitPos = oldBitPos;
                    zipSourcePos = oldPos;
                    return;
                } else {
                    final int dstPos = zipReadLimit;
                    final int srcPos = zipReadLimit - distance;
                    // Cannot use System#arraycopy here
                    for (int i = 1; i <= length; i += 1) {
                        zipCollection[dstPos + i] = zipCollection[srcPos + i];
                    }
                    zipReadLimit += length;
                }
            }
        }
    }

    /* InflatePlugin>>#zipNextBits: */
    private int zipNextBits(final int n) {
        while (zipBitPos < n) {
            final int byteValue = Byte.toUnsignedInt(zipSource[++zipSourcePos]);
            zipBitBuf += shl(byteValue, zipBitPos);
            zipBitPos += 8;
        }
        final int bits = (int) (zipBitBuf & (1L << n) - 1);
        zipBitBuf = shr(zipBitBuf, n);
        zipBitPos -= n;
        return bits;
    }

    /*
     * GUARDS
     */

    public boolean readStreamHasCorrectSize(final PointersObject receiver) {
        if (readStreamInstSize == 0) {
            if (!determineSizeOfReadStream(receiver)) {
                return false;
            }
            if (receiver.size() < readStreamInstSize + 8) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                readStreamInstSize = 0;
                return false;
            }
        }
        return receiver.size() >= readStreamInstSize + 8;
    }

    public boolean writeStreamHasCorrectSize(final PointersObject receiver) {
        if (writeStreamInstSize == 0) {
            if (!determineSizeOfWriteStream(receiver)) {
                return false;
            }
            if (receiver.size() < writeStreamInstSize + 3) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                writeStreamInstSize = 0;
                return false;
            }
        }
        return receiver.size() >= writeStreamInstSize + 3;
    }

    /*
     * POLYFILLS
     */

    private static Object fetchPointerofObject(final int index, final PointersObject pointersOop) {
        return pointersOop.instVarAt0Slow(index);
    }

    private static byte[] fetchBytePointerOfObject(final PointersObject rcvr, final int index) {
        final Object oop = fetchPointerofObject(index, rcvr);
        if (!isBytes(oop)) {
            throw PrimitiveFailed.GENERIC_ERROR;
        }
        return ((NativeObject) oop).getByteStorage();
    }

    private static int[] fetchNativePointerOfObject(final PointersObject rcvr, final int index) {
        final Object oop = fetchPointerofObject(index, rcvr);
        if (!isWords(oop)) {
            throw PrimitiveFailed.GENERIC_ERROR;
        }
        return ((NativeObject) oop).getIntStorage();
    }

    private static int[] fetchNativePointerOfObjectWithExpectedLength(final PointersObject rcvr, final int index, final int expectedLength) {
        final Object oop = fetchPointerofObject(index, rcvr);
        if (!(isWords(oop) && ((NativeObject) oop).getIntLength() == expectedLength)) {
            throw PrimitiveFailed.GENERIC_ERROR;
        }
        return ((NativeObject) oop).getIntStorage();
    }

    private static int fetchIntegerofObject(final int index, final PointersObject arrayOop) {
        final Object value = fetchPointerofObject(index, arrayOop);
        if (value instanceof final Long l) {
            return MiscUtils.toIntExact(l);
        } else {
            throw PrimitiveFailed.GENERIC_ERROR;
        }
    }

    private static void storeIntegerofObjectwithValue(final int i, final PointersObject streamOop, final long value) {
        streamOop.instVarAtPut0Slow(i, value);
    }

    private static boolean isWords(final Object object) {
        return SqueakGuards.isNativeObject(object) && ((NativeObject) object).isIntType();
    }

    private static boolean isBytes(final Object object) {
        return SqueakGuards.isNativeObject(object) && ((NativeObject) object).isTruffleStringType();
    }

    private static int shl(final int a, final int b) {
        return b > 31 ? 0 : a << b;
    }

    private static int shr(final int a, final int b) {
        return b > 31 ? 0 : a >>> b;
    }

    private static int div(final int a, final int b) {
        return (int) ((double) a / b);
    }

    private static int mod(final int a, final int b) {
        return a - div(a, b) * b;
    }

}
